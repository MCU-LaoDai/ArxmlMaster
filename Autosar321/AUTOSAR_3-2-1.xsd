<?xml version="1.0" encoding="UTF-8"?>
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" attributeFormDefault="unqualified" elementFormDefault="qualified" targetNamespace="http://autosar.org/3.2.1" xmlns:AR="http://autosar.org/3.2.1">
   <!--
AUTOSAR Schema Definition
-->
   <!-- 
Document Owner: AUTOSAR
Document Responsibility: AUTOSAR
Document Identification No: 230
Document Classification: Standard
Document Version: 3.5.0
Document Status: Final
Part of Release: 3.2
Revision: 1 
-->
   <!--
Disclaimer

This specification and the material contained in it, as released by AUTOSAR, 
is for the purpose of information only. AUTOSAR and the companies that have 
contributed to it shall not be liable for any use of the specification.

The material contained in this specification is protected by copyright and 
other types of Intellectual Property Rights. The commercial exploitation of 
the material contained in this specification requires a license to such 
Intellectual Property Rights.

This specification may be utilized or reproduced without any modification, in 
any form or by any means, for informational purposes only.
For any other purpose, no part of the specification may be utilized or 
reproduced, in any form or by any means, without permission in writing from 
the publisher.

The AUTOSAR specifications have been developed for automotive applications 
only. They have neither been developed, nor tested for non-automotive 
applications.

The word AUTOSAR and the AUTOSAR logo are registered trademarks.



Advice for users

AUTOSAR specifications may contain exemplary items (exemplary reference models,
"use cases", and/or references to exemplary technical solutions, devices, 
processes or software).

Any such exemplary items are contained in the specifications for illustration 
purposes only, and they themselves are not part of the AUTOSAR Standard. 
Neither their presence in such specifications, nor any later documentation of 
AUTOSAR conformance of products actually implementing such exemplary items, 
imply that intellectual property rights covering such exemplary items are 
licensed under the same rules as applicable to the AUTOSAR Standard.

-->
   <!-- element group for class Peripherals::ADC -->
   <xsd:group name="ADC">
      <xsd:annotation>
         <xsd:documentation>An ADC converts an analogue signal at an input pin to a digital value. The analogue signal are quantified to a maximum number of different levels defined by the resolution of the ADC. The Accuracy of the ADC is important for the overall functionality.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ADC"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BEHAVIOUR-AT-LIMIT" type="AR:ADC-BEHAVIOUR-AT-LIMIT-ENUM">
            <xsd:annotation>
               <xsd:documentation>Defines the action that is going to be performed when a limit is reached.
            - Clipping: Logical value is limited to minimal or maximal range of the value range. E.g. The max. resolution of an ADC is at 5V represented 0xFF; in case off clipping a voltage of 6V is also represented as 0xFF;
            - Undefined: Exceeding the resolution results in an undefined representation of the logical value. 
            - Default: Exceeding the resolution results in a predefined default value. The default value might be a value, which report the status to the application e.g. as an error condition. 
            - Other: A predefined function occur in order to prevent a undefined logical value. A typical application is a "Soft-Clipping" in a logarithmic form at the limit of the resolutions in audio applications.  The according methods have to be specified in the signal description.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ADC.behaviourAtLimit";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Peripherals::ADC -->
   <xsd:complexType abstract="false" mixed="false" name="ADC">
      <xsd:annotation>
         <xsd:documentation>An ADC converts an analogue signal at an input pin to a digital value. The analogue signal are quantified to a maximum number of different levels defined by the resolution of the ADC. The Accuracy of the ADC is important for the overall functionality.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ADC"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HW-ELEMENT"/>
         <xsd:group ref="AR:PERIPHERAL"/>
         <xsd:group ref="AR:ANALOGUE-IO"/>
         <xsd:group ref="AR:ADC"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Datatypes::ARLimit -->
   <xsd:group name="AR-LIMIT">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ARLimit"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VALUE" type="xsd:string">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ARLimit.value";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.roleElement="false";xml.roleWrapperElement="false";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- attribute group for class Datatypes::ARLimit -->
   <xsd:attributeGroup name="AR-LIMIT">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ARLimit"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="INTERVAL-TYPE" type="AR:INTERVAL-TYPE-ENUM">
         <xsd:annotation>
            <xsd:appinfo source="tags">mmt.qualifiedName="ARLimit.intervalType";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class Datatypes::ARLimit -->
   <xsd:complexType name="AR-LIMIT">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ARLimit"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="xsd:string">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
            <xsd:attributeGroup ref="AR:AR-LIMIT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <!-- attribute group for class Infrastructure::ARObject -->
   <xsd:attributeGroup name="AR-OBJECT">
      <xsd:annotation>
         <xsd:documentation>Implicit base class of all classes in metamodel.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ARObject"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="S" type="xsd:string">
         <xsd:annotation>
            <xsd:documentation>checksum calculated from the 
         * attributes
         * aggregations and aggregated non-identifiables
         * references</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="ARObject.checksum";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true";xml.name="S"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="T" type="xsd:dateTime">
         <xsd:annotation>
            <xsd:documentation>the timestamp of the creation or modification of an instance, its attributes, references or aggregated non-identifiables.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="ARObject.timestamp";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true";xml.name="T"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- element group for class Autosar::ARPackage -->
   <xsd:group name="AR-PACKAGE">
      <xsd:annotation>
         <xsd:documentation>AUTOSAR package, allowing to create top level packages to structure the contained ARElements.

      ARPackages are open sets, which means that in a file based description system, multiple files can be used to partially describe the contents of a package.

      This is an extended version of MSR's SW-SYSTEM.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ARPackage"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ELEMENTS">
            <xsd:annotation>
               <xsd:documentation>Elements that are part of this package</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="element.ARPackage";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ADC" type="AR:ADC"/>
                  <xsd:element name="ACTUATOR-HW" type="AR:ACTUATOR-HW"/>
                  <xsd:element name="APPLICATION-SOFTWARE-COMPONENT-TYPE" type="AR:APPLICATION-SOFTWARE-COMPONENT-TYPE"/>
                  <xsd:element name="ARRAY-TYPE" type="AR:ARRAY-TYPE"/>
                  <xsd:element name="BOOLEAN-TYPE" type="AR:BOOLEAN-TYPE"/>
                  <xsd:element name="BSW-BEHAVIOR" type="AR:BSW-BEHAVIOR"/>
                  <xsd:element name="BSW-IMPLEMENTATION" type="AR:BSW-IMPLEMENTATION"/>
                  <xsd:element name="BSW-MODULE-DESCRIPTION" type="AR:BSW-MODULE-DESCRIPTION"/>
                  <xsd:element name="BSW-MODULE-ENTRY" type="AR:BSW-MODULE-ENTRY"/>
                  <xsd:element name="CCU" type="AR:CCU"/>
                  <xsd:element name="CALPRM-COMPONENT-TYPE" type="AR:CALPRM-COMPONENT-TYPE"/>
                  <xsd:element name="CALPRM-INTERFACE" type="AR:CALPRM-INTERFACE"/>
                  <xsd:element name="CAN-CLUSTER" type="AR:CAN-CLUSTER"/>
                  <xsd:element name="CHAR-TYPE" type="AR:CHAR-TYPE"/>
                  <xsd:element name="CLIENT-SERVER-INTERFACE" type="AR:CLIENT-SERVER-INTERFACE"/>
                  <xsd:element name="CLOCK" type="AR:CLOCK"/>
                  <xsd:element name="COMMUNICATION-CLUSTER" type="AR:COMMUNICATION-CLUSTER"/>
                  <xsd:element name="COMMUNICATION-PERIPHERAL" type="AR:COMMUNICATION-PERIPHERAL"/>
                  <xsd:element name="COMMUNICATION-TRANSCEIVER" type="AR:COMMUNICATION-TRANSCEIVER"/>
                  <xsd:element name="COMPLEX-DEVICE-DRIVER-COMPONENT-TYPE" type="AR:COMPLEX-DEVICE-DRIVER-COMPONENT-TYPE"/>
                  <xsd:element name="COMPOSITION-TYPE" type="AR:COMPOSITION-TYPE"/>
                  <xsd:element name="COMPU-METHOD" type="AR:COMPU-METHOD"/>
                  <xsd:element name="CONSTANT-SPECIFICATION" type="AR:CONSTANT-SPECIFICATION"/>
                  <xsd:element name="DAC" type="AR:DAC"/>
                  <xsd:element name="DATA-CONSTR" type="AR:DATA-CONSTR"/>
                  <xsd:element name="DCM-I-PDU" type="AR:DCM-I-PDU"/>
                  <xsd:element name="DIGITAL-IO" type="AR:DIGITAL-IO"/>
                  <xsd:element name="DISCRETE-ECU-ELECTRONICS" type="AR:DISCRETE-ECU-ELECTRONICS"/>
                  <xsd:element name="DISPLAY-HW" type="AR:DISPLAY-HW"/>
                  <xsd:element name="ECU" type="AR:ECU"/>
                  <xsd:element name="ECU-ABSTRACTION-COMPONENT-TYPE" type="AR:ECU-ABSTRACTION-COMPONENT-TYPE"/>
                  <xsd:element name="ECU-CONFIGURATION" type="AR:ECU-CONFIGURATION"/>
                  <xsd:element name="ECU-INSTANCE" type="AR:ECU-INSTANCE"/>
                  <xsd:element name="ECU-PARAMETER-DEFINITION" type="AR:ECU-PARAMETER-DEFINITION"/>
                  <xsd:element name="ECU-SW-COMPOSITION" type="AR:ECU-SW-COMPOSITION"/>
                  <xsd:element name="END-TO-END-PROTECTION-SET" type="AR:END-TO-END-PROTECTION-SET"/>
                  <xsd:element name="FLEXRAY-CLUSTER" type="AR:FLEXRAY-CLUSTER"/>
                  <xsd:element name="FRAME" type="AR:FRAME"/>
                  <xsd:element name="GATEWAY" type="AR:GATEWAY"/>
                  <xsd:element name="HW-CONTAINER" type="AR:HW-CONTAINER"/>
                  <xsd:element name="I-PDU-GROUP" type="AR:I-PDU-GROUP"/>
                  <xsd:element name="I-SIGNAL" type="AR:I-SIGNAL"/>
                  <xsd:element name="IMPLEMENTATION" type="AR:IMPLEMENTATION"/>
                  <xsd:element name="INTEGER-TYPE" type="AR:INTEGER-TYPE"/>
                  <xsd:element name="INTERNAL-BEHAVIOR" type="AR:INTERNAL-BEHAVIOR"/>
                  <xsd:element name="LIN-CLUSTER" type="AR:LIN-CLUSTER"/>
                  <xsd:element name="MODE-DECLARATION-GROUP" type="AR:MODE-DECLARATION-GROUP"/>
                  <xsd:element name="MODULE-CONFIGURATION" type="AR:MODULE-CONFIGURATION"/>
                  <xsd:element name="MODULE-DEF" type="AR:MODULE-DEF"/>
                  <xsd:element name="MULTIPLEXED-I-PDU" type="AR:MULTIPLEXED-I-PDU"/>
                  <xsd:element name="N-PDU" type="AR:N-PDU"/>
                  <xsd:element name="NM-PDU" type="AR:NM-PDU"/>
                  <xsd:element name="OPAQUE-TYPE" type="AR:OPAQUE-TYPE"/>
                  <xsd:element name="OSCILLATOR" type="AR:OSCILLATOR"/>
                  <xsd:element name="PWD" type="AR:PWD"/>
                  <xsd:element name="PWM" type="AR:PWM"/>
                  <xsd:element name="PDUR-I-PDU-GROUP" type="AR:PDUR-I-PDU-GROUP"/>
                  <xsd:element name="PERIPHERAL" type="AR:PERIPHERAL"/>
                  <xsd:element name="PHYSICAL-DIMENSION" type="AR:PHYSICAL-DIMENSION"/>
                  <xsd:element name="POWER-DRIVER-HW-ELEMENT" type="AR:POWER-DRIVER-HW-ELEMENT"/>
                  <xsd:element name="POWER-SUPPLY-HW-ELEMENT" type="AR:POWER-SUPPLY-HW-ELEMENT"/>
                  <xsd:element name="PROCESSING-UNIT" type="AR:PROCESSING-UNIT"/>
                  <xsd:element name="PROVIDED-MEMORY-SEGMENT" type="AR:PROVIDED-MEMORY-SEGMENT"/>
                  <xsd:element name="PROVIDED-NV-MEMORY-SEGMENT" type="AR:PROVIDED-NV-MEMORY-SEGMENT"/>
                  <xsd:element name="REAL-TYPE" type="AR:REAL-TYPE"/>
                  <xsd:element name="RECORD-TYPE" type="AR:RECORD-TYPE"/>
                  <xsd:element name="SENDER-RECEIVER-INTERFACE" type="AR:SENDER-RECEIVER-INTERFACE"/>
                  <xsd:element name="SENSOR-ACTUATOR-SOFTWARE-COMPONENT-TYPE" type="AR:SENSOR-ACTUATOR-SOFTWARE-COMPONENT-TYPE"/>
                  <xsd:element name="SENSOR-HW" type="AR:SENSOR-HW"/>
                  <xsd:element name="SERVICE-COMPONENT-TYPE" type="AR:SERVICE-COMPONENT-TYPE"/>
                  <xsd:element name="SIGNAL-I-PDU" type="AR:SIGNAL-I-PDU"/>
                  <xsd:element name="STRING-TYPE" type="AR:STRING-TYPE"/>
                  <xsd:element name="SUBSTITUTION-FRAME" type="AR:SUBSTITUTION-FRAME"/>
                  <xsd:element name="SW-ADDR-METHOD" type="AR:SW-ADDR-METHOD"/>
                  <xsd:element name="SW-AXIS-TYPE" type="AR:SW-AXIS-TYPE"/>
                  <xsd:element name="SW-BASE-TYPE" type="AR:SW-BASE-TYPE"/>
                  <xsd:element name="SW-CLASS-INSTANCE" type="AR:SW-CLASS-INSTANCE"/>
                  <xsd:element name="SW-CODE-SYNTAX" type="AR:SW-CODE-SYNTAX"/>
                  <xsd:element name="SW-RECORD-LAYOUT" type="AR:SW-RECORD-LAYOUT"/>
                  <xsd:element name="SW-SERVICE" type="AR:SW-SERVICE"/>
                  <xsd:element name="SWC-IMPLEMENTATION" type="AR:SWC-IMPLEMENTATION"/>
                  <xsd:element name="SYSTEM" type="AR:SYSTEM"/>
                  <xsd:element name="SYSTEM-SIGNAL" type="AR:SYSTEM-SIGNAL"/>
                  <xsd:element name="SYSTEM-SIGNAL-GROUP" type="AR:SYSTEM-SIGNAL-GROUP"/>
                  <xsd:element name="TIMER" type="AR:TIMER"/>
                  <xsd:element name="UNIT" type="AR:UNIT"/>
                  <xsd:element name="USER-DEFINED-I-PDU" type="AR:USER-DEFINED-I-PDU"/>
                  <xsd:element name="USER-DEFINED-PDU" type="AR:USER-DEFINED-PDU"/>
                  <xsd:element name="WATCH-DOG" type="AR:WATCH-DOG"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SUB-PACKAGES">
            <xsd:annotation>
               <xsd:documentation>Contained sub packages.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="subPackage.ARPackage";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="AR-PACKAGE" type="AR:AR-PACKAGE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Autosar::ARPackage -->
   <xsd:complexType abstract="false" mixed="false" name="AR-PACKAGE">
      <xsd:annotation>
         <xsd:documentation>AUTOSAR package, allowing to create top level packages to structure the contained ARElements.

      ARPackages are open sets, which means that in a file based description system, multiple files can be used to partially describe the contents of a package.

      This is an extended version of MSR's SW-SYSTEM.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ARPackage"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:AR-PACKAGE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Autosar::AUTOSAR -->
   <xsd:group name="AUTOSAR">
      <xsd:annotation>
         <xsd:documentation>Root element of an AUTOSAR description, also the root element in corresponding XML documents.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AUTOSAR";xml.globalElement="true"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ADMIN-DATA" type="AR:ADMIN-DATA">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AUTOSAR.adminData";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TOP-LEVEL-PACKAGES">
            <xsd:annotation>
               <xsd:documentation>Top level packages of a description.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="topLevelPackage.AUTOSAR";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="AR-PACKAGE" type="AR:AR-PACKAGE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Autosar::AUTOSAR -->
   <xsd:complexType abstract="false" mixed="false" name="AUTOSAR">
      <xsd:annotation>
         <xsd:documentation>Root element of an AUTOSAR description, also the root element in corresponding XML documents.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AUTOSAR";xml.globalElement="true"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AUTOSAR"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- global element for class Autosar::AUTOSAR -->
   <xsd:element name="AUTOSAR" type="AR:AUTOSAR">
      <xsd:annotation>
         <xsd:documentation>Root element of an AUTOSAR description, also the root element in corresponding XML documents.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AUTOSAR";xml.globalElement="true"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
   </xsd:element>
   <!-- element group for class Timing::AbsoluteTolerance -->
   <xsd:group name="ABSOLUTE-TOLERANCE">
      <xsd:annotation>
         <xsd:documentation>Maximum allowable deviation</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AbsoluteTolerance"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ABSOLUTE" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Maximum allowable deviation in duration (in seconds)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AbsoluteTolerance.absolute";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Timing::AbsoluteTolerance -->
   <xsd:complexType abstract="false" mixed="false" name="ABSOLUTE-TOLERANCE">
      <xsd:annotation>
         <xsd:documentation>Maximum allowable deviation</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AbsoluteTolerance"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:ABSOLUTE-TOLERANCE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class FlexrayCommunication::AbsolutelyScheduledTiming -->
   <xsd:group name="ABSOLUTELY-SCHEDULED-TIMING">
      <xsd:annotation>
         <xsd:documentation>Each frame in FlexRay is identified by its slot id and communication cycle. A description is provided by the usage of AbsolutelyScheduledTiming. 

      In the static segment a frame can be sent multiple times within one communication cycle. For describing this case multiple AbsolutelyScheduledTimings have to be used. The main use case would be that a frame is sent twice within one communication cycle.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AbsolutelyScheduledTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMMUNICATION-CYCLE">
            <xsd:annotation>
               <xsd:documentation>The communication cycle where the frame is sent.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="communicationCycle.AbsolutelyScheduledTiming";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="CYCLE-COUNTER" type="AR:CYCLE-COUNTER"/>
                  <xsd:element name="CYCLE-REPETITION" type="AR:CYCLE-REPETITION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SLOT-ID" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>In the static part the SlotID defines the slot in which the frame is transmitted. 
            The SlotID also determines, in combination with FlexrayCluster::numberOfStaticSlots, whether the frame is sent in static or dynamic segment. 
            In the dynamic part, the slot id is equivalent to a priority. Lower dynamic slot ids are all sent until the end of the dynamic segment. Higher numbers, which were ignored that time, have to wait one cycle and then must try again.

            minValue: 1
            maxValue: 2047</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AbsolutelyScheduledTiming.slotID";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class FlexrayCommunication::AbsolutelyScheduledTiming -->
   <xsd:complexType abstract="false" mixed="false" name="ABSOLUTELY-SCHEDULED-TIMING">
      <xsd:annotation>
         <xsd:documentation>Each frame in FlexRay is identified by its slot id and communication cycle. A description is provided by the usage of AbsolutelyScheduledTiming. 

      In the static segment a frame can be sent multiple times within one communication cycle. For describing this case multiple AbsolutelyScheduledTimings have to be used. The main use case would be that a frame is sent twice within one communication cycle.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AbsolutelyScheduledTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:ABSOLUTELY-SCHEDULED-TIMING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <xsd:simpleType name="ABSTRACT-SIGNAL--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="SYSTEM-SIGNAL"/>
         <xsd:enumeration value="SYSTEM-SIGNAL-GROUP"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class SensorActuator::ActuatorHW -->
   <xsd:group name="ACTUATOR-HW">
      <xsd:annotation>
         <xsd:documentation>HW Element Actuator definition.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ActuatorHW"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DEFAULT-POSITION-TYPE" type="AR:ACTUATOR-HW-DEFAULT-POSITIOIN-TYPE-ENUM">
            <xsd:annotation>
               <xsd:documentation>Defines the way the actuator is seen after power on. On Bi-Stable or Multistable actuators the software has to know the status of this device after reset or Power On.
            Each actuator has a control input that determines its behaviour</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ActuatorHW.defaultPositionType";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DEFAULT-POSITION-VALUE" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>If there is a specific default value is available. E.g. Valve status = off;</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ActuatorHW.defaultPositionValue";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ELECTRICAL-TYPE" type="AR:ACTUATOR-HW-ELECTRICAL-TYPE-ENUM">
            <xsd:annotation>
               <xsd:documentation>Defines the most typical electrical behaviour of the system. This information is necessary for the ECU generation process and for tools which check for later interaction of the different component. (avoid resonance's, planning of the ECU power management).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ActuatorHW.electricalType";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ENDURANCE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Number of activation cycles the actuator is designed for.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ActuatorHW.endurance";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MOVEMENT" type="AR:ACTUATOR-HW-MOVEMENT-ENUM">
            <xsd:annotation>
               <xsd:documentation>Defines the way the movement is controlled by AUTOSAR. Positional feedback can be provided by the actuator by the conglomeration of the requisite actuator and sensor primitives.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ActuatorHW.movement";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SensorActuator::ActuatorHW -->
   <xsd:complexType abstract="false" mixed="false" name="ACTUATOR-HW">
      <xsd:annotation>
         <xsd:documentation>HW Element Actuator definition.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ActuatorHW"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HW-ELEMENT"/>
         <xsd:group ref="AR:SENSOR-ACTUATOR-HW"/>
         <xsd:group ref="AR:ACTUATOR-HW"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class AdminData::AdminData -->
   <xsd:group name="ADMIN-DATA">
      <xsd:annotation>
         <xsd:documentation>&lt;adminData&gt; can be used to set administrative information for an element. This administration information is to be treated as metadata such as revision id or state of the file. There are basically four kinds of metadata

      * The language and/or used laguages.

      * Revision information covering e.g. revision number, state, release date, changes. Note that this information can be given in general as well as related to a particular company.

      * Document metadata specific for a company

      * Formatting controls that can affect layouts for example.

      * Revision information for the element.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AdminData"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="LANGUAGE" type="AR:L-ENUM">
            <xsd:annotation>
               <xsd:documentation>This attribute  specifies the master language of the document or the document fragment. The master language is the one in which the document is maintained and from which the other languages are derived from.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AdminData.language";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="USED-LANGUAGES" type="AR:ML-DATA-10">
            <xsd:annotation>
               <xsd:documentation>Use &lt;usedLanguages&gt; to enter all other languages, in addition to the document language, which are used an a document or a section of a document.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AdminData.usedLanguages";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DOC-REVISIONS">
            <xsd:annotation>
               <xsd:documentation>Use &lt;docRevision&gt; , to generate information on the corresponding document version.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AdminData.docRevision";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="true";xml.roleWrapperElement="true";xml.sequenceOffset="50";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="DOC-REVISION" type="AR:DOC-REVISION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SDGS">
            <xsd:annotation>
               <xsd:documentation>&lt;sdg&gt; (Special Data Group) is a backdoor used to handle elements that has not yet been defined in a DTD. The &lt;sdg&gt; is a containder for one or several &lt;sd&gt; that defines new elements and carries the information. Special Data should only be used moderately since all elements should be defined in the dtd. Thereby should SDG be considered as a temporary sollution when elements are missing. If a &lt;sdgCaption&gt; element is created along with a &lt;shortName&gt; it is possible to reference the &lt;sdg&gt; structure via a &lt;xref&gt;.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AdminData.sdg";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="true";xml.roleWrapperElement="true";xml.sequenceOffset="60";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SDG" type="AR:SDG"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class AdminData::AdminData -->
   <xsd:complexType abstract="false" mixed="false" name="ADMIN-DATA">
      <xsd:annotation>
         <xsd:documentation>&lt;adminData&gt; can be used to set administrative information for an element. This administration information is to be treated as metadata such as revision id or state of the file. There are basically four kinds of metadata

      * The language and/or used laguages.

      * Revision information covering e.g. revision number, state, release date, changes. Note that this information can be given in general as well as related to a particular company.

      * Document metadata specific for a company

      * Formatting controls that can affect layouts for example.

      * Revision information for the element.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AdminData"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:ADMIN-DATA"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- complex type for class Filter::Always -->
   <xsd:complexType abstract="false" mixed="false" name="ALWAYS">
      <xsd:annotation>
         <xsd:documentation>No filtering is performed so that the message always passes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Always"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Peripherals::AnalogueIO -->
   <xsd:group name="ANALOGUE-IO">
      <xsd:annotation>
         <xsd:documentation>These are the common attributes for both, the ADC and the DAC.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AnalogueIO"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ACCURACY" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>There is a number of different conversion error in an ADC or DAC like non-linearity and absolute error. The accuracy is defined as the total error and it can be expressed as a deviation from its nominal value by e.g. 0.5, 1.0, 1.5 or 2.0 LSB.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AnalogueIO.accuracy";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONVERSION-TIME" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>ADC: The conversion time is the definition how long it takes for an ADC to convert an analogue signal to a digital value.
            DAC: The conversion time is the definition how long it takes for a DAC to convert a digital value to an analogue signal.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AnalogueIO.conversionTime";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EXTERNAL-REFERENCE-VOLTAGE" type="AR:ELECTRICAL-RANGE">
            <xsd:annotation>
               <xsd:documentation>The analogue comparator of an ADC must be connected to a voltage reference. An external voltage is usually connected to one low and one high voltage reference input pin.
            For an internal DAC it is normally only one voltage reference input. The low voltage reference input is internally connected to the analogue ground.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="externalReferenceVoltage.AnalogueIO";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODE" type="AR:ANALOGUE-IO-MODE-ENUM">
            <xsd:annotation>
               <xsd:documentation>An ADC or DAC can operate in continuous, single  or sequential mode. In the continuous mode the conversion is automatically repeated after a completion. In single shot only one conversion is performed. For the sequential mode can a predefined number of different analogue channels be converted.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AnalogueIO.mode";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MULTIPLEXED-M" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Defines the design of a simple multiplexer used by an ADC. Example A 2:8-multiplexer has 2 input channels and 8 registers. M is the second value.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AnalogueIO.multiplexedM";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MULTIPLEXED-N" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Defines the design of a simple multiplexer used by an ADC. Example A 2:8-multiplexer has 2 input channels and 8 registers. N is the first value.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AnalogueIO.multiplexedN";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RESOLUTION" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>For an Analogue to Digital Converter the resolution defines the number of different voltage levels, which are converted to a digital value. For example, an ADC with 10-bits resolution have the ability to convert an analogue value into 1024 different digital  values.
            Unit: Bits</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AnalogueIO.resolution";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="WIDTH" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The number of Bits used to store the digital value.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AnalogueIO.width";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Annotation::Annotation -->
   <xsd:complexType abstract="false" mixed="false" name="ANNOTATION">
      <xsd:annotation>
         <xsd:documentation>This is a plain annotation which does not have further formal data.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Annotation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:GENERAL-ANNOTATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class PortInterface::ApplicationError -->
   <xsd:group name="APPLICATION-ERROR">
      <xsd:annotation>
         <xsd:documentation>This is a user-defined error that is associated with an element of an AUTOSAR interface. It is specific for the particular functionality or service provided by the AUTOSAR software component.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ApplicationError"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ERROR-CODE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The RTE generator is forced to assign this value to the corresponding error symbol. Note that for error codes certain ranges are predefined (see RTE specification).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ApplicationError.errorCode";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class PortInterface::ApplicationError -->
   <xsd:complexType abstract="false" mixed="false" name="APPLICATION-ERROR">
      <xsd:annotation>
         <xsd:documentation>This is a user-defined error that is associated with an element of an AUTOSAR interface. It is specific for the particular functionality or service provided by the AUTOSAR software component.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ApplicationError"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:APPLICATION-ERROR"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="APPLICATION-ERROR--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="APPLICATION-ERROR"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class DataMapping::ApplicationErrorMapping -->
   <xsd:group name="APPLICATION-ERROR-MAPPING">
      <xsd:annotation>
         <xsd:documentation>In client server communication, the server may return any value within the application error range.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ApplicationErrorMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYSTEM-SIGNAL-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the SystemSignal with the ApplicationError.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ApplicationErrorMapping.systemSignal";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SYSTEM-SIGNAL--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataMapping::ApplicationErrorMapping -->
   <xsd:complexType abstract="false" mixed="false" name="APPLICATION-ERROR-MAPPING">
      <xsd:annotation>
         <xsd:documentation>In client server communication, the server may return any value within the application error range.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ApplicationErrorMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:APPLICATION-ERROR-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- complex type for class Components::ApplicationSoftwareComponentType -->
   <xsd:complexType abstract="false" mixed="false" name="APPLICATION-SOFTWARE-COMPONENT-TYPE">
      <xsd:annotation>
         <xsd:documentation>The ApplicationSoftwareComponentType is used to represent the application software.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ApplicationSoftwareComponentType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpType</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COMPONENT-TYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Characteristic::ArCalprmRef -->
   <xsd:group name="AR-CALPRM-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ArCalprmRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="AR-CALPRM-IREF" type="AR:AR-CALPRM-REF--CALPRM-ELEMENT-PROTOTYPE-IREF">
            <xsd:annotation>
               <xsd:documentation>This represents the referred arCalprm.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ArCalprmRef.arCalprm";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Characteristic::ArCalprmRef -->
   <xsd:complexType abstract="false" mixed="false" name="AR-CALPRM-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ArCalprmRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-CALPRM-REF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class _instanceRef::ArCalprmRef_CalprmElementPrototype -->
   <xsd:group name="AR-CALPRM-REF--CALPRM-ELEMENT-PROTOTYPE-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ArCalprmRef_CalprmElementPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPONENT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ArCalprmRef_CalprmElementPrototype.componentPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMPONENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PORT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ArCalprmRef_CalprmElementPrototype.portPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="1" name="CALPRM-ELEMENT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ArCalprmRef_CalprmElementPrototype.calprmElementPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.target</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:CALPRM-ELEMENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class _instanceRef::ArCalprmRef_CalprmElementPrototype -->
   <xsd:complexType abstract="false" mixed="false" name="AR-CALPRM-REF--CALPRM-ELEMENT-PROTOTYPE-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ArCalprmRef_CalprmElementPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:AR-CALPRM-REF--CALPRM-ELEMENT-PROTOTYPE-IREF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class PortInterface::ArgumentPrototype -->
   <xsd:group name="ARGUMENT-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>An argument of an operation, much like a data element, but also carries direction information and is associated with a particular operation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ArgumentPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DIRECTION" type="AR:DIRECTION-KIND">
            <xsd:annotation>
               <xsd:documentation>This attribute controls the direction of the ArgumentPrototype according to the DirectionKind.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ArgumentPrototype.direction";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class PortInterface::ArgumentPrototype -->
   <xsd:complexType abstract="false" mixed="false" name="ARGUMENT-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>An argument of an operation, much like a data element, but also carries direction information and is associated with a particular operation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ArgumentPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:DATA-PROTOTYPE"/>
         <xsd:group ref="AR:ARGUMENT-PROTOTYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="ARGUMENT-PROTOTYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ARGUMENT-PROTOTYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Datatypes::ArrayElement -->
   <xsd:group name="ARRAY-ELEMENT">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ArrayElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-NUMBER-OF-ELEMENTS" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The maximum number of elements that the array can contain.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ArrayElement.maxNumberOfElements";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpMaxMultiplicity</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Datatypes::ArrayElement -->
   <xsd:complexType abstract="false" mixed="false" name="ARRAY-ELEMENT">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ArrayElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:DATA-PROTOTYPE"/>
         <xsd:group ref="AR:ARRAY-ELEMENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="ARRAY-ELEMENT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ARRAY-ELEMENT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Constants::ArraySpecification -->
   <xsd:group name="ARRAY-SPECIFICATION">
      <xsd:annotation>
         <xsd:documentation>A constant array, which refers to its elements by index.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ArraySpecification"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ELEMENTS">
            <xsd:annotation>
               <xsd:documentation>Elements of array.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="element.ArraySpecification";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ARRAY-SPECIFICATION" type="AR:ARRAY-SPECIFICATION"/>
                  <xsd:element name="BOOLEAN-LITERAL" type="AR:BOOLEAN-LITERAL"/>
                  <xsd:element name="CHAR-LITERAL" type="AR:CHAR-LITERAL"/>
                  <xsd:element name="CONSTANT-REFERENCE" type="AR:CONSTANT-REFERENCE"/>
                  <xsd:element name="INTEGER-LITERAL" type="AR:INTEGER-LITERAL"/>
                  <xsd:element name="OPAQUE-LITERAL" type="AR:OPAQUE-LITERAL"/>
                  <xsd:element name="REAL-LITERAL" type="AR:REAL-LITERAL"/>
                  <xsd:element name="RECORD-SPECIFICATION" type="AR:RECORD-SPECIFICATION"/>
                  <xsd:element name="STRING-LITERAL" type="AR:STRING-LITERAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Constants::ArraySpecification -->
   <xsd:complexType abstract="false" mixed="false" name="ARRAY-SPECIFICATION">
      <xsd:annotation>
         <xsd:documentation>A constant array, which refers to its elements by index.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ArraySpecification"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:DATA-PROTOTYPE"/>
         <xsd:group ref="AR:ARRAY-SPECIFICATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Datatypes::ArrayType -->
   <xsd:group name="ARRAY-TYPE">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ArrayType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpType</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ELEMENT" type="AR:ARRAY-ELEMENT">
            <xsd:annotation>
               <xsd:documentation>This represents a formal representation of the ArrayElement within ArrayType.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ArrayType.element";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Datatypes::ArrayType -->
   <xsd:complexType abstract="false" mixed="false" name="ARRAY-TYPE">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ArrayType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpType</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ARRAY-TYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Composition::AssemblyConnectorPrototype -->
   <xsd:group name="ASSEMBLY-CONNECTOR-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>AssemblyConnectorPrototypes are exclusively used to connect ComponentPrototypes in the context of a CompositionType.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AssemblyConnectorPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpStructureElement</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="PROVIDER-IREF" type="AR:ASSEMBLY-CONNECTOR-PROTOTYPE--PROVIDER-IREF">
            <xsd:annotation>
               <xsd:documentation>Instance of providing port.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="provider.AssemblyConnectorPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REQUESTER-IREF" type="AR:ASSEMBLY-CONNECTOR-PROTOTYPE--REQUESTER-IREF">
            <xsd:annotation>
               <xsd:documentation>Instance of requiring port.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="requester.AssemblyConnectorPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Composition::AssemblyConnectorPrototype -->
   <xsd:complexType abstract="false" mixed="false" name="ASSEMBLY-CONNECTOR-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>AssemblyConnectorPrototypes are exclusively used to connect ComponentPrototypes in the context of a CompositionType.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AssemblyConnectorPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpStructureElement</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ASSEMBLY-CONNECTOR-PROTOTYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class _instanceRef::AssemblyConnectorPrototype_provider -->
   <xsd:group name="ASSEMBLY-CONNECTOR-PROTOTYPE--PROVIDER-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AssemblyConnectorPrototype_provider"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPONENT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AssemblyConnectorPrototype_provider.componentPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="10"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMPONENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="1" name="P-PORT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AssemblyConnectorPrototype_provider.pPortPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.target</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:P-PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class _instanceRef::AssemblyConnectorPrototype_provider -->
   <xsd:complexType abstract="false" mixed="false" name="ASSEMBLY-CONNECTOR-PROTOTYPE--PROVIDER-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AssemblyConnectorPrototype_provider"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:ASSEMBLY-CONNECTOR-PROTOTYPE--PROVIDER-IREF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class _instanceRef::AssemblyConnectorPrototype_requester -->
   <xsd:group name="ASSEMBLY-CONNECTOR-PROTOTYPE--REQUESTER-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AssemblyConnectorPrototype_requester"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPONENT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AssemblyConnectorPrototype_requester.componentPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="10"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMPONENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="1" name="R-PORT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AssemblyConnectorPrototype_requester.rPortPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.target</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:R-PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class _instanceRef::AssemblyConnectorPrototype_requester -->
   <xsd:complexType abstract="false" mixed="false" name="ASSEMBLY-CONNECTOR-PROTOTYPE--REQUESTER-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AssemblyConnectorPrototype_requester"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:ASSEMBLY-CONNECTOR-PROTOTYPE--REQUESTER-IREF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ECUResourceTemplate::AssemblyHWConnection -->
   <xsd:group name="ASSEMBLY-HW-CONNECTION">
      <xsd:annotation>
         <xsd:documentation>An AssemblyHWConnection is established between at least two HWPorts provided by different HWElements. 
      The AssemblyHWConnection can only be established between HWPorts on the same hierarchical level. To connect accross hierarchical levels use the DelegationHWConnection.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AssemblyHWConnection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="HW-PORT-REFS">
            <xsd:annotation>
               <xsd:documentation>References to HWPorts connected by this AssemblyHWConnection.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AssemblyHWConnection.hwPort";pureMM.maxOccurs="-1";pureMM.minOccurs="2"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="HW-PORT-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:HW-PORT--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUResourceTemplate::AssemblyHWConnection -->
   <xsd:complexType abstract="false" mixed="false" name="ASSEMBLY-HW-CONNECTION">
      <xsd:annotation>
         <xsd:documentation>An AssemblyHWConnection is established between at least two HWPorts provided by different HWElements. 
      The AssemblyHWConnection can only be established between HWPorts on the same hierarchical level. To connect accross hierarchical levels use the DelegationHWConnection.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AssemblyHWConnection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HW-CONNECTION"/>
         <xsd:group ref="AR:ASSEMBLY-HW-CONNECTION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class LinCommunication::AssignFrameIdTiming -->
   <xsd:group name="ASSIGN-FRAME-ID-TIMING">
      <xsd:annotation>
         <xsd:documentation>Schedule entry for an  Assign Frame Id master request.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AssignFrameIdTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ASSIGNED-FRAME-TRIGGERING-REF">
            <xsd:annotation>
               <xsd:documentation>The frame whose identifier is set by this assignment.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AssignFrameIdTiming.assignedFrameTriggering";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:LIN-FRAME-TRIGGERING--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class LinCommunication::AssignFrameIdTiming -->
   <xsd:complexType abstract="false" mixed="false" name="ASSIGN-FRAME-ID-TIMING">
      <xsd:annotation>
         <xsd:documentation>Schedule entry for an  Assign Frame Id master request.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AssignFrameIdTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:RELATIVELY-SCHEDULED-TIMING"/>
         <xsd:group ref="AR:ASSIGNMENT-TIMING-TYPE"/>
         <xsd:group ref="AR:ASSIGN-FRAME-ID-TIMING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class LinCommunication::AssignNadTiming -->
   <xsd:group name="ASSIGN-NAD-TIMING">
      <xsd:annotation>
         <xsd:documentation>Schedule entry for an Assign NAD master request.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AssignNadTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="NEW-NAD" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The newly assigned NAD value (valid range 1..126)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AssignNadTiming.newNad";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class LinCommunication::AssignNadTiming -->
   <xsd:complexType abstract="false" mixed="false" name="ASSIGN-NAD-TIMING">
      <xsd:annotation>
         <xsd:documentation>Schedule entry for an Assign NAD master request.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AssignNadTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:RELATIVELY-SCHEDULED-TIMING"/>
         <xsd:group ref="AR:ASSIGNMENT-TIMING-TYPE"/>
         <xsd:group ref="AR:ASSIGN-NAD-TIMING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class LinCommunication::AssignmentTimingType -->
   <xsd:group name="ASSIGNMENT-TIMING-TYPE">
      <xsd:annotation>
         <xsd:documentation>A LIN specific extension of the common RelativelyScheduledTiming
      The extension describes the LIN specific assignment frames.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AssignmentTimingType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ASSIGNED-CONTROLLER-REF">
            <xsd:annotation>
               <xsd:documentation>The LIN slaves controller who is target of this assignment.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="AssignmentTimingType.assignedController";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:LIN-COMMUNICATION-CONTROLLER--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServerCall::AsynchronousServerCallPoint -->
   <xsd:complexType abstract="false" mixed="false" name="ASYNCHRONOUS-SERVER-CALL-POINT">
      <xsd:annotation>
         <xsd:documentation>An asynchronous server call-point is used for asynchronous invocation of an operation prototype. It is associated with AsynchronousServerCallReturnsEvent, this RTEEvent notifies the completion of the required operation or a timeout, this event can be waited for or it can lead to the invocation of a runnable. 
      IMPORTANT: a server-call-point cannot be used concurrently. Once the client runnable has made the invocation, the server-call-point cannot be used until the call returns (or an error occurs!) at which point the server call-point becomes available again...</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AsynchronousServerCallPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SERVER-CALL-POINT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="ASYNCHRONOUS-SERVER-CALL-POINT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ASYNCHRONOUS-SERVER-CALL-POINT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class RTEEvents::AsynchronousServerCallReturnsEvent -->
   <xsd:group name="ASYNCHRONOUS-SERVER-CALL-RETURNS-EVENT">
      <xsd:annotation>
         <xsd:documentation>This event is raised when an asynchronous server call is finished.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AsynchronousServerCallReturnsEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="EVENT-SOURCE-REF">
            <xsd:annotation>
               <xsd:documentation>The referenced server call point</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="event.eventSource";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ASYNCHRONOUS-SERVER-CALL-POINT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class RTEEvents::AsynchronousServerCallReturnsEvent -->
   <xsd:complexType abstract="false" mixed="false" name="ASYNCHRONOUS-SERVER-CALL-RETURNS-EVENT">
      <xsd:annotation>
         <xsd:documentation>This event is raised when an asynchronous server call is finished.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="AsynchronousServerCallReturnsEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:RTE-EVENT"/>
         <xsd:group ref="AR:ASYNCHRONOUS-SERVER-CALL-RETURNS-EVENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="ATOMIC-SOFTWARE-COMPONENT-TYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="APPLICATION-SOFTWARE-COMPONENT-TYPE"/>
         <xsd:enumeration value="COMPLEX-DEVICE-DRIVER-COMPONENT-TYPE"/>
         <xsd:enumeration value="ECU-ABSTRACTION-COMPONENT-TYPE"/>
         <xsd:enumeration value="SENSOR-ACTUATOR-SOFTWARE-COMPONENT-TYPE"/>
         <xsd:enumeration value="SERVICE-COMPONENT-TYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class BaseTypes::BaseType -->
   <xsd:group name="BASE-TYPE">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BaseType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:choice maxOccurs="1" minOccurs="0">
            <xsd:group ref="AR:BASE-TYPE-DIRECT-DEFINITION"/>
            <xsd:group ref="AR:BASE-TYPE-INDIRECT-DEFINITION"/>
         </xsd:choice>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class BaseTypes::BaseTypeAbsSize -->
   <xsd:group name="BASE-TYPE-ABS-SIZE">
      <xsd:annotation>
         <xsd:documentation>This is the absolute size of the basetype. In this case the BaseType is of fixed lenght.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BaseTypeAbsSize"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BASE-TYPE-SIZE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Describes the length of the data type specified in the container in bits.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BaseTypeAbsSize.baseTypeSize";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="60"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BaseTypes::BaseTypeAbsSize -->
   <xsd:complexType abstract="false" mixed="false" name="BASE-TYPE-ABS-SIZE">
      <xsd:annotation>
         <xsd:documentation>This is the absolute size of the basetype. In this case the BaseType is of fixed lenght.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BaseTypeAbsSize"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:BASE-TYPE-ABS-SIZE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class BaseTypes::BaseTypeDirectDefinition -->
   <xsd:group name="BASE-TYPE-DIRECT-DEFINITION">
      <xsd:annotation>
         <xsd:documentation>This BaseType is defined directly (as opposite to a derived BaseType)</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BaseTypeDirectDefinition"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:choice maxOccurs="1" minOccurs="0">
            <xsd:group ref="AR:BASE-TYPE-ABS-SIZE"/>
            <xsd:group ref="AR:BASE-TYPE-MAX-SIZE"/>
         </xsd:choice>
         <xsd:element maxOccurs="1" minOccurs="0" name="BASE-TYPE-ENCODING" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>This specifies, how an object of the current BaseType is encode eg. in an ECU in a message sequence.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BaseTypeDirectDefinition.baseTypeEncoding";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="90"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MEM-ALIGNMENT" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>describes the alignment of the memory object in bits. E.g. "1" specifies, that the object in question is aligned to a byte while "32" specifies that it is aligned four byte.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BaseTypeDirectDefinition.memAlignment";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="100"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="BYTE-ORDER" type="AR:BYTE-ORDER">
            <xsd:annotation>
               <xsd:documentation>This element specifies the byte order of the parent element. The byte order is defined with the attribute TYPE. Possible values are:

            * MOST-SIGNIFICANT-BYTE-FIRST

            * MOST-SIGNIFICANT-BYTE-LAST</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BaseTypeDirectDefinition.byteOrder";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="110"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BaseTypes::BaseTypeDirectDefinition -->
   <xsd:complexType abstract="false" mixed="false" name="BASE-TYPE-DIRECT-DEFINITION">
      <xsd:annotation>
         <xsd:documentation>This BaseType is defined directly (as opposite to a derived BaseType)</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BaseTypeDirectDefinition"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:BASE-TYPE-DIRECT-DEFINITION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class BaseTypes::BaseTypeIndirectDefinition -->
   <xsd:group name="BASE-TYPE-INDIRECT-DEFINITION">
      <xsd:annotation>
         <xsd:documentation>This BaseType is defined by referring to anotherone. This indirect definition allows to create alias base types.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BaseTypeIndirectDefinition"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BASE-TYPE-REF">
            <xsd:annotation>
               <xsd:documentation>This is the baseType on which the indirectly defined base type is derived.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BaseTypeIndirectDefinition.baseType";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="130"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-BASE-TYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BaseTypes::BaseTypeIndirectDefinition -->
   <xsd:complexType abstract="false" mixed="false" name="BASE-TYPE-INDIRECT-DEFINITION">
      <xsd:annotation>
         <xsd:documentation>This BaseType is defined by referring to anotherone. This indirect definition allows to create alias base types.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BaseTypeIndirectDefinition"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:BASE-TYPE-INDIRECT-DEFINITION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class BaseTypes::BaseTypeMaxSize -->
   <xsd:group name="BASE-TYPE-MAX-SIZE">
      <xsd:annotation>
         <xsd:documentation>This is the maximum size of a BaseType in case of a dynamic BaseType.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BaseTypeMaxSize"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-BASE-TYPE-SIZE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Describes the maximum length of the BaseType  in bits</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BaseTypeMaxSize.maxBaseTypeSize";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="80"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BaseTypes::BaseTypeMaxSize -->
   <xsd:complexType abstract="false" mixed="false" name="BASE-TYPE-MAX-SIZE">
      <xsd:annotation>
         <xsd:documentation>This is the maximum size of a BaseType in case of a dynamic BaseType.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BaseTypeMaxSize"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:BASE-TYPE-MAX-SIZE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Constants::BooleanLiteral -->
   <xsd:group name="BOOLEAN-LITERAL">
      <xsd:annotation>
         <xsd:documentation>Boolean constant expression.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BooleanLiteral"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VALUE" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>The Boolean value.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BooleanLiteral.value";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Constants::BooleanLiteral -->
   <xsd:complexType abstract="false" mixed="false" name="BOOLEAN-LITERAL">
      <xsd:annotation>
         <xsd:documentation>Boolean constant expression.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BooleanLiteral"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:DATA-PROTOTYPE"/>
         <xsd:group ref="AR:BOOLEAN-LITERAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUCParameterDefTemplate::BooleanParamDef -->
   <xsd:group name="BOOLEAN-PARAM-DEF">
      <xsd:annotation>
         <xsd:documentation>Configuration parameter type for Boolean. allowed values are true and false.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BooleanParamDef";xml.sequenceOffset="0"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DEFAULT-VALUE" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Default value of the boolean configuration parameter.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BooleanParamDef.defaultValue";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::BooleanParamDef -->
   <xsd:complexType abstract="false" mixed="false" name="BOOLEAN-PARAM-DEF">
      <xsd:annotation>
         <xsd:documentation>Configuration parameter type for Boolean. allowed values are true and false.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BooleanParamDef";xml.sequenceOffset="0"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PARAM-CONF-MULTIPLICITY"/>
         <xsd:group ref="AR:COMMON-CONFIGURATION-ATTRIBUTES"/>
         <xsd:group ref="AR:CONFIG-PARAMETER"/>
         <xsd:group ref="AR:BOOLEAN-PARAM-DEF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- complex type for class Datatypes::BooleanType -->
   <xsd:complexType abstract="false" mixed="false" name="BOOLEAN-TYPE">
      <xsd:annotation>
         <xsd:documentation>This datatype represents a set containing the logical value true and false</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BooleanType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpType</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PRIMITIVE-TYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUCDescriptionTemplate::BooleanValue -->
   <xsd:group name="BOOLEAN-VALUE">
      <xsd:annotation>
         <xsd:documentation>Representing a configuration value of definition type BooleanParamDef</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BooleanValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VALUE" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Stores the value of the Boolean parameter.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BooleanValue.value";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCDescriptionTemplate::BooleanValue -->
   <xsd:complexType abstract="false" mixed="false" name="BOOLEAN-VALUE">
      <xsd:annotation>
         <xsd:documentation>Representing a configuration value of definition type BooleanParamDef</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BooleanValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:PARAMETER-VALUE"/>
         <xsd:group ref="AR:BOOLEAN-VALUE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class BasicElements::BootTime -->
   <xsd:group name="BOOT-TIME">
      <xsd:annotation>
         <xsd:documentation>Time information for ECU and PU startup.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BootTime"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COLD-START-TIME" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Time it takes to come from a completely powered down state to the HWInit state in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BootTime.coldStartTime";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RESET-TIME" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Time it takes from the reset initiation to the HWInit state in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BootTime.resetTime";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BasicElements::BootTime -->
   <xsd:complexType abstract="false" mixed="false" name="BOOT-TIME">
      <xsd:annotation>
         <xsd:documentation>Time information for ECU and PU startup.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BootTime"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:BOOT-TIME"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- complex type for class Inlines::Br -->
   <xsd:complexType abstract="false" mixed="false" name="BR">
      <xsd:annotation>
         <xsd:documentation>This element is the same as function here as in a HTML document i.e. it forces a line break.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Br"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class BswBehavior::BswBehavior -->
   <xsd:group name="BSW-BEHAVIOR">
      <xsd:annotation>
         <xsd:documentation>Specifies the behavior of a BSW module or a BSW cluster w.r.t. the code entities visible by the BSW Scheduler.
      It is possible to have several different BswBehaviors referring to the same BswModuleDescription.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswBehavior"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ENTITYS">
            <xsd:annotation>
               <xsd:documentation>A code entity for which the behavior is described</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswBehavior.entity";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="BSW-INTERRUPT-ENTITY" type="AR:BSW-INTERRUPT-ENTITY"/>
                  <xsd:element name="BSW-MODULE-ENTITY" type="AR:BSW-MODULE-ENTITY"/>
                  <xsd:element name="BSW-SCHEDULABLE-ENTITY" type="AR:BSW-SCHEDULABLE-ENTITY"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EVENTS">
            <xsd:annotation>
               <xsd:documentation>An event required by this module behavior.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswBehavior.event";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="BSW-CYCLIC-EVENT" type="AR:BSW-CYCLIC-EVENT"/>
                  <xsd:element name="BSW-SPORADIC-EVENT" type="AR:BSW-SPORADIC-EVENT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EXCLUSIVE-AREAS">
            <xsd:annotation>
               <xsd:documentation>This specifies an ExclusiveArea for this BswBehavior. The exclusiveArea is local to the module or module cluster.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswBehavior.exclusiveArea";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="EXCLUSIVE-AREA" type="AR:EXCLUSIVE-AREA"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODULE-REF">
            <xsd:annotation>
               <xsd:documentation>The module specification fulfilled by this behavior.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswBehavior.module";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:BSW-MODULE-DESCRIPTION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BswBehavior::BswBehavior -->
   <xsd:complexType abstract="false" mixed="false" name="BSW-BEHAVIOR">
      <xsd:annotation>
         <xsd:documentation>Specifies the behavior of a BSW module or a BSW cluster w.r.t. the code entities visible by the BSW Scheduler.
      It is possible to have several different BswBehaviors referring to the same BswModuleDescription.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswBehavior"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:BSW-BEHAVIOR"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="BSW-BEHAVIOR--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="BSW-BEHAVIOR"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class BswBehavior::BswCyclicEvent -->
   <xsd:group name="BSW-CYCLIC-EVENT">
      <xsd:annotation>
         <xsd:documentation>A cyclically recurring BSW event. The cyclic activity has to be implemented by the BSW Scheduler.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswCyclicEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CYCLE-TIME" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Requirement for the cycle time (in seconds) by which this event is triggered.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswCyclicEvent.cycleTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BswBehavior::BswCyclicEvent -->
   <xsd:complexType abstract="false" mixed="false" name="BSW-CYCLIC-EVENT">
      <xsd:annotation>
         <xsd:documentation>A cyclically recurring BSW event. The cyclic activity has to be implemented by the BSW Scheduler.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswCyclicEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:BSW-EVENT"/>
         <xsd:group ref="AR:BSW-CYCLIC-EVENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class BswBehavior::BswEvent -->
   <xsd:group name="BSW-EVENT">
      <xsd:annotation>
         <xsd:documentation>Defines an event which is used to trigger a schedulable entity of this BSW module or cluster. The event is local to the BSW module or cluster. The short name of the class instance is intended as an input to configure the required API of the BSW Scheduler.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="STARTS-ON-EVENT-REF">
            <xsd:annotation>
               <xsd:documentation>This entity is started by the event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswEvent.startsOnEvent";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:BSW-SCHEDULABLE-ENTITY--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class BswImplementation::BswImplementation -->
   <xsd:group name="BSW-IMPLEMENTATION">
      <xsd:annotation>
         <xsd:documentation>Contains the implementation specific information in addition to the generic specification (BswModuleDescription and BswBehavior).
      It is possible to have several different BswImplementations referring to the same BswBehavior.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswImplementation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="AR-MAJOR-VERSION" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Major version number of AUTOSAR specification on which this implementation is based on.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswImplementation.arMajorVersion";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="AR-MINOR-VERSION" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Minor version number of AUTOSAR specification on which this implementation is based on.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswImplementation.arMinorVersion";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="AR-PATCH-VERSION" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Patch level version number of AUTOSAR specification on which this implementation is based on.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswImplementation.arPatchVersion";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="BEHAVIOR-REF">
            <xsd:annotation>
               <xsd:documentation>The behavior of this implementation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswImplementation.behavior";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:BSW-BEHAVIOR--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PRECONFIGURED-CONFIGURATION-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the module configuration that contains preconfigured (i.e. fixed) configuration parameters.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswImplementation.preconfiguredConfiguration";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MODULE-CONFIGURATION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RECOMMENDED-CONFIGURATION-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the recommended configuration for this module.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswImplementation.recommendedConfiguration";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MODULE-CONFIGURATION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REQUIRED-HW-REFS">
            <xsd:annotation>
               <xsd:documentation>Hardware resource required by this BswImplementation</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswImplementation.requiredHW";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="REQUIRED-HW-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:HW-ELEMENT--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VENDOR-API-INFIX" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>In driver modules which can be instantiated several times on a single ECU, BSW00347 requires that the name of APIs is extended by the VendorId and a vendor specific name. 
            This parameter is used to specify the vendor specific name. In total, the implementation specific name is generated as follows:
            &lt;ModuleName&gt;_&lt;VendorId&gt;_ &lt;VendorApiInfix&gt;&lt;Api name from SWS&gt;.

            E.g.  assuming that the VendorId of the implementor is 123 and the implementer chose a VendorApiInfix of "v11r456" a api name Can_Write defined in the SWS will translate to Can_123_v11r456Write. 

            This attribute is mandatory for all modules with upper multiplicity &gt; 1. It shall not be used for modules with upper multiplicity =1.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswImplementation.vendorApiInfix";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VENDOR-SPECIFIC-MODULE-DEF-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the Vendor Specific ModuleDef used in this BSW module description.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswImplementation.vendorSpecificModuleDef";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MODULE-DEF--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BswImplementation::BswImplementation -->
   <xsd:complexType abstract="false" mixed="false" name="BSW-IMPLEMENTATION">
      <xsd:annotation>
         <xsd:documentation>Contains the implementation specific information in addition to the generic specification (BswModuleDescription and BswBehavior).
      It is possible to have several different BswImplementations referring to the same BswBehavior.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswImplementation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:IMPLEMENTATION"/>
         <xsd:group ref="AR:BSW-IMPLEMENTATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="BSW-IMPLEMENTATION--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="BSW-IMPLEMENTATION"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class BswBehavior::BswInterruptEntity -->
   <xsd:group name="BSW-INTERRUPT-ENTITY">
      <xsd:annotation>
         <xsd:documentation>BSW module entity, which is designed to be triggered by an interrupt.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswInterruptEntity"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="INTERRUPT-CATEGORY" type="AR:BSW-INTERRUPT-CATEGORY">
            <xsd:annotation>
               <xsd:documentation>Category of the interrupt</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswInterruptEntity.interruptCategory";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INTERRUPT-SOURCE" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Allows a textual documentation of the intended interrupt source.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswInterruptEntity.interruptSource";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BswBehavior::BswInterruptEntity -->
   <xsd:complexType abstract="false" mixed="false" name="BSW-INTERRUPT-ENTITY">
      <xsd:annotation>
         <xsd:documentation>BSW module entity, which is designed to be triggered by an interrupt.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswInterruptEntity"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:BSW-MODULE-ENTITY"/>
         <xsd:group ref="AR:BSW-INTERRUPT-ENTITY"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class BswInterfaces::BswModuleDependency -->
   <xsd:group name="BSW-MODULE-DEPENDENCY">
      <xsd:annotation>
         <xsd:documentation>This class collects the dependencies of a BSW module or cluster on a certain other BSW module in an abstract way.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswModuleDependency"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="EXPECTED-CALLBACK-REFS">
            <xsd:annotation>
               <xsd:documentation>Indicates a callback expected to be called from another module and implemented by this module.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswModuleDependency.expectedCallback";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="EXPECTED-CALLBACK-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:BSW-MODULE-ENTRY--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REQUIRED-ENTRY-REFS">
            <xsd:annotation>
               <xsd:documentation>Indicates an entry into another modules which is required by this module.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswModuleDependency.requiredEntry";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="REQUIRED-ENTRY-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:BSW-MODULE-ENTRY--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SERVICE-ITEMS">
            <xsd:annotation>
               <xsd:documentation>A single item (example: Nv block) for which the quality of a service is defined.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswModuleDependency.serviceItem";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="COM-MGR-USER-NEEDS" type="AR:COM-MGR-USER-NEEDS"/>
                  <xsd:element name="DIAGNOSTIC-COMMUNICATION-NEEDS" type="AR:DIAGNOSTIC-COMMUNICATION-NEEDS"/>
                  <xsd:element name="DIAGNOSTIC-EVENT-NEEDS" type="AR:DIAGNOSTIC-EVENT-NEEDS"/>
                  <xsd:element name="ECU-STATE-MGR-USER-NEEDS" type="AR:ECU-STATE-MGR-USER-NEEDS"/>
                  <xsd:element name="FUNCTION-INHIBITION-NEEDS" type="AR:FUNCTION-INHIBITION-NEEDS"/>
                  <xsd:element name="NV-BLOCK-NEEDS" type="AR:NV-BLOCK-NEEDS"/>
                  <xsd:element name="OBD-CONTROL-SERVICE-NEEDS" type="AR:OBD-CONTROL-SERVICE-NEEDS"/>
                  <xsd:element name="OBD-INFO-SERVICE-NEEDS" type="AR:OBD-INFO-SERVICE-NEEDS"/>
                  <xsd:element name="OBD-MONITOR-SERVICE-NEEDS" type="AR:OBD-MONITOR-SERVICE-NEEDS"/>
                  <xsd:element name="OBD-PID-SERVICE-NEEDS" type="AR:OBD-PID-SERVICE-NEEDS"/>
                  <xsd:element name="OBD-RATIO-SERVICE-NEEDS" type="AR:OBD-RATIO-SERVICE-NEEDS"/>
                  <xsd:element name="SERVICE-NEEDS" type="AR:SERVICE-NEEDS"/>
                  <xsd:element name="SUPERVISED-ENTITY-NEEDS" type="AR:SUPERVISED-ENTITY-NEEDS"/>
                  <xsd:element name="SWC-COM-MGR-USER-NEEDS" type="AR:SWC-COM-MGR-USER-NEEDS"/>
                  <xsd:element name="SWC-DIAGNOSTIC-COMMUNICATION-NEEDS" type="AR:SWC-DIAGNOSTIC-COMMUNICATION-NEEDS"/>
                  <xsd:element name="SWC-DIAGNOSTIC-EVENT-NEEDS" type="AR:SWC-DIAGNOSTIC-EVENT-NEEDS"/>
                  <xsd:element name="SWC-ECU-STATE-MGR-USER-NEEDS" type="AR:SWC-ECU-STATE-MGR-USER-NEEDS"/>
                  <xsd:element name="SWC-FUNCTION-INHIBITION-NEEDS" type="AR:SWC-FUNCTION-INHIBITION-NEEDS"/>
                  <xsd:element name="SWC-NV-BLOCK-NEEDS" type="AR:SWC-NV-BLOCK-NEEDS"/>
                  <xsd:element name="SWC-OBD-CONTROL-SERVICE-NEEDS" type="AR:SWC-OBD-CONTROL-SERVICE-NEEDS"/>
                  <xsd:element name="SWC-OBD-INFO-SERVICE-NEEDS" type="AR:SWC-OBD-INFO-SERVICE-NEEDS"/>
                  <xsd:element name="SWC-OBD-MONITOR-SERVICE-NEEDS" type="AR:SWC-OBD-MONITOR-SERVICE-NEEDS"/>
                  <xsd:element name="SWC-OBD-PID-SERVICE-NEEDS" type="AR:SWC-OBD-PID-SERVICE-NEEDS"/>
                  <xsd:element name="SWC-OBD-RATIO-SERVICE-NEEDS" type="AR:SWC-OBD-RATIO-SERVICE-NEEDS"/>
                  <xsd:element name="SWC-SUPERVISED-ENTITY-NEEDS" type="AR:SWC-SUPERVISED-ENTITY-NEEDS"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TARGET-MODULE-ID" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>AUTOSAR identifier of the target module of which the dependencies are defined.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswModuleDependency.targetModuleId";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BswInterfaces::BswModuleDependency -->
   <xsd:complexType abstract="false" mixed="false" name="BSW-MODULE-DEPENDENCY">
      <xsd:annotation>
         <xsd:documentation>This class collects the dependencies of a BSW module or cluster on a certain other BSW module in an abstract way.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswModuleDependency"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:BSW-MODULE-DEPENDENCY"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class BswOverview::BswModuleDescription -->
   <xsd:group name="BSW-MODULE-DESCRIPTION">
      <xsd:annotation>
         <xsd:documentation>Root element for the description of a single BSW module or BSW cluster.
      In case it describes a BSW module, the short name of this element equals the name of the BSW module.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswModuleDescription"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpStructureElement</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BSW-MODULE-DEPENDENCYS">
            <xsd:annotation>
               <xsd:documentation>Describes the dependency to another BSW module.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswModuleDescription.bswModuleDependency";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="BSW-MODULE-DEPENDENCY" type="AR:BSW-MODULE-DEPENDENCY"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODULE-ID" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Refers to the BSW Module Identifier defined by the AUTOSAR standard.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswModuleDescription.moduleId";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="OUTGOING-CALLBACK-REFS">
            <xsd:annotation>
               <xsd:documentation>Specifies a callback, which will be called from this module if required by 
            another module.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswModuleDescription.outgoingCallback";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="OUTGOING-CALLBACK-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:BSW-MODULE-ENTRY--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PROVIDED-ENTRY-REFS">
            <xsd:annotation>
               <xsd:documentation>Specifies an entry provided by this module which can be called by other modules. This includes "main" functions and interrupt routines, but not callbacks (because the signature of a callback is defined by the calller).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswModuleDescription.providedEntry";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="PROVIDED-ENTRY-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:BSW-MODULE-ENTRY--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BswOverview::BswModuleDescription -->
   <xsd:complexType abstract="false" mixed="false" name="BSW-MODULE-DESCRIPTION">
      <xsd:annotation>
         <xsd:documentation>Root element for the description of a single BSW module or BSW cluster.
      In case it describes a BSW module, the short name of this element equals the name of the BSW module.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswModuleDescription"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpStructureElement</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:BSW-MODULE-DESCRIPTION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="BSW-MODULE-DESCRIPTION--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="BSW-MODULE-DESCRIPTION"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class BswBehavior::BswModuleEntity -->
   <xsd:group name="BSW-MODULE-ENTITY">
      <xsd:annotation>
         <xsd:documentation>Specifies the smallest code fragment which can be described for a BSW module or cluster within AUTOSAR.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswModuleEntity"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ACTIVATION-POINT-REFS">
            <xsd:annotation>
               <xsd:documentation>The module entity can activate this event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswModuleEntity.activationPoint";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ACTIVATION-POINT-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:BSW-SPORADIC-EVENT--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CALLED-ENTRY-REFS">
            <xsd:annotation>
               <xsd:documentation>The entry of another (or the same) BSW module which is called by this entry (usually via C function call). This information allows to set up a model of call chains.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswModuleEntity.calledEntry";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CALLED-ENTRY-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:BSW-MODULE-ENTRY--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CAN-ENTER-EXCLUSIVE-AREA-REFS">
            <xsd:annotation>
               <xsd:documentation>The BswModuleEntity can enter/leave the referenced exclusive area through explicit API calls.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswModuleEntity.canEnterExclusiveArea";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CAN-ENTER-EXCLUSIVE-AREA-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:EXCLUSIVE-AREA--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CANCELLATION-POINT-REFS">
            <xsd:annotation>
               <xsd:documentation>The module entity can cancel the activation of the event (this only makes sense, if the event has a non-zero delay time).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswModuleEntity.cancellationPoint";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CANCELLATION-POINT-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:BSW-SPORADIC-EVENT--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="IMPLEMENTED-ENTRY-REF">
            <xsd:annotation>
               <xsd:documentation>The entry which is implemented by this module entity.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswModuleEntity.implementedEntry";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:BSW-MODULE-ENTRY--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BswBehavior::BswModuleEntity -->
   <xsd:complexType abstract="false" mixed="false" name="BSW-MODULE-ENTITY">
      <xsd:annotation>
         <xsd:documentation>Specifies the smallest code fragment which can be described for a BSW module or cluster within AUTOSAR.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswModuleEntity"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:BSW-MODULE-ENTITY"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="BSW-MODULE-ENTITY--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="BSW-INTERRUPT-ENTITY"/>
         <xsd:enumeration value="BSW-MODULE-ENTITY"/>
         <xsd:enumeration value="BSW-SCHEDULABLE-ENTITY"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class BswInterfaces::BswModuleEntry -->
   <xsd:group name="BSW-MODULE-ENTRY">
      <xsd:annotation>
         <xsd:documentation>This class represents a single API entry (C-function prototype) into the BSW module or cluster.

      The name of the C-function is equal to the short name of this element with one exception: In case of multiple instances of a module on the same CPU, special rules for "infixes" apply, see description of class BswImplementation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswModuleEntry"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CALL-TYPE" type="AR:BSW-CALL-TYPE">
            <xsd:annotation>
               <xsd:documentation>the type of call associated with this service</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswModuleEntry.callType";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EXECUTION-CONTEXT" type="AR:BSW-EXECUTION-CONTEXT">
            <xsd:annotation>
               <xsd:documentation>Specifies the excution context which is required (in case of entries into this module) or guaranteed (in case of entries called from this module) for this service.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswModuleEntry.executionContext";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="IS-SYNCHRONOUS" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>true: This calls a synchronous service, i.e. the service is completed when the call returns.
            false: The service (on semantical level) may not be complete when the call returns.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswModuleEntry.isSynchronous";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SERVICE-ID" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Refers to the service identifier of the Standardized Interfaces of AUTOSAR basic software.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswModuleEntry.serviceId";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BswInterfaces::BswModuleEntry -->
   <xsd:complexType abstract="false" mixed="false" name="BSW-MODULE-ENTRY">
      <xsd:annotation>
         <xsd:documentation>This class represents a single API entry (C-function prototype) into the BSW module or cluster.

      The name of the C-function is equal to the short name of this element with one exception: In case of multiple instances of a module on the same CPU, special rules for "infixes" apply, see description of class BswImplementation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswModuleEntry"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SW-SERVICE"/>
         <xsd:group ref="AR:BSW-MODULE-ENTRY"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="BSW-MODULE-ENTRY--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="BSW-MODULE-ENTRY"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- complex type for class BswBehavior::BswSchedulableEntity -->
   <xsd:complexType abstract="false" mixed="false" name="BSW-SCHEDULABLE-ENTITY">
      <xsd:annotation>
         <xsd:documentation>BSW module entity, which is designed for control by the BSW Scheduler. It implements a so-called "main" function.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswSchedulableEntity"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:BSW-MODULE-ENTITY"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="BSW-SCHEDULABLE-ENTITY--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="BSW-SCHEDULABLE-ENTITY"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class BswBehavior::BswSporadicEvent -->
   <xsd:group name="BSW-SPORADIC-EVENT">
      <xsd:annotation>
         <xsd:documentation>A BSW event, which can happen sporadically. The event is activated/cancelled by explicit calls from the module to the BSW Scheduler. There a two purposes for such an event:
      - cause a context switch, e.g. from an ISR context into a task context
      - implement a time delay</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswSporadicEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DELAY-TIME" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Requirement for the delay time (in seconds) after which this event is triggered. The delay is counted from the activation of this event by a BswModuleEntitiy until the actual triggering of another BswModuleEntity associated by the event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BswSporadicEvent.delayTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BswBehavior::BswSporadicEvent -->
   <xsd:complexType abstract="false" mixed="false" name="BSW-SPORADIC-EVENT">
      <xsd:annotation>
         <xsd:documentation>A BSW event, which can happen sporadically. The event is activated/cancelled by explicit calls from the module to the BSW Scheduler. There a two purposes for such an event:
      - cause a context switch, e.g. from an ISR context into a task context
      - implement a time delay</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BswSporadicEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:BSW-EVENT"/>
         <xsd:group ref="AR:BSW-SPORADIC-EVENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="BSW-SPORADIC-EVENT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="BSW-SPORADIC-EVENT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Peripherals::Buffer -->
   <xsd:group name="BUFFER">
      <xsd:annotation>
         <xsd:documentation>Description of a  buffer. It is used to describe input and output buffers.
      Buffers can also be configurable direction.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Buffer"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="NUMBER" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The amount of buffers with the attributes size and type.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Buffer.number";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SIZE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The size of the Buffer.
            Unit: Byte</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Buffer.size";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TYPE" type="AR:COMMUNICATION-DIRECTION-ENUM">
            <xsd:annotation>
               <xsd:documentation>Either input, output or configurable buffer.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Buffer.type";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Peripherals::Buffer -->
   <xsd:complexType abstract="false" mixed="false" name="BUFFER">
      <xsd:annotation>
         <xsd:documentation>Description of a  buffer. It is used to describe input and output buffers.
      Buffers can also be configurable direction.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Buffer"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:BUFFER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ECUElectronics::BusTermination -->
   <xsd:group name="BUS-TERMINATION">
      <xsd:annotation>
         <xsd:documentation>In order to avoid signal reflection and oscillation of the Technical Signal represen-tation the impedance on communication lines have to be defined and matched at the signal destination and the signal source.
      Some examples:
      A High-speed CAN network with a twisted pair cable works optimal with an overall impedance of 60 Ohms represented by a 120 Ohm resistor in the ECU at the begin-ning of the network and 120 Ohm in the ECU at the end of a linear network topology.
      For Low-speed CAN networks in many cases termination resistors of 820 Ohm each are distributed on several ECUs to get good balance between system scalability and signal integrity in real networks without a fixed network topology. The lower bandwidth can tolerate some impedance mismatch.
      For LIN networks recessive termination is used: The inactive bus signal level is defined by resistors tied to a defined voltage level.
      An important attribute for communication lines is the presence of a termination resistor and the value of this resistor.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BusTermination"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ACTIVE-SWITCHABLE" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Switchable termination describes a technology were the termination resistors can be switched or changed by extra hardware and therefore is under control of software. Main scope of a switchable termination is to adopt the termination of an individual ECU to the network topology of a specific car, e. g modules for extra car options can use this method to be incorporated in a wide range of different car types. The active termination is described by the values for each termination value. E.g. 120, 820, 12k. No termination is represented by values greater than 100 k. The attributes value and switchable are exclusive to each other.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BusTermination.activeSwitchable";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CHOKE" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>To improve the signal integrity on communication busses with a differential electrical signal representation on the physical layer, common mode chokes are used. They suppress common mode DC noise on CAN, FlexRay and Ethernet networks. Depending on the network topology common mode chokes of an ECU have to be taken in to account when adding ECUs to a network during design phase. Typically chokes are used on CAN, FlexRay, LVDS.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BusTermination.choke";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EMC-FILTER" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>To improve the EMC behaviour of communication busses common dedicated EMC Filters are used. They suppress frequencies outside the range, which is needed for the communication of the specific bus
            E.g. some small capacitors in parallel to ground, resistors and inductivities in series are added to the bus lines in order to prevent the higher harmonics stimulated by the communication on the network
            The information about the termination is used with in the system configuration process, where the placement of an ECU within a car architecture is generated.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BusTermination.emcFilter";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SPLIT" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Describe a technology were the termination is split in to individual resistors with a  capacitive coupling to ground. This technology improves the signal quality.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BusTermination.split";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VALUE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Describe the nominal Value of the termination resistor at the ECU as seen from the communication network.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="BusTermination.value";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUElectronics::BusTermination -->
   <xsd:complexType abstract="false" mixed="false" name="BUS-TERMINATION">
      <xsd:annotation>
         <xsd:documentation>In order to avoid signal reflection and oscillation of the Technical Signal represen-tation the impedance on communication lines have to be defined and matched at the signal destination and the signal source.
      Some examples:
      A High-speed CAN network with a twisted pair cable works optimal with an overall impedance of 60 Ohms represented by a 120 Ohm resistor in the ECU at the begin-ning of the network and 120 Ohm in the ECU at the end of a linear network topology.
      For Low-speed CAN networks in many cases termination resistors of 820 Ohm each are distributed on several ECUs to get good balance between system scalability and signal integrity in real networks without a fixed network topology. The lower bandwidth can tolerate some impedance mismatch.
      For LIN networks recessive termination is used: The inactive bus signal level is defined by resistors tied to a defined voltage level.
      An important attribute for communication lines is the presence of a termination resistor and the value of this resistor.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="BusTermination"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:BUS-TERMINATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ByteOrder::ByteOrder -->
   <xsd:group name="BYTE-ORDER">
      <xsd:annotation>
         <xsd:documentation>This element specifies the byte order of the parent element. The byte order is defined with the attribute TYPE. Possible values are:

      * MOST-SIGNIFICANT-BYTE-FIRST

      * MOST-SIGNIFICANT-BYTE-LAST</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ByteOrder"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONTENT" type="AR:BYTE-ORDER-ENUM">
            <xsd:annotation>
               <xsd:documentation>This represents the actual setting of the byte order.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ByteOrder.content";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.roleElement="false";xml.roleWrapperElement="false";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ByteOrder::ByteOrder -->
   <xsd:complexType name="BYTE-ORDER">
      <xsd:annotation>
         <xsd:documentation>This element specifies the byte order of the parent element. The byte order is defined with the attribute TYPE. Possible values are:

      * MOST-SIGNIFICANT-BYTE-FIRST

      * MOST-SIGNIFICANT-BYTE-LAST</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ByteOrder"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="AR:BYTE-ORDER-ENUM">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <!-- element group for class Peripherals::CCU -->
   <xsd:group name="CCU">
      <xsd:annotation>
         <xsd:documentation>The CCU is a special kind of a timer, which has the capability of counting and comparing external signals. The timer is equipped with some extra registers and comparators in order to measure time or frequency.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CCU"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODE" type="AR:CCU-MODE-ENUM">
            <xsd:annotation>
               <xsd:documentation>A Capture and Compare peripheral can be configured to operate either in capture or compare mode.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CCU.mode";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Peripherals::CCU -->
   <xsd:complexType abstract="false" mixed="false" name="CCU">
      <xsd:annotation>
         <xsd:documentation>The CCU is a special kind of a timer, which has the capability of counting and comparing external signals. The timer is equipped with some extra registers and comparators in order to measure time or frequency.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CCU"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HW-ELEMENT"/>
         <xsd:group ref="AR:PERIPHERAL"/>
         <xsd:group ref="AR:GENERAL-PURPOSE-TIMER"/>
         <xsd:group ref="AR:CCU"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ApplicationAttributes::CalibrationPortAnnotation -->
   <xsd:group name="CALIBRATION-PORT-ANNOTATION">
      <xsd:annotation>
         <xsd:documentation>Annotation to a port used for calibration regarding a certain CalprmElement.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CalibrationPortAnnotation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CALPRM-ELEMENT-REF">
            <xsd:annotation>
               <xsd:documentation>The instance of calprm element annotated.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CalibrationPortAnnotation.calprmElement";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:CALPRM-ELEMENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ApplicationAttributes::CalibrationPortAnnotation -->
   <xsd:complexType abstract="false" mixed="false" name="CALIBRATION-PORT-ANNOTATION">
      <xsd:annotation>
         <xsd:documentation>Annotation to a port used for calibration regarding a certain CalprmElement.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CalibrationPortAnnotation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:GENERAL-ANNOTATION"/>
         <xsd:group ref="AR:CALIBRATION-PORT-ANNOTATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Characteristic::CalprmAccess -->
   <xsd:group name="CALPRM-ACCESS">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CalprmAccess"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CALPRM-ACCESS-IREF" type="AR:CALPRM-ACCESS--CALPRM-ELEMENT-PROTOTYPE-IREF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="calprmAccess.CalprmAccess";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Characteristic::CalprmAccess -->
   <xsd:complexType abstract="false" mixed="false" name="CALPRM-ACCESS">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CalprmAccess"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:CALPRM-ACCESS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class _instanceRef::CalprmAccess_CalprmElementPrototype -->
   <xsd:group name="CALPRM-ACCESS--CALPRM-ELEMENT-PROTOTYPE-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CalprmAccess_CalprmElementPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPONENT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CalprmAccess_CalprmElementPrototype.componentPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="10"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMPONENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PORT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CalprmAccess_CalprmElementPrototype.portPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="1" name="CALPRM-ELEMENT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:documentation>This represents the corresponding calprmElementPrototype.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CalprmAccess_CalprmElementPrototype.calprmElementPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.target</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:CALPRM-ELEMENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class _instanceRef::CalprmAccess_CalprmElementPrototype -->
   <xsd:complexType abstract="false" mixed="false" name="CALPRM-ACCESS--CALPRM-ELEMENT-PROTOTYPE-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CalprmAccess_CalprmElementPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:CALPRM-ACCESS--CALPRM-ELEMENT-PROTOTYPE-IREF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- complex type for class Components::CalprmComponentType -->
   <xsd:complexType abstract="false" mixed="false" name="CALPRM-COMPONENT-TYPE">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CalprmComponentType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpType</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COMPONENT-TYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- complex type for class Characteristic::CalprmElementPrototype -->
   <xsd:complexType abstract="false" mixed="false" name="CALPRM-ELEMENT-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>In the context of a component there is no typed re-use of CalprmElementPrototype entities</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CalprmElementPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:DATA-PROTOTYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="CALPRM-ELEMENT-PROTOTYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CALPRM-ELEMENT-PROTOTYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Characteristic::CalprmInterface -->
   <xsd:group name="CALPRM-INTERFACE">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CalprmInterface"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpType</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CALPRM-ELEMENTS">
            <xsd:annotation>
               <xsd:documentation>This represents a calibration parameter owned by the CalprmInterface.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CalprmInterface.calprmElement";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CALPRM-ELEMENT-PROTOTYPE" type="AR:CALPRM-ELEMENT-PROTOTYPE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Characteristic::CalprmInterface -->
   <xsd:complexType abstract="false" mixed="false" name="CALPRM-INTERFACE">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CalprmInterface"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpType</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PORT-INTERFACE"/>
         <xsd:group ref="AR:CALPRM-INTERFACE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class CanTopology::CanCluster -->
   <xsd:group name="CAN-CLUSTER">
      <xsd:annotation>
         <xsd:documentation>CAN specific attributes</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanCluster";xml.namePlural="CAN-BUSES"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-BUS-LOAD-REDUCTION-ACTIVE" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>It determines if bus load reduction for the respective NM channel is active or not. 
            True: active
            False: inactive</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanCluster.nmBusLoadReductionActive";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-BUS-LOAD-REDUCTION-ENABLED" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>switch for enabling busload reduction support.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanCluster.nmBusLoadReductionEnabled";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-IMMEDIATE-NM-CYCLE-TIME" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Defines the immediate NM PDU cycle time in seconds which is used for nmImmediateNmTransmissions NM PDU transmissions. This parameter is only valid if CanNmImmediateNmTransmissions is greater one.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanCluster.nmImmediateNmCycleTime";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-IMMEDIATE-NM-TRANSMISSIONS" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Defines the number of immediate NM PDUs which shall be transmitted. If the value is zero no immediate NM PDUs are transmitted. The cycle time of immeditate NM PDUs is defined by nmImmediateNmCycleTime.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanCluster.nmImmediateNmTransmissions";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-IMMEDIATE-RESTART-ENABLED" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Enables the asynchronous transmission of a CanNm PDU upon bus-communication request in Prepare-Bus-Sleep mode.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanCluster.nmImmediateRestartEnabled";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-LOWER-CAN-ID" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>This attribute can be used together with the nmUpperCanId attribute to define a range of CanIds. Can Frames which will arrive in the given Id Range will be handled as Nm Pdus. 

            This range definition is redundant to the attribute "rxIdentifierRange" of "CanFrameTriggering". For backward compatibility reasons this redundancy shall be preserved and both shall be defined.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanCluster.nmLowerCanId";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-MSG-CYCLE-TIME" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Period of a CanNm message in seconds. It determines the periodic rate in the periodic transmission mode with bus load reduction and is the basis for transmit scheduling in the periodic transmission mode without bus load reduction.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanCluster.nmMsgCycleTime";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-REMOTE-SLEEP-INDICATION-TIME" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Timeout for Remote Sleep Indication in seconds. It defines the time how long it shall take to recognize that all other nodes are ready to sleep.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanCluster.nmRemoteSleepIndicationTime";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-REPEAT-MESSAGE-STATE-TIME" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>It defines how long the NM shall stay in the Repeat Message State (in seconds)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanCluster.nmRepeatMessageStateTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-TIMEOUT-TIME" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Network Timeout for NM-Messages. It denotes the time (in seconds) how long the NM shall stay in the Network Mode before transition into Prepare Bus-Sleep Mode shall take place. It shall be equal for all nodes in the cluster.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanCluster.nmTimeoutTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-UPPER-CAN-ID" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>This attribute can be used together with the nmLowerCanId attribute to define a range of CanIds. Can Frames which will arrive in the given Id Range will be handled as Nm Pdus. 

            This range definition is redundant to the attribute "rxIdentifierRange" of "CanFrameTriggering". For backward compatibility reasons this redundancy shall be preserved and both shall be defined.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanCluster.nmUpperCanId";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-WAIT-BUS-SLEEP-TIME" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Timeout for bus calm down phase. It denotes the time (in seconds) how long the NM shall stay in the Prepare Bus-Sleep Mode before transition into Bus-Sleep Mode shall take place. It shall be equal for all nodes in the cluster.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanCluster.nmWaitBusSleepTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CanTopology::CanCluster -->
   <xsd:complexType abstract="false" mixed="false" name="CAN-CLUSTER">
      <xsd:annotation>
         <xsd:documentation>CAN specific attributes</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanCluster";xml.namePlural="CAN-BUSES"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COMMUNICATION-CLUSTER"/>
         <xsd:group ref="AR:CAN-CLUSTER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class CanTopology::CanCommunicationConnector -->
   <xsd:group name="CAN-COMMUNICATION-CONNECTOR">
      <xsd:annotation>
         <xsd:documentation>CAN bus specific communication connector attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanCommunicationConnector"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="PNC-WAKEUP-CAN-ID" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>CAN Identifier used to configure the CAN Transceiver for partial network wakeup.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanCommunicationConnector.pncWakeupCanId";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PNC-WAKEUP-CAN-ID-EXTENDED" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Defines whether pncWakeupCanId and pncWakeupCanIdMask shall be interpreted as extended or standard CAN ID.
            true: extended Can identifier is used
            false: standard Can identifier is used</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanCommunicationConnector.pncWakeupCanIdExtended";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PNC-WAKEUP-CAN-ID-MASK" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Bit mask for CAN Identifier used to configure the CAN Transceiver for partial network wakeup.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanCommunicationConnector.pncWakeupCanIdMask";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PNC-WAKEUP-DATA-MASK" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Bit mask for CAN Payload used to configure the CAN Transceiver for partial network wakeup.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanCommunicationConnector.pncWakeupDataMask";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PNC-WAKEUP-DLC" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Data Length of the remote data frame used to configure the CAN Transceiver for partial network wakeup in Bytes.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanCommunicationConnector.pncWakeupDlc";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CanTopology::CanCommunicationConnector -->
   <xsd:complexType abstract="false" mixed="false" name="CAN-COMMUNICATION-CONNECTOR">
      <xsd:annotation>
         <xsd:documentation>CAN bus specific communication connector attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanCommunicationConnector"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COMMUNICATION-CONNECTOR"/>
         <xsd:group ref="AR:CAN-COMMUNICATION-CONNECTOR"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class CanTopology::CanCommunicationController -->
   <xsd:group name="CAN-COMMUNICATION-CONTROLLER">
      <xsd:annotation>
         <xsd:documentation>CAN bus specific communication port attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanCommunicationController"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CAN-CONTROLLER-ATTRIBUTES">
            <xsd:annotation>
               <xsd:documentation>CAN Bit Timing configuration</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="canControllerAttributes.CanCommunicationController";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="CAN-CONTROLLER-CONFIGURATION" type="AR:CAN-CONTROLLER-CONFIGURATION"/>
                  <xsd:element name="CAN-CONTROLLER-CONFIGURATION-REQUIREMENTS" type="AR:CAN-CONTROLLER-CONFIGURATION-REQUIREMENTS"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-MSG-CYCLE-OFFSET" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Node specific time offset in the periodic transmission node. It determines the start delay of the transmission. Specified in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanCommunicationController.nmMsgCycleOffset";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-MSG-REDUCED-TIME" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Node specific bus cycle time in the periodic transmission mode with bus load reduction. Specified in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanCommunicationController.nmMsgReducedTime";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-USER-DATA-ENABLED" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Switch for enabling user data support.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanCommunicationController.nmUserDataEnabled";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CanTopology::CanCommunicationController -->
   <xsd:complexType abstract="false" mixed="false" name="CAN-COMMUNICATION-CONTROLLER">
      <xsd:annotation>
         <xsd:documentation>CAN bus specific communication port attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanCommunicationController"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COMMUNICATION-CONTROLLER"/>
         <xsd:group ref="AR:CAN-COMMUNICATION-CONTROLLER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class CanTopology::CanControllerConfiguration -->
   <xsd:group name="CAN-CONTROLLER-CONFIGURATION">
      <xsd:annotation>
         <xsd:documentation>This element is used for the specification of the exact CAN Bit Timing configuration parameter values.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanControllerConfiguration"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="NUMBER-OF-SAMPLES" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Number of samples. Possible values are 1 or 3.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanControllerConfiguration.numberOfSamples";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PROPAGATION-DELAY" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The propagation time segment in quanta.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanControllerConfiguration.propagationDelay";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYNC-JUMP-WIDTH" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The number of quanta in the Synchronization Jump Width, SJW. The (Re-)Synchronization Jump Width (SJW) defines how far a resynchronization may move the Sample Point inside the limits defined by the Phase Buffer Segments to compensate for edge phase errors.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanControllerConfiguration.syncJumpWidth";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIME-SEG-1" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The number of quanta before the sampling point.

            The propagation time segment is factored into the timeSeg1 configuration parameter:
            timeSeg1 = tPROP_SEG + tPHASE_SEG1</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanControllerConfiguration.timeSeg1";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIME-SEG-2" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The number of quanta after the sampling point:
            timeSeg2 = Phase_Seg2</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanControllerConfiguration.timeSeg2";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CanTopology::CanControllerConfiguration -->
   <xsd:complexType abstract="false" mixed="false" name="CAN-CONTROLLER-CONFIGURATION">
      <xsd:annotation>
         <xsd:documentation>This element is used for the specification of the exact CAN Bit Timing configuration parameter values.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanControllerConfiguration"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:CAN-CONTROLLER-CONFIGURATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CanTopology::CanControllerConfigurationRequirements -->
   <xsd:group name="CAN-CONTROLLER-CONFIGURATION-REQUIREMENTS">
      <xsd:annotation>
         <xsd:documentation>This element allows the specification of ranges for the CAN Bit Timing configuration parameters. These ranges are taken as requirements and have to be respected by the ECU developer.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanControllerConfigurationRequirements"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-NUMBER-OF-TIME-QUANTA-PER-BIT" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Maximum number of time quanta in the bit time.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanControllerConfigurationRequirements.maxNumberOfTimeQuantaPerBit";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-SAMPLE-POINT" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>The max. value of the sample point as a percentage of the total bit time.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanControllerConfigurationRequirements.maxSamplePoint";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-SYNC-JUMP-WIDTH" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>The max. Synchronization Jump Width value as a percentage of the total bit time. The (Re-)Synchronization Jump Width (SJW) defines how far a resynchronization may move the Sample Point inside the limits defined by the Phase Buffer Segments to compensate for edge phase errors.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanControllerConfigurationRequirements.maxSyncJumpWidth";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MIN-NUMBER-OF-TIME-QUANTA-PER-BIT" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Minimum number of time quanta in the bit time.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanControllerConfigurationRequirements.minNumberOfTimeQuantaPerBit";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MIN-SAMPLE-POINT" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>The min. value of the sample point as a percentage of the total bit time.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanControllerConfigurationRequirements.minSamplePoint";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MIN-SYNC-JUMP-WIDTH" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>The min. Synchronization Jump Width value as a percentage of the total bit time. The (Re-)Synchronization Jump Width (SJW) defines how far a resynchronization may move the Sample Point inside the limits defined by the Phase Buffer Segments to compensate for edge phase errors.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanControllerConfigurationRequirements.minSyncJumpWidth";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CanTopology::CanControllerConfigurationRequirements -->
   <xsd:complexType abstract="false" mixed="false" name="CAN-CONTROLLER-CONFIGURATION-REQUIREMENTS">
      <xsd:annotation>
         <xsd:documentation>This element allows the specification of ranges for the CAN Bit Timing configuration parameters. These ranges are taken as requirements and have to be respected by the ECU developer.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanControllerConfigurationRequirements"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:CAN-CONTROLLER-CONFIGURATION-REQUIREMENTS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CanCommunication::CanFrameTriggering -->
   <xsd:group name="CAN-FRAME-TRIGGERING">
      <xsd:annotation>
         <xsd:documentation>CAN specific attributes to the FrameTriggering</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanFrameTriggering"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CAN-ADDRESSING-MODE" type="AR:CAN-ADDRESSING-MODE-TYPE">
            <xsd:annotation>
               <xsd:documentation>The CAN protocol supports two types of frame formats. The standard frame format uses 11-bit identifiers and is defined in the CAN specification 2.0 A. Additionally the extended frame format allows 29-bit identifiers and is defined in the CAN specification 2.0 B.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanFrameTriggering.canAddressingMode";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="IDENTIFIER" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>To describe a frames identifier on the communication system, usualy with a fixed identifierValue.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanFrameTriggering.identifier";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RX-IDENTIFIER-RANGE" type="AR:RX-IDENTIFIER-RANGE">
            <xsd:annotation>
               <xsd:documentation>Optional definition of a CanId range.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="rxIdentifierRange.CanFrameTriggering";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CanCommunication::CanFrameTriggering -->
   <xsd:complexType abstract="false" mixed="false" name="CAN-FRAME-TRIGGERING">
      <xsd:annotation>
         <xsd:documentation>CAN specific attributes to the FrameTriggering</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanFrameTriggering"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:FRAME-TRIGGERING"/>
         <xsd:group ref="AR:CAN-FRAME-TRIGGERING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class TransportProtocols::CanTpConnectionChannel -->
   <xsd:group name="CAN-TP-CONNECTION-CHANNEL">
      <xsd:annotation>
         <xsd:documentation>A connection channel represents an internal path for the transmission or reception of a Pdu via CanTp
      and describes the the sender and the receiver of this particular communication.

      The CanTp module routes a Pdu through the connection channel</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanTpConnectionChannel"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ADDRESSING-FORMAT" type="AR:CAN-TP-ADDRESSING-FORMAT-TYPE">
            <xsd:annotation>
               <xsd:documentation>Declares which communication addressing mode is supported.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpConnectionChannel.addressingFormat";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="BLOCK-SIZE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The maximum number of N-PDUs the CanTp receiver allows the sender to send, before waiting for an authorization to continue transmission of the following N-PDUs. For further details on this parameter value see ISO 15765-2 specification.

            Note: For reasons of buffer length, the CAN Transport Layer can adapt the BS value within the limit of this maximum BS</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpConnectionChannel.blockSize";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CHANNEL-MODE-TYPE" type="AR:CAN-TP-CHANNEL-MODE-TYPE">
            <xsd:annotation>
               <xsd:documentation>The CAN Transport Layer supports half and full duplex channel modes.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpConnectionChannel.channelModeType";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-PDU-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to an NPdu (Single Frame, First Frame or Consecutive Frame).

            The Single Frame network protocol data unit (SF N_PDU) shall be sent out by the sending network entity and can be received by one or multiple receiving network entities.
            The Single Frame (SF N_PDU) shall be sent out to transfer a service data unit that can be transferred via a single service request to the data link layer. This network protocol data unit shall be sent to transfer unsegmented messages.

            The First Frame network protocol data unit (FF N_PDU) identifies the first network protocol data unit (N_PDU) of a segmented message transmitted by a network sending entity and received by a receiving network entity. 

            The Consecutive Frame network protocol data unit (CF N_PDU) transfers segments (N_Data) of the service data unit message data (&lt;MessageData&gt;). All network protocol data units (N_PDUs) transmitted by the sending entity after the First Frame network protocol data unit (FF N_PDU) shall be encoded as Consecutive Frames network protocol data units (CF N_PDUs).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpConnectionChannel.dataPdu";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:N-PDU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FLOW-CONTROL-PDU-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the  Flow Control NPdu.

            The Flow Control network protocol data unit (FC N_PDU) is identified by the Flow Control protocol control information (FC N_PCI). The Flow Control network protocol data unit (FC N_PDU) instructs a sending network entity to start, stop or resume transmission of CF N_PDUs. The Flow Control network protocol data unit shall be sent by the receiving network layer entity to the sending network layer entity, when ready to receive more data, after correct reception of:

            a) First Frame network protocol data unit (FF N_PDU) 
            b) the last Consecutive Frame network protocol data unit (CF N_PDU) of a block of Consecutive Frames (CF N_PDU) if further Consecutive Frame network protocol data unit (CF N_PDU) need(s) to be sent.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpConnectionChannel.flowControlPdu";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:N-PDU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MINIMUM-SEPARATION-TIME" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>This attribute defines the minimum amount of time (separation Time) between two succeeding CFs. Specified in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpConnectionChannel.minimumSeparationTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MULTICAST-ADDRESSING" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Specifies the communication type:

            true: 1:n communication (Functional)
            false: 1:1 communication (Physical)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpConnectionChannel.multicastAddressing";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MULTICAST-REF">
            <xsd:annotation>
               <xsd:documentation>TP address for 1:n connections.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpConnectionChannel.multicast";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:TP-ADDRESS--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PADDING-ACTIVATION" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Defines if the receive frame uses padding or not.

            true:
            The N-PDU received uses padding for SF, FC and the last CF. (N-PDU length is always 8 bytes)

            false:
            The N-PDU received does not use padding for SF, CF and the last CF. (N-PDU length is dynamic)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpConnectionChannel.paddingActivation";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SOURCE-REF">
            <xsd:annotation>
               <xsd:documentation>The source of the TP connection.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpConnectionChannel.source";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:CAN-TP-NODE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TA-TYPE" type="AR:NETWORK-TARGET-ADDRESS-TYPE">
            <xsd:annotation>
               <xsd:documentation>Network Target Address type.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpConnectionChannel.taType";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TARGET-REFS">
            <xsd:annotation>
               <xsd:documentation>The target of the TP connection.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpConnectionChannel.target";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="TARGET-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:CAN-TP-NODE--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMEOUT-AS" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Value in second of the N_As timeout. N_As is the time for transmission of a CAN frame (any N_PDU) on the part of the sender.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpConnectionChannel.timeoutAs";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMEOUT-BR" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>N_Br is the elapsed time (in seconds) between the receiving indication of a FF or CF or the transmit confirmation of a FC, until the transmit request of the next FC.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpConnectionChannel.timeoutBr";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMEOUT-BS" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Value in seconds of the N_Bs timeout. N_Bs is the time of transmission until reception of the next Flow Control N_PDU.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpConnectionChannel.timeoutBs";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMEOUT-CR" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Value in seconds of the N_Cr timeout. N_Cr is the time until reception of the next Consecutive Frame N_PDU.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpConnectionChannel.timeoutCr";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMEOUT-CS" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>N_Cs is the time (in seconds) which elapses between the transmit request of a CF N-PDU until the transmit request of the next CF N-PDU.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpConnectionChannel.timeoutCs";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TP-SDU-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the IPdu that is segmented by the Transport Protocol. 

            To support the low-level routing of NPdu's the NPdu is a specialization of an IPdu. More details can be found in the NPdu class description. Nevertheless the CanTpConnection must not reference a NPdu with this tpSdu reference.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpConnectionChannel.tpSdu";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:I-PDU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TransportProtocols::CanTpConnectionChannel -->
   <xsd:complexType abstract="false" mixed="false" name="CAN-TP-CONNECTION-CHANNEL">
      <xsd:annotation>
         <xsd:documentation>A connection channel represents an internal path for the transmission or reception of a Pdu via CanTp
      and describes the the sender and the receiver of this particular communication.

      The CanTp module routes a Pdu through the connection channel</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanTpConnectionChannel"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:CAN-TP-CONNECTION-CHANNEL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class TransportProtocols::CanTpNode -->
   <xsd:group name="CAN-TP-NODE">
      <xsd:annotation>
         <xsd:documentation>TP Node (Sender or Receiver) provides the TP Address and the connection to the Topology description.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanTpNode"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="RX-WFT-MAX" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>This parameter indicates how many Flow Control wait N-PDUs can be consecutively transmitted by the receiver.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpNode.rxWftMax";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMEOUT-AR" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Value in seconds of the N_Ar timeout. N_Ar is the time for transmission of a CAN frame (any N_PDU) on the receiver side.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CanTpNode.timeoutAr";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TransportProtocols::CanTpNode -->
   <xsd:complexType abstract="false" mixed="false" name="CAN-TP-NODE">
      <xsd:annotation>
         <xsd:documentation>TP Node (Sender or Receiver) provides the TP Address and the connection to the Topology description.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CanTpNode"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:TP-NODE"/>
         <xsd:group ref="AR:CAN-TP-NODE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="CAN-TP-NODE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CAN-TP-NODE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Constants::CharLiteral -->
   <xsd:group name="CHAR-LITERAL">
      <xsd:annotation>
         <xsd:documentation>Character constant description.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CharLiteral"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VALUE" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>The character value (a string of length 1).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CharLiteral.value";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Constants::CharLiteral -->
   <xsd:complexType abstract="false" mixed="false" name="CHAR-LITERAL">
      <xsd:annotation>
         <xsd:documentation>Character constant description.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CharLiteral"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:DATA-PROTOTYPE"/>
         <xsd:group ref="AR:CHAR-LITERAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Datatypes::CharType -->
   <xsd:group name="CHAR-TYPE">
      <xsd:annotation>
         <xsd:documentation>This represents a character belonging to the character-set specified in the encoding.  The semantics are built-in into this datatype.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CharType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpType</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ENCODING" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Specification of character encoding, e.g. ISO-8859-1</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CharType.encoding";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Datatypes::CharType -->
   <xsd:complexType abstract="false" mixed="false" name="CHAR-TYPE">
      <xsd:annotation>
         <xsd:documentation>This represents a character belonging to the character-set specified in the encoding.  The semantics are built-in into this datatype.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CharType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpType</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PRIMITIVE-TYPE"/>
         <xsd:group ref="AR:CHAR-TYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUCParameterDefTemplate::ChoiceContainerDef -->
   <xsd:group name="CHOICE-CONTAINER-DEF">
      <xsd:annotation>
         <xsd:documentation>Used to define configuration containers that provide a choice between several ParamConfContainerDef. But in the actual ECU Configuration Description only one instance from the choice list will be present (depending on the multiplicites given).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ChoiceContainerDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CHOICES">
            <xsd:annotation>
               <xsd:documentation>The choices available in a ChoiceContainerDef.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="choice.ChoiceContainerDef";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="PARAM-CONF-CONTAINER-DEF" type="AR:PARAM-CONF-CONTAINER-DEF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::ChoiceContainerDef -->
   <xsd:complexType abstract="false" mixed="false" name="CHOICE-CONTAINER-DEF">
      <xsd:annotation>
         <xsd:documentation>Used to define configuration containers that provide a choice between several ParamConfContainerDef. But in the actual ECU Configuration Description only one instance from the choice list will be present (depending on the multiplicites given).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ChoiceContainerDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PARAM-CONF-MULTIPLICITY"/>
         <xsd:group ref="AR:CONTAINER-DEF"/>
         <xsd:group ref="AR:CHOICE-CONTAINER-DEF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUCParameterDefTemplate::ChoiceReferenceParamDef -->
   <xsd:group name="CHOICE-REFERENCE-PARAM-DEF">
      <xsd:annotation>
         <xsd:documentation>Specify alternative references where in the ECU Configuration description only one of the specified references will actually be used.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ChoiceReferenceParamDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DESTINATION-REFS">
            <xsd:annotation>
               <xsd:documentation>All the possible parameter containers for the reference are specified.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ChoiceReferenceParamDef.destination";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="DESTINATION-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:PARAM-CONF-CONTAINER-DEF--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::ChoiceReferenceParamDef -->
   <xsd:complexType abstract="false" mixed="false" name="CHOICE-REFERENCE-PARAM-DEF">
      <xsd:annotation>
         <xsd:documentation>Specify alternative references where in the ECU Configuration description only one of the specified references will actually be used.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ChoiceReferenceParamDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PARAM-CONF-MULTIPLICITY"/>
         <xsd:group ref="AR:COMMON-CONFIGURATION-ATTRIBUTES"/>
         <xsd:group ref="AR:CHOICE-REFERENCE-PARAM-DEF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Communication::ClientComSpec -->
   <xsd:group name="CLIENT-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>Client specific communication attributes (R-Port and client-server interface).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="OPERATION-REF">
            <xsd:annotation>
               <xsd:documentation>Operation these attributes belong to.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ClientComSpec.operation";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:OPERATION-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Communication::ClientComSpec -->
   <xsd:complexType abstract="false" mixed="false" name="CLIENT-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>Client specific communication attributes (R-Port and client-server interface).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:CLIENT-COM-SPEC"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataMapping::ClientIdMapping -->
   <xsd:group name="CLIENT-ID-MAPPING">
      <xsd:annotation>
         <xsd:documentation>In case of a server on one ECU with multiple clients on other ECUs, the client server communication shall use different unique COM signals and signal groups for each client to allow the identification of the client associated with each system signal.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientIdMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYSTEM-SIGNAL-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the SystemSignal with the ClientID.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ClientIdMapping.systemSignal";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SYSTEM-SIGNAL--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataMapping::ClientIdMapping -->
   <xsd:complexType abstract="false" mixed="false" name="CLIENT-ID-MAPPING">
      <xsd:annotation>
         <xsd:documentation>In case of a server on one ECU with multiple clients on other ECUs, the client server communication shall use different unique COM signals and signal groups for each client to allow the identification of the client associated with each system signal.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientIdMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:CLIENT-ID-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataMapping::ClientServerArrayElementMapping -->
   <xsd:group name="CLIENT-SERVER-ARRAY-ELEMENT-MAPPING">
      <xsd:annotation>
         <xsd:documentation>The ArrayElement may be a primitive one or a composite one. If the element is primitive, it will be mapped to the "SystemSignal" (multiplicity 1).
      If the element is composite, there will be no mapping to the "SystemSignal" (multiplicity 0). In this case the "ArrayElementMapping" Element will aggregate the "TypeMapping" Element. In that way also the composite datatypes can be mapped to SystemSignals. 

      Regardless whether composite or primitive array element is mapped the indexed array element always needs to be specified.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerArrayElementMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPLEX-TYPE-MAPPING">
            <xsd:annotation>
               <xsd:documentation>This aggregation will be used if the element is  composite.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="complexTypeMapping.ClientServerArrayElementMapping";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="CLIENT-SERVER-ARRAY-TYPE-MAPPING" type="AR:CLIENT-SERVER-ARRAY-TYPE-MAPPING"/>
                  <xsd:element name="CLIENT-SERVER-RECORD-TYPE-MAPPING" type="AR:CLIENT-SERVER-RECORD-TYPE-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INDEXED-ARRAY-ELEMENT" type="AR:INDEXED-ARRAY-ELEMENT">
            <xsd:annotation>
               <xsd:documentation>Reference to an indexed array element in the context of the mappedOperation or in the context of a composite element.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="indexedArrayElement.ClientServerArrayElementMapping";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SIGNAL-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the system signal used to carry the primitive ArrayElement.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerArrayElementMapping.signal";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SYSTEM-SIGNAL--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataMapping::ClientServerArrayElementMapping -->
   <xsd:complexType abstract="false" mixed="false" name="CLIENT-SERVER-ARRAY-ELEMENT-MAPPING">
      <xsd:annotation>
         <xsd:documentation>The ArrayElement may be a primitive one or a composite one. If the element is primitive, it will be mapped to the "SystemSignal" (multiplicity 1).
      If the element is composite, there will be no mapping to the "SystemSignal" (multiplicity 0). In this case the "ArrayElementMapping" Element will aggregate the "TypeMapping" Element. In that way also the composite datatypes can be mapped to SystemSignals. 

      Regardless whether composite or primitive array element is mapped the indexed array element always needs to be specified.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerArrayElementMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:CLIENT-SERVER-ARRAY-ELEMENT-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataMapping::ClientServerArrayTypeMapping -->
   <xsd:group name="CLIENT-SERVER-ARRAY-TYPE-MAPPING">
      <xsd:annotation>
         <xsd:documentation>If the compositeType is an Array, the "ArrayTypeMapping" will be used.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerArrayTypeMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ARRAY-ELEMENT-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>Each ArrayElement must be mapped on a SystemSignal.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="arrayElementMapping.ClientServerArrayTypeMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CLIENT-SERVER-ARRAY-ELEMENT-MAPPING" type="AR:CLIENT-SERVER-ARRAY-ELEMENT-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataMapping::ClientServerArrayTypeMapping -->
   <xsd:complexType abstract="false" mixed="false" name="CLIENT-SERVER-ARRAY-TYPE-MAPPING">
      <xsd:annotation>
         <xsd:documentation>If the compositeType is an Array, the "ArrayTypeMapping" will be used.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerArrayTypeMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:CLIENT-SERVER-COMPOSITE-TYPE-MAPPING"/>
         <xsd:group ref="AR:CLIENT-SERVER-ARRAY-TYPE-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataMapping::ClientServerCompositeTypeMapping -->
   <xsd:group name="CLIENT-SERVER-COMPOSITE-TYPE-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Two mappings exist for the composite data types: "ArrayTypeMapping" and "RecordTypeMapping".
      In both, a primitive datatype will be mapped to a system signal. 

      But it is also possible to combine the arrays and the records, so that an "array" could be an element of a "record" and in the same manner a "record" could be an element of an "array". Nesting these data types is also possible.

      If an element of a composite data type is again a composite one, the "CompositeTypeMapping" element will be used one more time (aggregation between the ArrayElementMapping and CompositeTypeMapping or aggregation between the RecordElementMapping and CompositeTypeMapping).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerCompositeTypeMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ARGUMENT-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to an argument in the context of the mappedOperation. Only ClientServerCompositeTypeMapping elements that are directly aggregated by the ClientServerToSignalGroupMapping shall contain this reference.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerCompositeTypeMapping.argument";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ARGUMENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class PortInterface::ClientServerInterface -->
   <xsd:group name="CLIENT-SERVER-INTERFACE">
      <xsd:annotation>
         <xsd:documentation>A client/server interface declares a number of operations that can be invoked on a server by a client.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerInterface"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpType</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="OPERATIONS">
            <xsd:annotation>
               <xsd:documentation>OperationPrototypes owned by this ClientServerInterface.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="operation.interface";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="OPERATION-PROTOTYPE" type="AR:OPERATION-PROTOTYPE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="POSSIBLE-ERRORS">
            <xsd:annotation>
               <xsd:documentation>Application errors that are defined as part of this interface.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="possibleError.ClientServerInterface";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="APPLICATION-ERROR" type="AR:APPLICATION-ERROR"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class PortInterface::ClientServerInterface -->
   <xsd:complexType abstract="false" mixed="false" name="CLIENT-SERVER-INTERFACE">
      <xsd:annotation>
         <xsd:documentation>A client/server interface declares a number of operations that can be invoked on a server by a client.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerInterface"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpType</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PORT-INTERFACE"/>
         <xsd:group ref="AR:CLIENT-SERVER-INTERFACE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class DataMapping::ClientServerPrimitiveTypeMapping -->
   <xsd:group name="CLIENT-SERVER-PRIMITIVE-TYPE-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Mapping of an argument with a primitive datatype to a signal.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerPrimitiveTypeMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ARGUMENT-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to an argument in the context of the mappedOperation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerPrimitiveTypeMapping.argument";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ARGUMENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYSTEM-SIGNAL-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the system signal used to carry the argument</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerPrimitiveTypeMapping.systemSignal";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SYSTEM-SIGNAL--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataMapping::ClientServerPrimitiveTypeMapping -->
   <xsd:complexType abstract="false" mixed="false" name="CLIENT-SERVER-PRIMITIVE-TYPE-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Mapping of an argument with a primitive datatype to a signal.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerPrimitiveTypeMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:CLIENT-SERVER-PRIMITIVE-TYPE-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataMapping::ClientServerRecordElementMapping -->
   <xsd:group name="CLIENT-SERVER-RECORD-ELEMENT-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Mapping of a primitive record element to a SystemSignal. 

      If the element is composite, there will be no mapping (multiplicity 0). In this case the "RecordElementMapping" Element will aggregate the "TypeMapping" Element. In that way also the composite datatypes can be mapped to SystemSignals. 

      Regardless whether composite or primitive record element is mapped the record element always needs to be specified.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerRecordElementMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPLEX-TYPE-MAPPING">
            <xsd:annotation>
               <xsd:documentation>This aggregation will be used if the element is  composite.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="complexTypeMapping.ClientServerRecordElementMapping";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="CLIENT-SERVER-ARRAY-TYPE-MAPPING" type="AR:CLIENT-SERVER-ARRAY-TYPE-MAPPING"/>
                  <xsd:element name="CLIENT-SERVER-RECORD-TYPE-MAPPING" type="AR:CLIENT-SERVER-RECORD-TYPE-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RECORD-ELEMENT-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to a RecordElement in the context of the mappedOperation or in the context of a composite element.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerRecordElementMapping.recordElement";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:RECORD-ELEMENT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SIGNAL-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the system signal used to carry the primitive RecordElement.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerRecordElementMapping.signal";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SYSTEM-SIGNAL--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataMapping::ClientServerRecordElementMapping -->
   <xsd:complexType abstract="false" mixed="false" name="CLIENT-SERVER-RECORD-ELEMENT-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Mapping of a primitive record element to a SystemSignal. 

      If the element is composite, there will be no mapping (multiplicity 0). In this case the "RecordElementMapping" Element will aggregate the "TypeMapping" Element. In that way also the composite datatypes can be mapped to SystemSignals. 

      Regardless whether composite or primitive record element is mapped the record element always needs to be specified.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerRecordElementMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:CLIENT-SERVER-RECORD-ELEMENT-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataMapping::ClientServerRecordTypeMapping -->
   <xsd:group name="CLIENT-SERVER-RECORD-TYPE-MAPPING">
      <xsd:annotation>
         <xsd:documentation>If the compositeType is a Record, the "RecordTypeMapping" will be used.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerRecordTypeMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="RECORD-ELEMENT-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>Each RecordElement must be mapped on a SystemSignal.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="recordElementMapping.ClientServerRecordTypeMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CLIENT-SERVER-RECORD-ELEMENT-MAPPING" type="AR:CLIENT-SERVER-RECORD-ELEMENT-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataMapping::ClientServerRecordTypeMapping -->
   <xsd:complexType abstract="false" mixed="false" name="CLIENT-SERVER-RECORD-TYPE-MAPPING">
      <xsd:annotation>
         <xsd:documentation>If the compositeType is a Record, the "RecordTypeMapping" will be used.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerRecordTypeMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:CLIENT-SERVER-COMPOSITE-TYPE-MAPPING"/>
         <xsd:group ref="AR:CLIENT-SERVER-RECORD-TYPE-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataMapping::ClientServerToSignalGroupMapping -->
   <xsd:group name="CLIENT-SERVER-TO-SIGNAL-GROUP-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Mapping of client server operation arguments to signals of a signal group. Arguments with a primitive datatype will be mapped via the "ClientServerPrimitiveTypeMapping" element. 
      Arguments with composite datatypes will be mapped via the "CompositeTypeMapping" element.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerToSignalGroupMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="APPLICATION-ERRORS">
            <xsd:annotation>
               <xsd:documentation>In client server communication, the server may return any value within the application error range.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="applicationError.ClientServerToSignalGroupMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="APPLICATION-ERROR-MAPPING" type="AR:APPLICATION-ERROR-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CLIENT-ID" type="AR:CLIENT-ID-MAPPING">
            <xsd:annotation>
               <xsd:documentation>In case of a server on one ECU with multiple clients on other ECUs, the client server communication shall use different unique COM signals and signal groups for each client to allow the identification of the client associated with each system signal.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="clientID.ClientServerToSignalGroupMapping";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPOSITE-TYPE-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>Mapping of arguments with composite datatypes.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="compositeTypeMapping.ClientServerToSignalGroupMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CLIENT-SERVER-ARRAY-TYPE-MAPPING" type="AR:CLIENT-SERVER-ARRAY-TYPE-MAPPING"/>
                  <xsd:element name="CLIENT-SERVER-RECORD-TYPE-MAPPING" type="AR:CLIENT-SERVER-RECORD-TYPE-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EMPTY-SIGNAL" type="AR:EMPTY-SIGNAL-MAPPING">
            <xsd:annotation>
               <xsd:documentation>According to the COM Specification, signal groups without signals are allowed. These have a "signalLength" = 0. In this case there shall be an "update-bit" configured.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="emptySignal.ClientServerToSignalGroupMapping";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAPPED-OPERATION-IREF" type="AR:CLIENT-SERVER-TO-SIGNAL-GROUP-MAPPING--MAPPED-OPERATION-IREF">
            <xsd:annotation>
               <xsd:documentation>Reference to the operation whose arguments should be transmitted via the communication bus.
            Reference to a Operation, which is mapped to a signal group.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="mappedOperation.ClientServerToSignalGroupMapping";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PRIMITIVE-TYPE-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>Mapping of an argument with a primitive datatype to a signal.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="primitiveTypeMapping.ClientServerToSignalGroupMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CLIENT-SERVER-PRIMITIVE-TYPE-MAPPING" type="AR:CLIENT-SERVER-PRIMITIVE-TYPE-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REQUEST-GROUP-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the signal group which contains the references to request signals used to transport the OUT arguments of the operation or the empty signal if the operation doesn't have OUT arguments.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerToSignalGroupMapping.requestGroup";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SYSTEM-SIGNAL-GROUP--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RESPONSE-GROUP-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the signal group which contains the references to response signals used to transport the IN arguments of the operation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerToSignalGroupMapping.responseGroup";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SYSTEM-SIGNAL-GROUP--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SEQUENCE-COUNTER" type="AR:SEQUENCE-COUNTER-MAPPING">
            <xsd:annotation>
               <xsd:documentation>The purpose of sequence counters is to map a response to the correct request of a known client.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="sequenceCounter.ClientServerToSignalGroupMapping";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataMapping::ClientServerToSignalGroupMapping -->
   <xsd:complexType abstract="false" mixed="false" name="CLIENT-SERVER-TO-SIGNAL-GROUP-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Mapping of client server operation arguments to signals of a signal group. Arguments with a primitive datatype will be mapped via the "ClientServerPrimitiveTypeMapping" element. 
      Arguments with composite datatypes will be mapped via the "CompositeTypeMapping" element.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerToSignalGroupMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:CLIENT-SERVER-TO-SIGNAL-GROUP-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class _instanceRef::ClientServerToSignalGroupMapping_mappedOperation -->
   <xsd:group name="CLIENT-SERVER-TO-SIGNAL-GROUP-MAPPING--MAPPED-OPERATION-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerToSignalGroupMapping_mappedOperation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPOSITION-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerToSignalGroupMapping_mappedOperation.compositionPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="10"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SOFTWARE-COMPOSITION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="COMPONENT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerToSignalGroupMapping_mappedOperation.componentPrototype";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMPONENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PORT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerToSignalGroupMapping_mappedOperation.portPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="1" name="OPERATION-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerToSignalGroupMapping_mappedOperation.operation";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="40"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.target</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:OPERATION-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class _instanceRef::ClientServerToSignalGroupMapping_mappedOperation -->
   <xsd:complexType abstract="false" mixed="false" name="CLIENT-SERVER-TO-SIGNAL-GROUP-MAPPING--MAPPED-OPERATION-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ClientServerToSignalGroupMapping_mappedOperation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:CLIENT-SERVER-TO-SIGNAL-GROUP-MAPPING--MAPPED-OPERATION-IREF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ECUElectronics::Clock -->
   <xsd:group name="CLOCK">
      <xsd:annotation>
         <xsd:documentation>The clock delivers the time for the PU and other HW Elements on the ECU.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Clock"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ADJUSTABLE" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Defines if the clock is adjustable from software.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Clock.adjustable";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CLOCK-JITTER" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>The short-term deviation of the nominal frequency to the real frequency. Jitter is influenced by the circuitry itself, voltage spikes etc. Jitter is critical for communication elements. PLL need/generate jitter for operation. Therefore communication interfaces should operate from an oscillator e.g. quartz directly or use only divider, not a PLL, as clock source. Using PLL for communication interfaces is a very common source for problems in ECU test and integration.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Clock.clockJitter";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CLOCK-STARTUP-TIME" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>The time the clock generation needs to deliver a stable and valid signal.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Clock.clockStartupTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CLOCK-TOLERANCE" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>The long-term deviation of the nominal frequency to the real frequency. Influenced by manufacturing, layout, temperature, external components and voltage. Tolerances are critical for timer application and time synchronisation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Clock.clockTolerance";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FREQUENCY" type="AR:FREQUENCY-RANGE">
            <xsd:annotation>
               <xsd:documentation>The frequency range the clock is able to provide. This value depends on what the oscillator is delivering.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="frequency.Clock";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="OSCILLATOR-REFS">
            <xsd:annotation>
               <xsd:documentation>Specifies which oscillator is used to generate the clock.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Clock.oscillator";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="OSCILLATOR-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:OSCILLATOR--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TYPE" type="AR:CLOCK-TYPE-ENUM">
            <xsd:annotation>
               <xsd:documentation>Defines the type of the clock signal.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Clock.type";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUElectronics::Clock -->
   <xsd:complexType abstract="false" mixed="false" name="CLOCK">
      <xsd:annotation>
         <xsd:documentation>The clock delivers the time for the PU and other HW Elements on the ECU.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Clock"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HW-ELEMENT"/>
         <xsd:group ref="AR:ECU-ELECTRONICS"/>
         <xsd:group ref="AR:CLOCK"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="CLOCK--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CLOCK"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Implementation::Code -->
   <xsd:group name="CODE">
      <xsd:annotation>
         <xsd:documentation>A generic code descriptor.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Code"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TYPE" type="AR:CODE-TYPE-ENUM">
            <xsd:annotation>
               <xsd:documentation>The type of described code.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Code.type";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="XFILES">
            <xsd:annotation>
               <xsd:documentation>The files belonging to this code descriptor.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Code.xfile";pureMM.maxOccurs="-1";pureMM.minOccurs="1";xml.roleElement="true";xml.typeElement="false"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="XFILE" type="AR:XFILE-SO"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Implementation::Code -->
   <xsd:complexType abstract="false" mixed="false" name="CODE">
      <xsd:annotation>
         <xsd:documentation>A generic code descriptor.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Code"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:CODE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ServiceNeeds::ComMgrUserNeeds -->
   <xsd:group name="COM-MGR-USER-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs on the configuration of the Communication Manager for one "user".</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ComMgrUserNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-COMM-MODE" type="AR:MAX-COMM-MODE-ENUM">
            <xsd:annotation>
               <xsd:documentation>Maximum communication mode requested by this ComM user</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ComMgrUserNeeds.maxCommMode";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceNeeds::ComMgrUserNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="COM-MGR-USER-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs on the configuration of the Communication Manager for one "user".</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ComMgrUserNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COM-MGR-USER-NEEDS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class CoreTopology::CommConnectorPort -->
   <xsd:group name="COMM-CONNECTOR-PORT">
      <xsd:annotation>
         <xsd:documentation>The Ecu communication relationship defines which signals, Pdus and frames are actually received and transmitted by this ECU. 

      For each signal, Pdu or Frame that is transmitted or received and used by the Ecu an association between a SignalPort, IPduPort or FramePort with the corresponding Triggering shall be created. 
      A SignalPort shall be created only if the corresponding signal is handled by COM (RTE or Signal Gateway). 
      If a Pdu Gateway ECU only routes the Pdu without being interested in the content only a FramePort and an IPduPort needs to be created.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CommConnectorPort"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMMUNICATION-DIRECTION" type="AR:COMMUNICATION-DIRECTION-TYPE">
            <xsd:annotation>
               <xsd:documentation>communication Direction of the Connector Port (input or output Port).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CommConnectorPort.communicationDirection";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class ECUCParameterDefTemplate::CommonConfigurationAttributes -->
   <xsd:group name="COMMON-CONFIGURATION-ATTRIBUTES">
      <xsd:annotation>
         <xsd:documentation>Attributes used by Configuration Parameters as well as References.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CommonConfigurationAttributes"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONFIGURATION-CLASS-AFFECTION" type="AR:CONFIGURATION-CLASS-AFFECTION">
            <xsd:annotation>
               <xsd:documentation>Specifes whether changes on this parameter have some affection on other parameters. This element is deprecated and will be removed in future versions.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="configurationClassAffection.CommonConfigurationAttributes";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="IMPLEMENTATION-CONFIG-CLASSES">
            <xsd:annotation>
               <xsd:documentation>Specifies which in which ConfigurationClass this parameter or reference is available for which ConfigurationVariant.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="implementationConfigClass.CommonConfigurationAttributes";pureMM.maxOccurs="-1";pureMM.minOccurs="1";xml.namePlural="IMPLEMENTATION-CONFIG-CLASSES"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="IMPLEMENTATION-CONFIG-CLASS" type="AR:IMPLEMENTATION-CONFIG-CLASS"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ORIGIN" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>String specifying if this configuration parameter is an AUTOSAR standardized configuration parameter or if the parameter is hardware- or vendor-specific.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CommonConfigurationAttributes.origin";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <xsd:simpleType name="COMMON-CONFIGURATION-ATTRIBUTES--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="BOOLEAN-PARAM-DEF"/>
         <xsd:enumeration value="CHOICE-REFERENCE-PARAM-DEF"/>
         <xsd:enumeration value="DERIVED-BOOLEAN-PARAM-DEF"/>
         <xsd:enumeration value="DERIVED-ENUMERATION-PARAM-DEF"/>
         <xsd:enumeration value="DERIVED-FLOAT-PARAM-DEF"/>
         <xsd:enumeration value="DERIVED-INTEGER-PARAM-DEF"/>
         <xsd:enumeration value="DERIVED-STRING-PARAM-DEF"/>
         <xsd:enumeration value="ENUMERATION-PARAM-DEF"/>
         <xsd:enumeration value="FLOAT-PARAM-DEF"/>
         <xsd:enumeration value="FOREIGN-REFERENCE-PARAM-DEF"/>
         <xsd:enumeration value="FUNCTION-NAME-DEF"/>
         <xsd:enumeration value="INSTANCE-REFERENCE-PARAM-DEF"/>
         <xsd:enumeration value="INTEGER-PARAM-DEF"/>
         <xsd:enumeration value="LINKER-SYMBOL-DEF"/>
         <xsd:enumeration value="REFERENCE-PARAM-DEF"/>
         <xsd:enumeration value="STRING-PARAM-DEF"/>
         <xsd:enumeration value="SYMBOLIC-NAME-REFERENCE-PARAM-DEF"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class SignalPaths::CommonSignalPath -->
   <xsd:group name="COMMON-SIGNAL-PATH">
      <xsd:annotation>
         <xsd:documentation>The CommonSignalPath describes that two or more SwcToSwcSignals and/or SwcToSwcOperationArguments must take the same way (Signal Path) in the topology.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CommonSignalPath"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="OPERATIONS">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="operation.CommonSignalPath";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SWC-TO-SWC-OPERATION-ARGUMENTS" type="AR:SWC-TO-SWC-OPERATION-ARGUMENTS"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SIGNALS">
            <xsd:annotation>
               <xsd:documentation>The SwcToSwcSignals that must take the same way (Signal Path) in the topology.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="signal.CommonSignalPath";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SWC-TO-SWC-SIGNAL" type="AR:SWC-TO-SWC-SIGNAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SignalPaths::CommonSignalPath -->
   <xsd:complexType abstract="false" mixed="false" name="COMMON-SIGNAL-PATH">
      <xsd:annotation>
         <xsd:documentation>The CommonSignalPath describes that two or more SwcToSwcSignals and/or SwcToSwcOperationArguments must take the same way (Signal Path) in the topology.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CommonSignalPath"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:COMMON-SIGNAL-PATH"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CoreTopology::CommunicationCluster -->
   <xsd:group name="COMMUNICATION-CLUSTER">
      <xsd:annotation>
         <xsd:documentation>The CommunicationCluster is the main element to describe the topological connection of communicating ECUs.

      A cluster describes the ensemble of ECUs, which are linked by a communication medium of arbitrary topology (bus, star, ring, ...). The nodes within the cluster share the same communication protocol, which may be event-triggered, time-triggered or a combination of both.

      A CommunicationCluster aggregates one or more physical channels. All physical channels that are aggregated by a communication cluster  are synchronized with each other.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationCluster"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-FRAME-LENGTH" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Maximal supported length in bytes for frames in this cluster.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationCluster.maxFrameLength";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-NODE-DETECTION-ENABLED" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Enable/disable the node detection functionality.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationCluster.nmNodeDetectionEnabled";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-NODE-ID-ENABLED" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Enable/disable the source node identifier.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationCluster.nmNodeIdEnabled";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-REPEAT-MESSAGE-SUPPORT" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>switch for enabling support for repeat message</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationCluster.nmRepeatMessageSupport";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PHYSICAL-CHANNELS">
            <xsd:annotation>
               <xsd:documentation>This relationship defines which channel element belongs to which cluster. A channel must be assigned to exactly one cluster, whereas a cluster may have one or more channels.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="physicalChannel.CommunicationCluster";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="FLEXRAY-PHYSICAL-CHANNEL" type="AR:FLEXRAY-PHYSICAL-CHANNEL"/>
                  <xsd:element name="PHYSICAL-CHANNEL" type="AR:PHYSICAL-CHANNEL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PROTOCOL-NAME" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>The name of the protocol used.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationCluster.protocolName";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PROTOCOL-VERSION" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>The version of the protocol used.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationCluster.protocolVersion";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SPEED" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>channels speed in bits per second</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationCluster.speed";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreTopology::CommunicationCluster -->
   <xsd:complexType abstract="false" mixed="false" name="COMMUNICATION-CLUSTER">
      <xsd:annotation>
         <xsd:documentation>The CommunicationCluster is the main element to describe the topological connection of communicating ECUs.

      A cluster describes the ensemble of ECUs, which are linked by a communication medium of arbitrary topology (bus, star, ring, ...). The nodes within the cluster share the same communication protocol, which may be event-triggered, time-triggered or a combination of both.

      A CommunicationCluster aggregates one or more physical channels. All physical channels that are aggregated by a communication cluster  are synchronized with each other.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationCluster"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COMMUNICATION-CLUSTER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class CoreTopology::CommunicationConnector -->
   <xsd:group name="COMMUNICATION-CONNECTOR">
      <xsd:annotation>
         <xsd:documentation>The connection between the referencing ECU and the referenced channel via the referenced controller.

      Connectors are used to describe the bus interfaces of the ECUs and to specify the sending/receiving behavior. 

      Each CommunicationConnector has a reference to exactly one communicationController. 

      The communicationController can be referenced by several CommunicationConnector elements. This is important for the FlexRay Bus. 
      FlexRay communicates via two physical channels. But only one controller in an ECU is responsible for both channels. Thus, two connectors (for channel A and for channel B) must reference to the same controller. 

      The relationship of CommunicationConnector and PhysicalChannel in the scope of one EcuInstance is always 1:1. The existence of two or more CommunicationConnectors aggregated at the same EcuInstance that reference the same PhysicalChannel is prohibited.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationConnector"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CHANNEL-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the channel to which the ECU is connected.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationConnector.channel";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PHYSICAL-CHANNEL--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMM-CONTROLLER-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the communication controller.
            The CommunicationConnector and referenced CommunicationController must be aggregated by the same ECUInstance.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationConnector.commController";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMMUNICATION-CONTROLLER--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECU-COMM-PORT-INSTANCES">
            <xsd:annotation>
               <xsd:documentation>An ECUs reception or send ports.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ecuCommPortInstance.CommunicationConnector";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="FRAME-PORT" type="AR:FRAME-PORT"/>
                  <xsd:element name="I-PDU-PORT" type="AR:I-PDU-PORT"/>
                  <xsd:element name="SIGNAL-PORT" type="AR:SIGNAL-PORT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-ADDRESS" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>An ECUs NM address on the referenced channel.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationConnector.nmAddress";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PNC-GATEWAY-TYPE" type="AR:PNC-GATEWAY-TYPE-ENUM">
            <xsd:annotation>
               <xsd:documentation>Defines if this EcuInstance shall implement the PncGateway functionality on this CommunicationConnector and its respective PhysicalChannel. Several EcuInstances on the same PhysicalChannel can have the PncGateway functionality enabled, but only one of them shall have the pncGatewayType "active".</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationConnector.pncGatewayType";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreTopology::CommunicationConnector -->
   <xsd:complexType abstract="false" mixed="false" name="COMMUNICATION-CONNECTOR">
      <xsd:annotation>
         <xsd:documentation>The connection between the referencing ECU and the referenced channel via the referenced controller.

      Connectors are used to describe the bus interfaces of the ECUs and to specify the sending/receiving behavior. 

      Each CommunicationConnector has a reference to exactly one communicationController. 

      The communicationController can be referenced by several CommunicationConnector elements. This is important for the FlexRay Bus. 
      FlexRay communicates via two physical channels. But only one controller in an ECU is responsible for both channels. Thus, two connectors (for channel A and for channel B) must reference to the same controller. 

      The relationship of CommunicationConnector and PhysicalChannel in the scope of one EcuInstance is always 1:1. The existence of two or more CommunicationConnectors aggregated at the same EcuInstance that reference the same PhysicalChannel is prohibited.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationConnector"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COMMUNICATION-CONNECTOR"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="COMMUNICATION-CONNECTOR--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CAN-COMMUNICATION-CONNECTOR"/>
         <xsd:enumeration value="COMMUNICATION-CONNECTOR"/>
         <xsd:enumeration value="FLEX-RAY-COMMUNICATION-CONNECTOR"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class CoreTopology::CommunicationController -->
   <xsd:group name="COMMUNICATION-CONTROLLER">
      <xsd:annotation>
         <xsd:documentation>The communication controller is a dedicated hardware device by means of which hosts are sending frames to and receiving frames from the communication medium.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationController"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="WAKE-UP-BY-CONTROLLER-SUPPORTED" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>May the ECU be woken up  by this CAN Controller? 
            TRUE: wake up is possible
            FALSE: wake up is not supported Note: 

            This flag may only be set to TRUE if the feature is supported by both hardware and basic software.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationController.wakeUpByControllerSupported";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreTopology::CommunicationController -->
   <xsd:complexType abstract="false" mixed="false" name="COMMUNICATION-CONTROLLER">
      <xsd:annotation>
         <xsd:documentation>The communication controller is a dedicated hardware device by means of which hosts are sending frames to and receiving frames from the communication medium.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationController"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COMMUNICATION-CONTROLLER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="COMMUNICATION-CONTROLLER--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CAN-COMMUNICATION-CONTROLLER"/>
         <xsd:enumeration value="COMMUNICATION-CONTROLLER"/>
         <xsd:enumeration value="FLEXRAY-COMMUNICATION-CONTROLLER"/>
         <xsd:enumeration value="LIN-MASTER"/>
         <xsd:enumeration value="LIN-SLAVE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ECUResourceMapping::CommunicationControllerMapping -->
   <xsd:group name="COMMUNICATION-CONTROLLER-MAPPING">
      <xsd:annotation>
         <xsd:documentation>CommunicationControllerMapping specifies the CommunicationPeripheral
      hardware (defined in the ECU Resource Template) to realize the specified CommunicationController in a physical topology.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationControllerMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMMUNICATION-CONTROLLER-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the CommunicationController in the System Template</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationControllerMapping.communicationController";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMMUNICATION-CONTROLLER--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMMUNICATION-PERIPHERAL-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationControllerMapping.communicationPeripheral";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMMUNICATION-PERIPHERAL--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUResourceMapping::CommunicationControllerMapping -->
   <xsd:complexType abstract="false" mixed="false" name="COMMUNICATION-CONTROLLER-MAPPING">
      <xsd:annotation>
         <xsd:documentation>CommunicationControllerMapping specifies the CommunicationPeripheral
      hardware (defined in the ECU Resource Template) to realize the specified CommunicationController in a physical topology.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationControllerMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:COMMUNICATION-CONTROLLER-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Peripherals::CommunicationFilter -->
   <xsd:group name="COMMUNICATION-FILTER">
      <xsd:annotation>
         <xsd:documentation>Describes the amount and the size of the communication filters. These can be used as acceptance or rejection filters.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationFilter"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="FILTER-COUNT" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>How many acceptance filters are availabe.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationFilter.filterCount";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FILTER-WIDTH" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Which bit-size do the filters have.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationFilter.filterWidth";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="WILD-CARDS" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Is it possible to provide wildcard identifires allowing to specify ranges for filtering.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationFilter.wildCards";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Peripherals::CommunicationFilter -->
   <xsd:complexType abstract="false" mixed="false" name="COMMUNICATION-FILTER">
      <xsd:annotation>
         <xsd:documentation>Describes the amount and the size of the communication filters. These can be used as acceptance or rejection filters.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationFilter"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:COMMUNICATION-FILTER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Peripherals::CommunicationHWPort -->
   <xsd:group name="COMMUNICATION-HW-PORT">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationHWPort"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="PHYSICAL-LAYER" type="AR:COMMUNICATION-PHYSICAL-MEDIUM">
            <xsd:annotation>
               <xsd:documentation>Describes the physical medium the bus is working on. In most cases it is not relevant for the SW to know about it.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="physicalLayer.CommunicationHWPort";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SPEED">
            <xsd:annotation>
               <xsd:documentation>The Communication speed can be provided either as a fixed value if it can not be changed by software. Or there can be a range in which software can configure the communication speed. Also a list of possible speed values can be provided from which the software can choose.
            If the communication speed is not fixed with one value the System Constraint Description has the freedom to choose from the given range or list of communication speed. In the end only HW Ports with the same communication speed can be connected to a bus system.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="speed.CommunicationHWPort";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="COMMUNICATION-SPEED-FIXED" type="AR:COMMUNICATION-SPEED-FIXED"/>
                  <xsd:element name="COMMUNICATION-SPEED-LIST" type="AR:COMMUNICATION-SPEED-LIST"/>
                  <xsd:element name="COMMUNICATION-SPEED-RANGE" type="AR:COMMUNICATION-SPEED-RANGE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Peripherals::CommunicationHWPort -->
   <xsd:complexType abstract="false" mixed="false" name="COMMUNICATION-HW-PORT">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationHWPort"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HW-PORT"/>
         <xsd:group ref="AR:PERIPHERAL-HW-PORT"/>
         <xsd:group ref="AR:COMMUNICATION-HW-PORT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Peripherals::CommunicationPeripheral -->
   <xsd:group name="COMMUNICATION-PERIPHERAL">
      <xsd:annotation>
         <xsd:documentation>Peripheral representing communication devices.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationPeripheral"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ACCEPTANCE-FILTER" type="AR:COMMUNICATION-FILTER">
            <xsd:annotation>
               <xsd:documentation>If the Communication Peripheral supports filtering of frames here the amount and quality of filters is described.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="acceptanceFilter.CommunicationPeripheral";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ARCHITECTURE" type="AR:COMMUNICATION-ARCHITECTURE-ENUM">
            <xsd:annotation>
               <xsd:documentation>The implemented architecture</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationPeripheral.architecture";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CLOCK-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the clock description. This is used to calculate possible transmission rates.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationPeripheral.clock";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:CLOCK--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ERROR-DETECTION" type="AR:ERROR-DETECTION-CORRECTION">
            <xsd:annotation>
               <xsd:documentation>Under certain conditions that are likely to appear in automotive applications, the transmission of information between communication endpoints might be unsafe because of particular sources of interference . It is possible to detect the presence of interference by means of error-detection codes (EDC) and at least partly overcome the problem by means of error-correction codes (ECC). 
            Error detection is a method that allows some communication errors to be detected. For this purpose the introduction of redundancy is required such that the information transmitted consists of more bits than the source of information. The extra bits are required for EDC and ECC.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="errorDetection.CommunicationPeripheral";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="HW-PORTS">
            <xsd:annotation>
               <xsd:documentation>Describes the actual ommunication HW Port of this peripheral.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="hwPort.CommunicationPeripheral";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="COMMUNICATION-HW-PORT" type="AR:COMMUNICATION-HW-PORT"/>
                  <xsd:element name="ECU-COMMUNICATION-PORT" type="AR:ECU-COMMUNICATION-PORT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MONITOR" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>The Element Monitor specifies if the device supports listen only. In this mode the device is passive on the bus and no acknowledgement or other responds are transmitted.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationPeripheral.monitor";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PROTOCOLS">
            <xsd:annotation>
               <xsd:documentation>Describes which protocols are supported by this hardware.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="protocol.CommunicationPeripheral";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="COMMUNICATION-PROTOCOL" type="AR:COMMUNICATION-PROTOCOL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REJECTION-FILTER" type="AR:COMMUNICATION-FILTER">
            <xsd:annotation>
               <xsd:documentation>If the Communication Peripheral supports filtering of frames here the amount and quality of filters is described.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="rejectionFilter.CommunicationPeripheral";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMESTAMP-AVAILABLE" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Is a timestamp for received frames available.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationPeripheral.timestampAvailable";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Peripherals::CommunicationPeripheral -->
   <xsd:complexType abstract="false" mixed="false" name="COMMUNICATION-PERIPHERAL">
      <xsd:annotation>
         <xsd:documentation>Peripheral representing communication devices.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationPeripheral"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HW-ELEMENT"/>
         <xsd:group ref="AR:PERIPHERAL"/>
         <xsd:group ref="AR:COMMUNICATION-PERIPHERAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="COMMUNICATION-PERIPHERAL--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="COMMUNICATION-PERIPHERAL"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Peripherals::CommunicationPhysicalMedium -->
   <xsd:group name="COMMUNICATION-PHYSICAL-MEDIUM">
      <xsd:annotation>
         <xsd:documentation>Describes the physical medium the bus is working on. In most cases it is not relevant for the SW to know about it, only for compatibility checking.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationPhysicalMedium"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="PHYSICAL-MEDIUM-DATA-LINES" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Specifies how many data lines (ground not included) are used for the physical layer. Some bus systems can be implemented with e.g. 1, 2 or 4 data lines.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationPhysicalMedium.physicalMediumDataLines";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PHYSICAL-MEDIUM-STANDARD" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>The element protocol name defines the exact standardised protocol name.
            Examples are:
            - ISO 11519 for low-speed CAN
            - IEEE 802.11g for W-LAN (54 Mbit/s at 2,5 GHz)
            - IEEE-1394a for Firewire-400</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationPhysicalMedium.physicalMediumStandard";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PHYSICAL-MEDIUM-TYPE" type="AR:COMMUNICATION-PHYSICAL-MEDIUM-ENUM">
            <xsd:annotation>
               <xsd:documentation>Describes the actual medium used for transmission.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationPhysicalMedium.physicalMediumType";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Peripherals::CommunicationPhysicalMedium -->
   <xsd:complexType abstract="false" mixed="false" name="COMMUNICATION-PHYSICAL-MEDIUM">
      <xsd:annotation>
         <xsd:documentation>Describes the physical medium the bus is working on. In most cases it is not relevant for the SW to know about it, only for compatibility checking.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationPhysicalMedium"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:COMMUNICATION-PHYSICAL-MEDIUM"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Peripherals::CommunicationProtocol -->
   <xsd:group name="COMMUNICATION-PROTOCOL">
      <xsd:annotation>
         <xsd:documentation>The name and version of the communication protocol.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationProtocol"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VERSIONS">
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element maxOccurs="unbounded" minOccurs="0" name="VERSION" type="xsd:string">
                     <xsd:annotation>
                        <xsd:documentation>This is the version number of the implementation of the protocol layer, e.g. 
                     - 2.0a, 2.0b  for CAN.
                     - 1.3, 2.0 for LIN.
                     - 2.0   for USB.</xsd:documentation>
                        <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationProtocol.version";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
                     </xsd:annotation>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Peripherals::CommunicationProtocol -->
   <xsd:complexType abstract="false" mixed="false" name="COMMUNICATION-PROTOCOL">
      <xsd:annotation>
         <xsd:documentation>The name and version of the communication protocol.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationProtocol"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COMMUNICATION-PROTOCOL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Peripherals::CommunicationSpeed -->
   <xsd:group name="COMMUNICATION-SPEED">
      <xsd:annotation>
         <xsd:documentation>Abstract element to describe communication speed. This can be either a fixed value, a range or a list of allowed communication speed.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationSpeed"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TOLERANCE" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>The element defines the tolerance allowed for the interface. (E.g. K-Line or LIN +/- 2 % at 9.6 Kbd)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationSpeed.tolerance";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class Peripherals::CommunicationSpeedFixed -->
   <xsd:group name="COMMUNICATION-SPEED-FIXED">
      <xsd:annotation>
         <xsd:documentation>Fixed value for the communication speed.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationSpeedFixed"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="FIX-SPEED" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Unit: bits per second</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationSpeedFixed.fixSpeed";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Peripherals::CommunicationSpeedFixed -->
   <xsd:complexType abstract="false" mixed="false" name="COMMUNICATION-SPEED-FIXED">
      <xsd:annotation>
         <xsd:documentation>Fixed value for the communication speed.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationSpeedFixed"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:COMMUNICATION-SPEED"/>
         <xsd:group ref="AR:COMMUNICATION-SPEED-FIXED"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Peripherals::CommunicationSpeedList -->
   <xsd:group name="COMMUNICATION-SPEED-LIST">
      <xsd:annotation>
         <xsd:documentation>List of possible communication speed.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationSpeedList"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SPEEDS">
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element maxOccurs="unbounded" minOccurs="0" name="SPEED" type="xsd:integer">
                     <xsd:annotation>
                        <xsd:documentation>Unit: bits per second</xsd:documentation>
                        <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationSpeedList.speed";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
                     </xsd:annotation>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Peripherals::CommunicationSpeedList -->
   <xsd:complexType abstract="false" mixed="false" name="COMMUNICATION-SPEED-LIST">
      <xsd:annotation>
         <xsd:documentation>List of possible communication speed.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationSpeedList"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:COMMUNICATION-SPEED"/>
         <xsd:group ref="AR:COMMUNICATION-SPEED-LIST"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Peripherals::CommunicationSpeedRange -->
   <xsd:group name="COMMUNICATION-SPEED-RANGE">
      <xsd:annotation>
         <xsd:documentation>Range of communication speed.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationSpeedRange"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-SPEED" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Unit: bits per second</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationSpeedRange.maxSpeed";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MIN-SPEED" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Unit: bits per second</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationSpeedRange.minSpeed";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Peripherals::CommunicationSpeedRange -->
   <xsd:complexType abstract="false" mixed="false" name="COMMUNICATION-SPEED-RANGE">
      <xsd:annotation>
         <xsd:documentation>Range of communication speed.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationSpeedRange"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:COMMUNICATION-SPEED"/>
         <xsd:group ref="AR:COMMUNICATION-SPEED-RANGE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ECUElectronics::CommunicationTransceiver -->
   <xsd:group name="COMMUNICATION-TRANSCEIVER">
      <xsd:annotation>
         <xsd:documentation>The Communication Transceiver has to transfer and receive the data through the physical link and is the implementation of the OSI layer 1. Communication Transceivers have additional links to the controller/PU to support wake-up feature, enabling/disabling and error indication.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationTransceiver"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ACCEPTANCE-FILTER" type="AR:COMMUNICATION-FILTER">
            <xsd:annotation>
               <xsd:documentation>Some transceivers have already acceptance filters implemented in hardware. This can be specified here.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="acceptanceFilter.CommunicationTransceiver";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ARCHITECTURE" type="AR:COMMUNICATION-ARCHITECTURE-ENUM">
            <xsd:annotation>
               <xsd:documentation>Distinguish between different implementations.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationTransceiver.architecture";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REJECTION-FILTER" type="AR:COMMUNICATION-FILTER">
            <xsd:annotation>
               <xsd:documentation>Some transceivers have already rejection filters implemented in hardware. This can be specified here.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="rejectionFilter.CommunicationTransceiver";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TERMINATION" type="AR:BUS-TERMINATION">
            <xsd:annotation>
               <xsd:documentation>Description how this network node is terminated.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="termination.CommunicationTransceiver";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUElectronics::CommunicationTransceiver -->
   <xsd:complexType abstract="false" mixed="false" name="COMMUNICATION-TRANSCEIVER">
      <xsd:annotation>
         <xsd:documentation>The Communication Transceiver has to transfer and receive the data through the physical link and is the implementation of the OSI layer 1. Communication Transceivers have additional links to the controller/PU to support wake-up feature, enabling/disabling and error indication.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CommunicationTransceiver"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HW-ELEMENT"/>
         <xsd:group ref="AR:ECU-ELECTRONICS"/>
         <xsd:group ref="AR:COMMUNICATION-TRANSCEIVER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- complex type for class AdminData::CompanyRevisionInfo -->
   <xsd:complexType abstract="false" mixed="false" name="COMPANY-REVISION-INFO">
      <xsd:annotation>
         <xsd:documentation>Use &lt;companyRevisionInfo&gt; , to generate information on document version within the respective company.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompanyRevisionInfo";xml.sequenceOffset="30"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- complex type for class AdminData::CompanySpecificInfo -->
   <xsd:complexType abstract="false" mixed="false" name="COMPANY-SPECIFIC-INFO">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompanySpecificInfo"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Implementation::Compiler -->
   <xsd:group name="COMPILER">
      <xsd:annotation>
         <xsd:documentation>Specifies the compiler attributes. In case of source code this specifies requirements how the compiler shall be invoked. In case of object code this documents the used compiler settings.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Compiler"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="NAME" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Compiler name (like gcc).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Compiler.name";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="OPTIONS" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Specifies the compiler options.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Compiler.options";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VENDOR" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Vendor of compiler.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Compiler.vendor";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VERSION" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Exact version of compiler executable.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Compiler.version";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Implementation::Compiler -->
   <xsd:complexType abstract="false" mixed="false" name="COMPILER">
      <xsd:annotation>
         <xsd:documentation>Specifies the compiler attributes. In case of source code this specifies requirements how the compiler shall be invoked. In case of object code this documents the used compiler settings.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Compiler"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COMPILER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Components::ComplexDeviceDriverComponentType -->
   <xsd:group name="COMPLEX-DEVICE-DRIVER-COMPONENT-TYPE">
      <xsd:annotation>
         <xsd:documentation>The ComplexDeviceDriver Component is a special AtomicSoftwareComponent that has direct access to hardware on an ECUand which is therefore linked to a specific ECU or specific hardware. The ComplexDeviceDriver ComponentType introduces the possibility to link from the software representation to its hardware description provided by the ECU Resource Template.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ComplexDeviceDriverComponentType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpType</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BSW-MODULE-DESCRIPTION-REFS">
            <xsd:annotation>
               <xsd:documentation>Reference from the ComplexDeviceDriverComponentType to the Basic Software Module Description describing the BSW part of the Complex Device Driver Component.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ComplexDeviceDriverComponentType.bswModuleDescription";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="BSW-MODULE-DESCRIPTION-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:BSW-MODULE-DESCRIPTION--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="HARDWARE-ELEMENT-REFS">
            <xsd:annotation>
               <xsd:documentation>Reference from the ComplexDeviceDriverComponentType to the description of the used HWElements.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ComplexDeviceDriverComponentType.hardwareElement";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="HARDWARE-ELEMENT-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:HW-ELEMENT--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Components::ComplexDeviceDriverComponentType -->
   <xsd:complexType abstract="false" mixed="false" name="COMPLEX-DEVICE-DRIVER-COMPONENT-TYPE">
      <xsd:annotation>
         <xsd:documentation>The ComplexDeviceDriver Component is a special AtomicSoftwareComponent that has direct access to hardware on an ECUand which is therefore linked to a specific ECU or specific hardware. The ComplexDeviceDriver ComponentType introduces the possibility to link from the software representation to its hardware description provided by the ECU Resource Template.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ComplexDeviceDriverComponentType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpType</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COMPONENT-TYPE"/>
         <xsd:group ref="AR:COMPLEX-DEVICE-DRIVER-COMPONENT-TYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class SWmapping::ComponentClustering -->
   <xsd:group name="COMPONENT-CLUSTERING">
      <xsd:annotation>
         <xsd:documentation>Constraint that forces the mapping of all referenced SW component instances to the same ECU</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ComponentClustering"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CLUSTERED-COMPONENT-IREFS">
            <xsd:annotation>
               <xsd:documentation>Reference to the components that have to be mapped together.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="clusteredComponent.ComponentClustering";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CLUSTERED-COMPONENT-IREF" type="AR:COMPONENT-CLUSTERING--CLUSTERED-COMPONENT-IREF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SWmapping::ComponentClustering -->
   <xsd:complexType abstract="false" mixed="false" name="COMPONENT-CLUSTERING">
      <xsd:annotation>
         <xsd:documentation>Constraint that forces the mapping of all referenced SW component instances to the same ECU</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ComponentClustering"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:COMPONENT-CLUSTERING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class _instanceRef::ComponentClustering_clusteredComponent -->
   <xsd:group name="COMPONENT-CLUSTERING--CLUSTERED-COMPONENT-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ComponentClustering_clusteredComponent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SOFTWARE-COMPOSITION-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ComponentClustering_clusteredComponent.softwareComposition";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="10"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SOFTWARE-COMPOSITION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="COMPONENT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ComponentClustering_clusteredComponent.componentPrototype";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMPONENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="1" name="CLUSTERED-COMPONENT-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ComponentClustering_clusteredComponent.clusteredComponent";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.target</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMPONENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class _instanceRef::ComponentClustering_clusteredComponent -->
   <xsd:complexType abstract="false" mixed="false" name="COMPONENT-CLUSTERING--CLUSTERED-COMPONENT-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ComponentClustering_clusteredComponent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:COMPONENT-CLUSTERING--CLUSTERED-COMPONENT-IREF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Composition::ComponentPrototype -->
   <xsd:group name="COMPONENT-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>Role of a software component within a composition.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ComponentPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TYPE-TREF">
            <xsd:annotation>
               <xsd:documentation>Type of the instance.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ComponentPrototype.type";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">isOfType</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMPONENT-TYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Composition::ComponentPrototype -->
   <xsd:complexType abstract="false" mixed="false" name="COMPONENT-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>Role of a software component within a composition.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ComponentPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COMPONENT-PROTOTYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="COMPONENT-PROTOTYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="COMPONENT-PROTOTYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class SWmapping::ComponentSeparation -->
   <xsd:group name="COMPONENT-SEPARATION">
      <xsd:annotation>
         <xsd:documentation>Constraint that forces the two referenced SW components (called A and B in the following) not to be mapped to the same ECU. If a SW component (e.g. A) is a composition, none of the atomic SW components making up the A composition must be mapped together with any of the atomic SW components making up the B composition. Furthermore, A and B must be disjoint.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ComponentSeparation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SEPARATED-COMPONENT-IREFS">
            <xsd:annotation>
               <xsd:documentation>The two components that have to be mapped to different ECUs</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="separatedComponent.ComponentSeparation";pureMM.maxOccurs="2";pureMM.minOccurs="2"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="2" minOccurs="0">
                  <xsd:element name="SEPARATED-COMPONENT-IREF" type="AR:COMPONENT-SEPARATION--SEPARATED-COMPONENT-IREF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SWmapping::ComponentSeparation -->
   <xsd:complexType abstract="false" mixed="false" name="COMPONENT-SEPARATION">
      <xsd:annotation>
         <xsd:documentation>Constraint that forces the two referenced SW components (called A and B in the following) not to be mapped to the same ECU. If a SW component (e.g. A) is a composition, none of the atomic SW components making up the A composition must be mapped together with any of the atomic SW components making up the B composition. Furthermore, A and B must be disjoint.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ComponentSeparation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:COMPONENT-SEPARATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class _instanceRef::ComponentSeparation_separatedComponent -->
   <xsd:group name="COMPONENT-SEPARATION--SEPARATED-COMPONENT-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ComponentSeparation_separatedComponent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SOFTWARE-COMPOSITION-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ComponentSeparation_separatedComponent.softwareComposition";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="10"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SOFTWARE-COMPOSITION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="COMPONENT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ComponentSeparation_separatedComponent.componentPrototype";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMPONENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="1" name="SEPARATED-COMPONENT-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ComponentSeparation_separatedComponent.separatedComponent";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.target</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMPONENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class _instanceRef::ComponentSeparation_separatedComponent -->
   <xsd:complexType abstract="false" mixed="false" name="COMPONENT-SEPARATION--SEPARATED-COMPONENT-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ComponentSeparation_separatedComponent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:COMPONENT-SEPARATION--SEPARATED-COMPONENT-IREF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Components::ComponentType -->
   <xsd:group name="COMPONENT-TYPE">
      <xsd:annotation>
         <xsd:documentation>Base class for AUTOSAR software components.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ComponentType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpType</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="PORTS">
            <xsd:annotation>
               <xsd:documentation>The ports through which this component can communicate.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="port.component";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="P-PORT-PROTOTYPE" type="AR:P-PORT-PROTOTYPE"/>
                  <xsd:element name="R-PORT-PROTOTYPE" type="AR:R-PORT-PROTOTYPE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PORT-GROUPS">
            <xsd:annotation>
               <xsd:documentation>A portGroup being part of this component.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ComponentType.portGroup";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="PORT-GROUP" type="AR:PORT-GROUP"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <xsd:simpleType name="COMPONENT-TYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="APPLICATION-SOFTWARE-COMPONENT-TYPE"/>
         <xsd:enumeration value="CALPRM-COMPONENT-TYPE"/>
         <xsd:enumeration value="COMPLEX-DEVICE-DRIVER-COMPONENT-TYPE"/>
         <xsd:enumeration value="COMPOSITION-TYPE"/>
         <xsd:enumeration value="ECU-ABSTRACTION-COMPONENT-TYPE"/>
         <xsd:enumeration value="SENSOR-ACTUATOR-SOFTWARE-COMPONENT-TYPE"/>
         <xsd:enumeration value="SERVICE-COMPONENT-TYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Composition::CompositionType -->
   <xsd:group name="COMPOSITION-TYPE">
      <xsd:annotation>
         <xsd:documentation>A CompositionType aggregates ComponentPrototypes (that in turn are typed by ComponentTypes) as well as ConnectorPrototypes for primarily connecting ComponentPrototypes among each others and towards the surface of the CompositionType. By this means hierarchical structures of software-components can be created.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompositionType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpType</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPONENTS">
            <xsd:annotation>
               <xsd:documentation>The instantiated components that are part of this composition.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="component.CompositionType";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="COMPONENT-PROTOTYPE" type="AR:COMPONENT-PROTOTYPE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONNECTORS">
            <xsd:annotation>
               <xsd:documentation>ConnectorPrototypes have the principal ability to establish a connection among PortPrototypes. They can have many roles in the context of a CompositionType. Details are refined by subclasses.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="connector.composition";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ASSEMBLY-CONNECTOR-PROTOTYPE" type="AR:ASSEMBLY-CONNECTOR-PROTOTYPE"/>
                  <xsd:element name="DELEGATION-CONNECTOR-PROTOTYPE" type="AR:DELEGATION-CONNECTOR-PROTOTYPE"/>
                  <xsd:element name="SERVICE-CONNECTOR-PROTOTYPE" type="AR:SERVICE-CONNECTOR-PROTOTYPE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Composition::CompositionType -->
   <xsd:complexType abstract="false" mixed="false" name="COMPOSITION-TYPE">
      <xsd:annotation>
         <xsd:documentation>A CompositionType aggregates ComponentPrototypes (that in turn are typed by ComponentTypes) as well as ConnectorPrototypes for primarily connecting ComponentPrototypes among each others and towards the surface of the CompositionType. By this means hierarchical structures of software-components can be created.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompositionType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpType</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COMPONENT-TYPE"/>
         <xsd:group ref="AR:COMPOSITION-TYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="COMPOSITION-TYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="COMPOSITION-TYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ComputationMethod::Compu -->
   <xsd:group name="COMPU">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Compu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:choice maxOccurs="1" minOccurs="0">
            <xsd:group ref="AR:COMPU-PROG-CODE"/>
            <xsd:group ref="AR:COMPU-SCALES"/>
         </xsd:choice>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPU-DEFAULT-VALUE" type="AR:COMPU-CONST">
            <xsd:annotation>
               <xsd:documentation>This property can be used to specify an output value for a conversion formula, if the value to be converted lies outside the plausibility limit. Although this is possible for all conversion formulae, it is especially valid for variables with tabular conversion formulae.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Compu.compuDefaultValue";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="70"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ComputationMethod::Compu -->
   <xsd:complexType abstract="false" mixed="false" name="COMPU">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Compu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:COMPU"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ComputationMethod::CompuConst -->
   <xsd:group name="COMPU-CONST">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuConst"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:choice maxOccurs="1" minOccurs="0">
            <xsd:group ref="AR:COMPU-CONST-FORMULA-CONTENT"/>
            <xsd:group ref="AR:COMPU-CONST-NUMERIC-CONTENT"/>
            <xsd:group ref="AR:COMPU-CONST-TEXT-CONTENT"/>
         </xsd:choice>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ComputationMethod::CompuConst -->
   <xsd:complexType abstract="false" mixed="false" name="COMPU-CONST">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuConst"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:COMPU-CONST"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ComputationMethod::CompuConstFormulaContent -->
   <xsd:group name="COMPU-CONST-FORMULA-CONTENT">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuConstFormulaContent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VF" type="AR:VF">
            <xsd:annotation>
               <xsd:documentation>Value calculated via a system constant. This element is included in every case, where parameters should be generated from numerical values during compile time (not runtime!). Thus for example, the influence of the cylinder number on conversion formulae, can be introduced in a repeatable manner.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CompuConstFormulaContent.vf";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ComputationMethod::CompuConstFormulaContent -->
   <xsd:complexType abstract="false" mixed="false" name="COMPU-CONST-FORMULA-CONTENT">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuConstFormulaContent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:COMPU-CONST-FORMULA-CONTENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ComputationMethod::CompuConstNumericContent -->
   <xsd:group name="COMPU-CONST-NUMERIC-CONTENT">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuConstNumericContent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="V" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Use &lt;v&gt; to enter a numerical value.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CompuConstNumericContent.v";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ComputationMethod::CompuConstNumericContent -->
   <xsd:complexType abstract="false" mixed="false" name="COMPU-CONST-NUMERIC-CONTENT">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuConstNumericContent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:COMPU-CONST-NUMERIC-CONTENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ComputationMethod::CompuConstTextContent -->
   <xsd:group name="COMPU-CONST-TEXT-CONTENT">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuConstTextContent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VT" type="AR:VT">
            <xsd:annotation>
               <xsd:documentation>&lt;vt&gt; represents one particular textual value of the calibration item.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CompuConstTextContent.vt";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="70"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ComputationMethod::CompuConstTextContent -->
   <xsd:complexType abstract="false" mixed="false" name="COMPU-CONST-TEXT-CONTENT">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuConstTextContent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:COMPU-CONST-TEXT-CONTENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- attribute group for class ComputationMethod::CompuGenericMath -->
   <xsd:attributeGroup name="COMPU-GENERIC-MATH">
      <xsd:annotation>
         <xsd:documentation>This class represents a calculation formula as a simple arithmetical expression.

      string f(x): function to calculate the physical value from the binary, control unit internal value. The interpretation proceeds from left to right for operations of the same operation preferences. Operator preferences, such as power before product/quotient before sum/difference before shift left before shift right before logical AND before logical OR are taken into account. Brackets are allowed and should be used in order to exclude interpretation doubt. 

      For more details refer to ASAM Harmonized Data Objects v1.1 Chapter 9.3.11.

      Note that this element is a mixed string since a future variant mechanism  might use placeholdes to represent references to other objects of the metamodel.

      As of August 2007 within ASAM there are slightly different syntaxes. One from ASAM-HDO (GenericMath) and the one from SwDataDependency: The difference is mainly between available functions and operators. Nevertheless we use the same class for now.

      numeric_expression ::= ( "-"expression ) | ( expression ( "+" | "-" | "*" | "/" | "^") expression )
                      expression ::= ( number | variable | numeric_expression | ( "(" expression ")" ) | sinus_statement | cosinus_statement | sqrt_statement ) | expression {white-space}
                      sinus_statement ::= "sin" "(" expression ")"
                      cosinus_statement ::= "cos" "(" expression ")"
                      sqrt_statement ::= "sqrt" "(" expression ")"
                      number ::= integer_literal | float_literal
                      variable ::= Any valid Object in question
                      integer_literal ::= ( "1..9" { "0..9" } ) | ( "0" "x" "0..9a..f" { "0..9a..f" } )
                      float_literal ::= ( decimal_digits "."  decimal_digits   exponent_part  ) | ( "." decimal_digits  exponent_part  ) | ( decimal_digits  exponent_part  )
                      decimal_digits ::= "0..9" { "0..9" }
                      exponent_part ::= "e"  "+" | "-"  decimal_digits
                      white-space ::= tabulator | blank | newline | carriage_return | {tabulator | blank | newline | carriage_return }
                      tabulator ::= \t
                      blank ::= " "
                      newline ::= \n
                      carriage_return ::= \c</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuGenericMath"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="LEVEL" type="AR:IDENTIFIER">
         <xsd:annotation>
            <xsd:documentation>Placeholder to describe an indicator of a language level for the mathematics e.g. INFORMAL, ASAMHDO.
         May be refined by particular usecases.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="CompuGenericMath.level";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class ComputationMethod::CompuGenericMath -->
   <xsd:complexType abstract="false" mixed="true" name="COMPU-GENERIC-MATH">
      <xsd:annotation>
         <xsd:documentation>This class represents a calculation formula as a simple arithmetical expression.

      string f(x): function to calculate the physical value from the binary, control unit internal value. The interpretation proceeds from left to right for operations of the same operation preferences. Operator preferences, such as power before product/quotient before sum/difference before shift left before shift right before logical AND before logical OR are taken into account. Brackets are allowed and should be used in order to exclude interpretation doubt. 

      For more details refer to ASAM Harmonized Data Objects v1.1 Chapter 9.3.11.

      Note that this element is a mixed string since a future variant mechanism  might use placeholdes to represent references to other objects of the metamodel.

      As of August 2007 within ASAM there are slightly different syntaxes. One from ASAM-HDO (GenericMath) and the one from SwDataDependency: The difference is mainly between available functions and operators. Nevertheless we use the same class for now.

      numeric_expression ::= ( "-"expression ) | ( expression ( "+" | "-" | "*" | "/" | "^") expression )
                      expression ::= ( number | variable | numeric_expression | ( "(" expression ")" ) | sinus_statement | cosinus_statement | sqrt_statement ) | expression {white-space}
                      sinus_statement ::= "sin" "(" expression ")"
                      cosinus_statement ::= "cos" "(" expression ")"
                      sqrt_statement ::= "sqrt" "(" expression ")"
                      number ::= integer_literal | float_literal
                      variable ::= Any valid Object in question
                      integer_literal ::= ( "1..9" { "0..9" } ) | ( "0" "x" "0..9a..f" { "0..9a..f" } )
                      float_literal ::= ( decimal_digits "."  decimal_digits   exponent_part  ) | ( "." decimal_digits  exponent_part  ) | ( decimal_digits  exponent_part  )
                      decimal_digits ::= "0..9" { "0..9" }
                      exponent_part ::= "e"  "+" | "-"  decimal_digits
                      white-space ::= tabulator | blank | newline | carriage_return | {tabulator | blank | newline | carriage_return }
                      tabulator ::= \t
                      blank ::= " "
                      newline ::= \n
                      carriage_return ::= \c</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuGenericMath"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0"/>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:COMPU-GENERIC-MATH"/>
   </xsd:complexType>
   <!-- element group for class ComputationMethod::CompuMethod -->
   <xsd:group name="COMPU-METHOD">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuMethod"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DISPLAY-FORMAT" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>This property specifies, how the physical value shall be displayed e.g. in documents or measurement and calibration tools.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CompuMethod.displayFormat";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="UNIT-REF">
            <xsd:annotation>
               <xsd:documentation>This is the physical unit of the Physical values for which the CompuMethod applies.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CompuMethod.unit";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:UNIT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPU-INTERNAL-TO-PHYS" type="AR:COMPU">
            <xsd:annotation>
               <xsd:documentation>This speifies the computation from internal values to physical values.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CompuMethod.compuInternalToPhys";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="80"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPU-PHYS-TO-INTERNAL" type="AR:COMPU">
            <xsd:annotation>
               <xsd:documentation>This represents the computation from physical values to the internal values.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CompuMethod.compuPhysToInternal";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="90"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ComputationMethod::CompuMethod -->
   <xsd:complexType abstract="false" mixed="false" name="COMPU-METHOD">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuMethod"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COMPU-METHOD"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="COMPU-METHOD--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="COMPU-METHOD"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ComputationMethod::CompuNominatorDenominator -->
   <xsd:group name="COMPU-NOMINATOR-DENOMINATOR">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuNominatorDenominator"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixed,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice>
         <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element maxOccurs="unbounded" minOccurs="0" name="VF" type="AR:VF">
               <xsd:annotation>
                  <xsd:documentation>Value calculated via a system constant. This element is included in every case, where parameters should be generated from numerical values during compile time (not runtime!). Thus for example, the influence of the cylinder number on conversion formulae, can be introduced in a repeatable manner.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="CompuNominatorDenominator.vf";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element maxOccurs="unbounded" minOccurs="0" name="V" type="xsd:string">
               <xsd:annotation>
                  <xsd:documentation>Use &lt;v&gt; to enter a numerical value.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="CompuNominatorDenominator.v";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
         </xsd:choice>
      </xsd:choice>
   </xsd:group>
   <!-- complex type for class ComputationMethod::CompuNominatorDenominator -->
   <xsd:complexType abstract="false" mixed="false" name="COMPU-NOMINATOR-DENOMINATOR">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuNominatorDenominator"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixed,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:COMPU-NOMINATOR-DENOMINATOR"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ComputationMethod::CompuProgCode -->
   <xsd:group name="COMPU-PROG-CODE">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuProgCode"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="PROG-CODE" type="AR:PROG-CODE">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CompuProgCode.progCode";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="60"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ComputationMethod::CompuProgCode -->
   <xsd:complexType abstract="false" mixed="false" name="COMPU-PROG-CODE">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuProgCode"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:COMPU-PROG-CODE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ComputationMethod::CompuRationalCoeffs -->
   <xsd:group name="COMPU-RATIONAL-COEFFS">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuRationalCoeffs"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPU-NUMERATOR" type="AR:COMPU-NOMINATOR-DENOMINATOR">
            <xsd:annotation>
               <xsd:documentation>This is the enumerator of the rational expression.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CompuRationalCoeffs.compuNumerator";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPU-DENOMINATOR" type="AR:COMPU-NOMINATOR-DENOMINATOR">
            <xsd:annotation>
               <xsd:documentation>This is the denominator of the expression.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CompuRationalCoeffs.compuDenominator";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ComputationMethod::CompuRationalCoeffs -->
   <xsd:complexType abstract="false" mixed="false" name="COMPU-RATIONAL-COEFFS">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuRationalCoeffs"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:COMPU-RATIONAL-COEFFS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ComputationMethod::CompuScale -->
   <xsd:group name="COMPU-SCALE">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuScale"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SHORT-LABEL" type="AR:IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>This element specifies a short name for the particular scale. The name can for example be used to derive a programming language identifier.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CompuScale.shortLabel";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYMBOL" type="AR:IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>The symbol, if provided, is used by code generators to get a C identifier for the CompuScale. The name will be used as is for the code generation, therefore it needs to be unique within the generation context.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CompuScale.symbol";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="25"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DESC" type="AR:ML-DATA-2">
            <xsd:annotation>
               <xsd:documentation>&lt;desc&gt; represents a general but brief description of the object in question.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CompuScale.desc";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="LOWER-LIMIT" type="AR:LIMIT">
            <xsd:annotation>
               <xsd:documentation>This element specifies the lower limit of a closed, half-open or open interval. It can also be set to infinity by setting the attribute INTERVAL-TYPE to INFINITE. No value has to be set in the case of an infinite interval.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CompuScale.lowerLimit";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="UPPER-LIMIT" type="AR:LIMIT">
            <xsd:annotation>
               <xsd:documentation>This element specifies the upper limit of a closed, half-open or open interval. It can also be set to infinity by setting the attribute INTERVAL-TYPE to INFINITE. No value has to be set in the case of an infinite interval.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CompuScale.upperLimit";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:choice maxOccurs="1" minOccurs="0">
            <xsd:group ref="AR:COMPU-SCALE-CONSTANT-CONTENTS"/>
            <xsd:group ref="AR:COMPU-SCALE-RATIONAL-FORMULA"/>
         </xsd:choice>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ComputationMethod::CompuScale -->
   <xsd:complexType abstract="false" mixed="false" name="COMPU-SCALE">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuScale"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:COMPU-SCALE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ComputationMethod::CompuScaleConstantContents -->
   <xsd:group name="COMPU-SCALE-CONSTANT-CONTENTS">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuScaleConstantContents"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPU-CONST" type="AR:COMPU-CONST">
            <xsd:annotation>
               <xsd:documentation>This represnts the fact that the scale is a constant. The use case is mainly a non interplolated scale. It is a simplification of the fact that a constant scale can also be expressed as Rational Function of oder 0.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CompuScaleConstantContents.compuConst";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="90"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ComputationMethod::CompuScaleConstantContents -->
   <xsd:complexType abstract="false" mixed="false" name="COMPU-SCALE-CONSTANT-CONTENTS">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuScaleConstantContents"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:COMPU-SCALE-CONSTANT-CONTENTS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- complex type for class ComputationMethod::CompuScaleGenericMath -->
   <xsd:complexType abstract="false" mixed="false" name="COMPU-SCALE-GENERIC-MATH">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuScaleGenericMath"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ComputationMethod::CompuScaleRationalFormula -->
   <xsd:group name="COMPU-SCALE-RATIONAL-FORMULA">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuScaleRationalFormula"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPU-RATIONAL-COEFFS" type="AR:COMPU-RATIONAL-COEFFS">
            <xsd:annotation>
               <xsd:documentation>This specifies the coefficients of the rational fomula.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CompuScaleRationalFormula.compuRationalCoeffs";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="110"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ComputationMethod::CompuScaleRationalFormula -->
   <xsd:complexType abstract="false" mixed="false" name="COMPU-SCALE-RATIONAL-FORMULA">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuScaleRationalFormula"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:COMPU-SCALE-RATIONAL-FORMULA"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ComputationMethod::CompuScales -->
   <xsd:group name="COMPU-SCALES">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuScales"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPU-SCALES">
            <xsd:annotation>
               <xsd:documentation>This represents one scale within the compu method.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CompuScales.compuScale";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="true";xml.roleWrapperElement="true";xml.sequenceOffset="40";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="COMPU-SCALE" type="AR:COMPU-SCALE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ComputationMethod::CompuScales -->
   <xsd:complexType abstract="false" mixed="false" name="COMPU-SCALES">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CompuScales"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:COMPU-SCALES"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ECUCParameterDefTemplate::ConfigParameter -->
   <xsd:group name="CONFIG-PARAMETER">
      <xsd:annotation>
         <xsd:documentation>Abstract class used to define the similarities of all ECU Configuration Parameter types defined as subclasses.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ConfigParameter"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYMBOLIC-NAME-VALUE" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Specifies that this parameter's value is used, together with the aggregating container, to derive a symbolic name definition. E.g.: #define "container_shortName" "this parameter's value".</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ConfigParameter.symbolicNameValue";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <xsd:simpleType name="CONFIG-PARAMETER--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="BOOLEAN-PARAM-DEF"/>
         <xsd:enumeration value="DERIVED-BOOLEAN-PARAM-DEF"/>
         <xsd:enumeration value="DERIVED-ENUMERATION-PARAM-DEF"/>
         <xsd:enumeration value="DERIVED-FLOAT-PARAM-DEF"/>
         <xsd:enumeration value="DERIVED-INTEGER-PARAM-DEF"/>
         <xsd:enumeration value="DERIVED-STRING-PARAM-DEF"/>
         <xsd:enumeration value="ENUMERATION-PARAM-DEF"/>
         <xsd:enumeration value="FLOAT-PARAM-DEF"/>
         <xsd:enumeration value="FUNCTION-NAME-DEF"/>
         <xsd:enumeration value="INTEGER-PARAM-DEF"/>
         <xsd:enumeration value="LINKER-SYMBOL-DEF"/>
         <xsd:enumeration value="STRING-PARAM-DEF"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="CONFIG-REFERENCE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CHOICE-REFERENCE-PARAM-DEF"/>
         <xsd:enumeration value="FOREIGN-REFERENCE-PARAM-DEF"/>
         <xsd:enumeration value="INSTANCE-REFERENCE-PARAM-DEF"/>
         <xsd:enumeration value="REFERENCE-PARAM-DEF"/>
         <xsd:enumeration value="SYMBOLIC-NAME-REFERENCE-PARAM-DEF"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ECUCDescriptionTemplate::ConfigReferenceValue -->
   <xsd:group name="CONFIG-REFERENCE-VALUE">
      <xsd:annotation>
         <xsd:documentation>Abstract class to be used as common parent for all reference values in the ECU Configuration Description.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ConfigReferenceValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DEFINITION-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the definition of this ConfigReferenceValue subclasses in the ECU Configuration Parameter Definition.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ConfigReferenceValue.definition";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="-10"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:CONFIG-REFERENCE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class ECUCParameterDefTemplate::ConfigurationClassAffection -->
   <xsd:group name="CONFIGURATION-CLASS-AFFECTION">
      <xsd:annotation>
         <xsd:documentation>Specifies in the "VendorSpecificModuleDefinition" whether changes on this parameter do affect other parameters in a later configuration step. This element is deprecated and will be removed in future versions.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ConfigurationClassAffection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="AFFECTED-REFS">
            <xsd:annotation>
               <xsd:documentation>Optional reference to parameters or references which are affected by the ConfigurationClassAffection.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ConfigurationClassAffection.affected";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="AFFECTED-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:COMMON-CONFIGURATION-ATTRIBUTES--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="AFFECTION-KIND" type="AR:CONFIGURATION-AFFECTION">
            <xsd:annotation>
               <xsd:documentation>Specifies which affect do changes in this parameter have on other parameters. This attribute is deprecated and will be removed in future versions.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ConfigurationClassAffection.affectionKind";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::ConfigurationClassAffection -->
   <xsd:complexType abstract="false" mixed="false" name="CONFIGURATION-CLASS-AFFECTION">
      <xsd:annotation>
         <xsd:documentation>Specifies in the "VendorSpecificModuleDefinition" whether changes on this parameter do affect other parameters in a later configuration step. This element is deprecated and will be removed in future versions.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ConfigurationClassAffection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:CONFIGURATION-CLASS-AFFECTION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Constants::ConstantReference -->
   <xsd:group name="CONSTANT-REFERENCE">
      <xsd:annotation>
         <xsd:documentation>Instead of defining this constant inline, another constant is referenced.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ConstantReference"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONSTANT-REF">
            <xsd:annotation>
               <xsd:documentation>The referenced constant.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ConstantReference.constant";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:CONSTANT-SPECIFICATION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Constants::ConstantReference -->
   <xsd:complexType abstract="false" mixed="false" name="CONSTANT-REFERENCE">
      <xsd:annotation>
         <xsd:documentation>Instead of defining this constant inline, another constant is referenced.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ConstantReference"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:DATA-PROTOTYPE"/>
         <xsd:group ref="AR:CONSTANT-REFERENCE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Constants::ConstantSpecification -->
   <xsd:group name="CONSTANT-SPECIFICATION">
      <xsd:annotation>
         <xsd:documentation>Specification of a constant that can be part of a package, i.e. it can be defined stand-alone.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ConstantSpecification"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VALUE">
            <xsd:annotation>
               <xsd:documentation>Specification of an expression leading to a value of a given datatype.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="value.ConstantSpecification";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="ARRAY-SPECIFICATION" type="AR:ARRAY-SPECIFICATION"/>
                  <xsd:element name="BOOLEAN-LITERAL" type="AR:BOOLEAN-LITERAL"/>
                  <xsd:element name="CHAR-LITERAL" type="AR:CHAR-LITERAL"/>
                  <xsd:element name="CONSTANT-REFERENCE" type="AR:CONSTANT-REFERENCE"/>
                  <xsd:element name="INTEGER-LITERAL" type="AR:INTEGER-LITERAL"/>
                  <xsd:element name="OPAQUE-LITERAL" type="AR:OPAQUE-LITERAL"/>
                  <xsd:element name="REAL-LITERAL" type="AR:REAL-LITERAL"/>
                  <xsd:element name="RECORD-SPECIFICATION" type="AR:RECORD-SPECIFICATION"/>
                  <xsd:element name="STRING-LITERAL" type="AR:STRING-LITERAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Constants::ConstantSpecification -->
   <xsd:complexType abstract="false" mixed="false" name="CONSTANT-SPECIFICATION">
      <xsd:annotation>
         <xsd:documentation>Specification of a constant that can be part of a package, i.e. it can be defined stand-alone.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ConstantSpecification"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:CONSTANT-SPECIFICATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="CONSTANT-SPECIFICATION--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CONSTANT-SPECIFICATION"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ECUCDescriptionTemplate::Container -->
   <xsd:group name="CONTAINER">
      <xsd:annotation>
         <xsd:documentation>Represents a Container definition in the ECU Configuration Description.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Container"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DEFINITION-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the definition of this Container in the ECU Configuration Parameter Definition.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Container.definition";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="-10"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:CONTAINER-DEF--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PARAMETER-VALUES">
            <xsd:annotation>
               <xsd:documentation>Aggregates all ECU Configuration Values within this Container.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="parameterValue.Container";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="BOOLEAN-VALUE" type="AR:BOOLEAN-VALUE"/>
                  <xsd:element name="ENUMERATION-VALUE" type="AR:ENUMERATION-VALUE"/>
                  <xsd:element name="FLOAT-VALUE" type="AR:FLOAT-VALUE"/>
                  <xsd:element name="FUNCTION-NAME-VALUE" type="AR:FUNCTION-NAME-VALUE"/>
                  <xsd:element name="INTEGER-VALUE" type="AR:INTEGER-VALUE"/>
                  <xsd:element name="LINKER-SYMBOL-VALUE" type="AR:LINKER-SYMBOL-VALUE"/>
                  <xsd:element name="STRING-VALUE" type="AR:STRING-VALUE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REFERENCE-VALUES">
            <xsd:annotation>
               <xsd:documentation>Aggregates all References with this container.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="referenceValue.Container";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="INSTANCE-REFERENCE-VALUE" type="AR:INSTANCE-REFERENCE-VALUE"/>
                  <xsd:element name="REFERENCE-VALUE" type="AR:REFERENCE-VALUE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SUB-CONTAINERS">
            <xsd:annotation>
               <xsd:documentation>Aggregates all sub-containers within this container.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="subContainer.Container";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CONTAINER" type="AR:CONTAINER"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCDescriptionTemplate::Container -->
   <xsd:complexType abstract="false" mixed="false" name="CONTAINER">
      <xsd:annotation>
         <xsd:documentation>Represents a Container definition in the ECU Configuration Description.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Container"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:CONTAINER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUCParameterDefTemplate::ContainerDef -->
   <xsd:group name="CONTAINER-DEF">
      <xsd:annotation>
         <xsd:documentation>Base class used to gather common attributes of configuration container definitions.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ContainerDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="POST-BUILD-CHANGEABLE" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Specifies if the number of instances of this container may be changed post-build time. This parameter may only be set to true if all of the following conditions hold:
            - the container's upperMultiplicity &gt; lowerMultiplicity
            - all parameters within the container and subContainers are post-build time changeable.
            If any of the aggregated parameters is either pre-compile time or link time this attribute is ignored and may be omitted.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ContainerDef.postBuildChangeable";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <xsd:simpleType name="CONTAINER-DEF--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CHOICE-CONTAINER-DEF"/>
         <xsd:enumeration value="PARAM-CONF-CONTAINER-DEF"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Fibex4Flexray::CycleCounter -->
   <xsd:group name="CYCLE-COUNTER">
      <xsd:annotation>
         <xsd:documentation>The communication cycle where the frame is send is described by the attribute "cycleCounter".</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CycleCounter"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CYCLE-COUNTER" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The communication cycle where the frame described by this timing is sent. If a timing is given in this way the referencing cluster must specify the NUMBER-OF-CYCLES as upper bound and point of total repetition. 

            This value is incremented at the beginning of each new cycle, ranging from 0 to
            63, and is reset to 0 after a sequence of 64 cycles.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CycleCounter.CycleCounter";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Fibex4Flexray::CycleCounter -->
   <xsd:complexType abstract="false" mixed="false" name="CYCLE-COUNTER">
      <xsd:annotation>
         <xsd:documentation>The communication cycle where the frame is send is described by the attribute "cycleCounter".</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CycleCounter"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:CYCLE-COUNTER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Fibex4Flexray::CycleRepetition -->
   <xsd:group name="CYCLE-REPETITION">
      <xsd:annotation>
         <xsd:documentation>The communication cycle where the frame is send is described by the
      attributes baseCycle and cycleRepetition.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CycleRepetition"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BASE-CYCLE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The first communication cycle where the frame is sent.

            This value is incremented at the beginning of each new cycle, ranging from 0 to
            63, and is reset to 0 after a sequence of 64 cycles.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CycleRepetition.BaseCycle";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CYCLE-REPETITION" type="AR:CYCLE-REPETITION-TYPE">
            <xsd:annotation>
               <xsd:documentation>The number of communication cycles (after the first cycle) whenever the frame described by this timing is sent again.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CycleRepetition.CycleRepetition";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Fibex4Flexray::CycleRepetition -->
   <xsd:complexType abstract="false" mixed="false" name="CYCLE-REPETITION">
      <xsd:annotation>
         <xsd:documentation>The communication cycle where the frame is send is described by the
      attributes baseCycle and cycleRepetition.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CycleRepetition"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:CYCLE-REPETITION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Timing::CyclicTiming -->
   <xsd:group name="CYCLIC-TIMING">
      <xsd:annotation>
         <xsd:documentation>Specification of a cyclic sending behavior.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CyclicTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="FINAL-REPETITIONS" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Number of repetitions the pdu is sent from the moment the stop condition has been met</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="CyclicTiming.finalRepetitions";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REPEATING-TIME" type="AR:TIME-RANGE-TYPE">
            <xsd:annotation>
               <xsd:documentation>Specification of the repeating cycle.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="repeatingTime.CyclicTiming";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="STARTING-TIME" type="AR:TIME-RANGE-TYPE">
            <xsd:annotation>
               <xsd:documentation>Specification of the time that is needed before the pdu can be sent the first time.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="startingTime.CyclicTiming";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Timing::CyclicTiming -->
   <xsd:complexType abstract="false" mixed="false" name="CYCLIC-TIMING">
      <xsd:annotation>
         <xsd:documentation>Specification of a cyclic sending behavior.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="CyclicTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:CYCLIC-TIMING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- complex type for class Peripherals::DAC -->
   <xsd:complexType abstract="false" mixed="false" name="DAC">
      <xsd:annotation>
         <xsd:documentation>The processing unit writes a digital value to a register of the DAC and the value is converted to an analogue value at a given pin.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DAC"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HW-ELEMENT"/>
         <xsd:group ref="AR:PERIPHERAL"/>
         <xsd:group ref="AR:ANALOGUE-IO"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class GlobalConstraints::DataConstr -->
   <xsd:group name="DATA-CONSTR">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataConstr"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-CONSTR-RULES">
            <xsd:annotation>
               <xsd:documentation>This is one particular rule within the data constraints,</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataConstr.dataConstrRule";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="true";xml.roleWrapperElement="true";xml.sequenceOffset="30";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="DATA-CONSTR-RULE" type="AR:DATA-CONSTR-RULE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class GlobalConstraints::DataConstr -->
   <xsd:complexType abstract="false" mixed="false" name="DATA-CONSTR">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataConstr"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:DATA-CONSTR"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="DATA-CONSTR--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="DATA-CONSTR"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class GlobalConstraints::DataConstrRule -->
   <xsd:group name="DATA-CONSTR-RULE">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataConstrRule"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="PHYS-CONSTRS" type="AR:PHYS-CONSTRS">
            <xsd:annotation>
               <xsd:documentation>Describes the limitiations applicapble on the physical domain (as opposed to the internal domain).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataConstrRule.physConstrs";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INTERNAL-CONSTRS" type="AR:INTERNAL-CONSTRS">
            <xsd:annotation>
               <xsd:documentation>Describes the limitiations applicapble on the internal domain (as opposed to the physical domain).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataConstrRule.internalConstrs";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class GlobalConstraints::DataConstrRule -->
   <xsd:complexType abstract="false" mixed="false" name="DATA-CONSTR-RULE">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataConstrRule"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:DATA-CONSTR-RULE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class PortInterface::DataElementPrototype -->
   <xsd:group name="DATA-ELEMENT-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>A data element of a sender-receiver interface, supporting signal like communication patterns.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataElementPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="IS-QUEUED" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Qualifies whether the content of the data element is queued. If it is queued, then the data element has "event" semantics, i.e. data elements are stored in a queue and all data elements are processed in "first in first out" order.
            If it is not queued, then the "last is best" semantics applies. Please note: Depending on the read access cycle to the data element some values might not be processed by the receiver.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataElementPrototype.isQueued";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class PortInterface::DataElementPrototype -->
   <xsd:complexType abstract="false" mixed="false" name="DATA-ELEMENT-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>A data element of a sender-receiver interface, supporting signal like communication patterns.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataElementPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:DATA-PROTOTYPE"/>
         <xsd:group ref="AR:DATA-ELEMENT-PROTOTYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="DATA-ELEMENT-PROTOTYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="DATA-ELEMENT-PROTOTYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Datatypes::DataPrototype -->
   <xsd:group name="DATA-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>Base class for prototypical roles of a datatype.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-DATA-DEF-PROPS" type="AR:SW-DATA-DEF-PROPS">
            <xsd:annotation>
               <xsd:documentation>This element describes all of the distinguishing characteristics of a data object (variable or parameter). &lt;swDataDefProps&gt; is used in every case, where characteristics of data objects must be given.

            It is inevitable that not all of the inputs are useful all of the time. Hence, the process definition or the DCI has the task of implementing limitations.

            The &lt;swDataDefProps&gt; describe the characteristics of all axes:

            * The characteristics of the argument axes (abscissas) are described in &lt;swCalprmAxisSet&gt; .

            * The characteristics of the value axis are described directly in &lt;swDataDefProps&gt; .</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataPrototype.swDataDefProps";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TYPE-TREF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataPrototype.type";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">isOfType</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:DATATYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class MeasurementProperty::DataPrototypeRef -->
   <xsd:group name="DATA-PROTOTYPE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataPrototypeRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-PROTOTYPE-IREF" type="AR:DATA-PROTOTYPE-REF--DATA-PROTOTYPE-IREF">
            <xsd:annotation>
               <xsd:documentation>This represents the referred dataPrototype.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataPrototypeRef.dataPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class MeasurementProperty::DataPrototypeRef -->
   <xsd:complexType abstract="false" mixed="false" name="DATA-PROTOTYPE-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataPrototypeRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:DATA-PROTOTYPE-REF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class _instanceRef::DataPrototypeRef_DataPrototype -->
   <xsd:group name="DATA-PROTOTYPE-REF--DATA-PROTOTYPE-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataPrototypeRef_DataPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="COMPOSITION-COMPONENT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataPrototypeRef_DataPrototype.compositionComponentPrototype";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="10"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMPONENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPONENT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataPrototypeRef_DataPrototype.componentPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMPONENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PORT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataPrototypeRef_DataPrototype.portPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="1" name="DATA-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataPrototypeRef_DataPrototype.dataPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="40"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.target</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:DATA-ELEMENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class _instanceRef::DataPrototypeRef_DataPrototype -->
   <xsd:complexType abstract="false" mixed="false" name="DATA-PROTOTYPE-REF--DATA-PROTOTYPE-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataPrototypeRef_DataPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:DATA-PROTOTYPE-REF--DATA-PROTOTYPE-IREF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataElements::DataReadAccess -->
   <xsd:group name="DATA-READ-ACCESS">
      <xsd:annotation>
         <xsd:documentation>The presence of a DataReadAccess implies that a RunnableEntity needs access to a DataElementPrototype in an RPortPrototype. The RunnableEntity will not modify the contents of the data but only read the information.
      The RunnableEntity expects that the contents of this data does NOT change during the entire duration of its execution.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataReadAccess"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-ELEMENT-IREF" type="AR:DATA-READ-ACCESS--DATA-ELEMENT-IREF">
            <xsd:annotation>
               <xsd:documentation>The data element that is going to be read by this runnable.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="dataElement.DataReadAccess";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataElements::DataReadAccess -->
   <xsd:complexType abstract="false" mixed="false" name="DATA-READ-ACCESS">
      <xsd:annotation>
         <xsd:documentation>The presence of a DataReadAccess implies that a RunnableEntity needs access to a DataElementPrototype in an RPortPrototype. The RunnableEntity will not modify the contents of the data but only read the information.
      The RunnableEntity expects that the contents of this data does NOT change during the entire duration of its execution.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataReadAccess"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:DATA-READ-ACCESS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class _instanceRef::DataReadAccess_dataElement -->
   <xsd:group name="DATA-READ-ACCESS--DATA-ELEMENT-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataReadAccess_dataElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="R-PORT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataReadAccess_dataElement.rPortPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="10"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:R-PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="1" name="DATA-ELEMENT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataReadAccess_dataElement.dataElementPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.target</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:DATA-ELEMENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class _instanceRef::DataReadAccess_dataElement -->
   <xsd:complexType abstract="false" mixed="false" name="DATA-READ-ACCESS--DATA-ELEMENT-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataReadAccess_dataElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:DATA-READ-ACCESS--DATA-ELEMENT-IREF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class RTEEvents::DataReceiveErrorEvent -->
   <xsd:group name="DATA-RECEIVE-ERROR-EVENT">
      <xsd:annotation>
         <xsd:documentation>This event is raised by the RTE when the Com layer detects and notifies an error concerning the reception of the referenced data element.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataReceiveErrorEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-IREF" type="AR:DATA-RECEIVE-ERROR-EVENT--DATA-IREF">
            <xsd:annotation>
               <xsd:documentation>Data element referenced by event</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="data.event";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class RTEEvents::DataReceiveErrorEvent -->
   <xsd:complexType abstract="false" mixed="false" name="DATA-RECEIVE-ERROR-EVENT">
      <xsd:annotation>
         <xsd:documentation>This event is raised by the RTE when the Com layer detects and notifies an error concerning the reception of the referenced data element.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataReceiveErrorEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:RTE-EVENT"/>
         <xsd:group ref="AR:DATA-RECEIVE-ERROR-EVENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class _instanceRef::DataReceiveErrorEvent_data -->
   <xsd:group name="DATA-RECEIVE-ERROR-EVENT--DATA-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataReceiveErrorEvent_data"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="R-PORT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataReceiveErrorEvent_data.rPortPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="10"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:R-PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="1" name="DATA-ELEMENT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataReceiveErrorEvent_data.dataElementPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.target</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:DATA-ELEMENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class _instanceRef::DataReceiveErrorEvent_data -->
   <xsd:complexType abstract="false" mixed="false" name="DATA-RECEIVE-ERROR-EVENT--DATA-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataReceiveErrorEvent_data"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:DATA-RECEIVE-ERROR-EVENT--DATA-IREF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataElements::DataReceivePoint -->
   <xsd:group name="DATA-RECEIVE-POINT">
      <xsd:annotation>
         <xsd:documentation>A DataReceivePoint allows a RunnableEntity to explicitly query for received information, thereby blocking write access to the same information only for a very brief period.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataReceivePoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-ELEMENT-IREF" type="AR:DATA-RECEIVE-POINT--DATA-ELEMENT-IREF">
            <xsd:annotation>
               <xsd:documentation>The data element to be explicitly read.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="dataElement.DataReceivePoint";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataElements::DataReceivePoint -->
   <xsd:complexType abstract="false" mixed="false" name="DATA-RECEIVE-POINT">
      <xsd:annotation>
         <xsd:documentation>A DataReceivePoint allows a RunnableEntity to explicitly query for received information, thereby blocking write access to the same information only for a very brief period.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataReceivePoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:DATA-RECEIVE-POINT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class _instanceRef::DataReceivePoint_dataElement -->
   <xsd:group name="DATA-RECEIVE-POINT--DATA-ELEMENT-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataReceivePoint_dataElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="R-PORT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataReceivePoint_dataElement.rPortPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="10"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:R-PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="1" name="DATA-ELEMENT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataReceivePoint_dataElement.dataElementPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.target</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:DATA-ELEMENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class _instanceRef::DataReceivePoint_dataElement -->
   <xsd:complexType abstract="false" mixed="false" name="DATA-RECEIVE-POINT--DATA-ELEMENT-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataReceivePoint_dataElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:DATA-RECEIVE-POINT--DATA-ELEMENT-IREF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class RTEEvents::DataReceivedEvent -->
   <xsd:group name="DATA-RECEIVED-EVENT">
      <xsd:annotation>
         <xsd:documentation>The event is raised when the referenced data elements are received.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataReceivedEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-IREF" type="AR:DATA-RECEIVED-EVENT--DATA-IREF">
            <xsd:annotation>
               <xsd:documentation>Data element referenced by event</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="data.event";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class RTEEvents::DataReceivedEvent -->
   <xsd:complexType abstract="false" mixed="false" name="DATA-RECEIVED-EVENT">
      <xsd:annotation>
         <xsd:documentation>The event is raised when the referenced data elements are received.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataReceivedEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:RTE-EVENT"/>
         <xsd:group ref="AR:DATA-RECEIVED-EVENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class _instanceRef::DataReceivedEvent_data -->
   <xsd:group name="DATA-RECEIVED-EVENT--DATA-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataReceivedEvent_data"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="R-PORT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataReceivedEvent_data.rPortPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="10"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:R-PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="1" name="DATA-ELEMENT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataReceivedEvent_data.dataElementPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.target</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:DATA-ELEMENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class _instanceRef::DataReceivedEvent_data -->
   <xsd:complexType abstract="false" mixed="false" name="DATA-RECEIVED-EVENT--DATA-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataReceivedEvent_data"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:DATA-RECEIVED-EVENT--DATA-IREF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class RTEEvents::DataSendCompletedEvent -->
   <xsd:group name="DATA-SEND-COMPLETED-EVENT">
      <xsd:annotation>
         <xsd:documentation>The event is raised when the referenced data elements have been sent or an error occurs.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataSendCompletedEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="EVENT-SOURCE-REF">
            <xsd:annotation>
               <xsd:documentation>Data send point that triggers the event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="event.eventSource";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:DATA-SEND-POINT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class RTEEvents::DataSendCompletedEvent -->
   <xsd:complexType abstract="false" mixed="false" name="DATA-SEND-COMPLETED-EVENT">
      <xsd:annotation>
         <xsd:documentation>The event is raised when the referenced data elements have been sent or an error occurs.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataSendCompletedEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:RTE-EVENT"/>
         <xsd:group ref="AR:DATA-SEND-COMPLETED-EVENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class DataElements::DataSendPoint -->
   <xsd:group name="DATA-SEND-POINT">
      <xsd:annotation>
         <xsd:documentation>A DataSendPoint specifies that a RunnableEntity explicitly sends a certain DataElementPrototype.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataSendPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-ELEMENT-IREF" type="AR:DATA-SEND-POINT--DATA-ELEMENT-IREF">
            <xsd:annotation>
               <xsd:documentation>The data element that is sent by this runnable.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="dataElement.DataSendPoint";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataElements::DataSendPoint -->
   <xsd:complexType abstract="false" mixed="false" name="DATA-SEND-POINT">
      <xsd:annotation>
         <xsd:documentation>A DataSendPoint specifies that a RunnableEntity explicitly sends a certain DataElementPrototype.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataSendPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:DATA-SEND-POINT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="DATA-SEND-POINT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="DATA-SEND-POINT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class _instanceRef::DataSendPoint_dataElement -->
   <xsd:group name="DATA-SEND-POINT--DATA-ELEMENT-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataSendPoint_dataElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="P-PORT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataSendPoint_dataElement.pPortPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="10"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:P-PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="1" name="DATA-ELEMENT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataSendPoint_dataElement.dataElementPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.target</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:DATA-ELEMENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class _instanceRef::DataSendPoint_dataElement -->
   <xsd:complexType abstract="false" mixed="false" name="DATA-SEND-POINT--DATA-ELEMENT-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataSendPoint_dataElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:DATA-SEND-POINT--DATA-ELEMENT-IREF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class LinCommunication::DataTiming -->
   <xsd:group name="DATA-TIMING">
      <xsd:annotation>
         <xsd:documentation>A LIN specific extension of the common RelativelyScheduledTiming. The extension maps the LIN specific free data frames into SystemTemplate. The base type keeps scheduling for those free data frames applicable.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="FREE-FORMAT" type="AR:FREE-FORMAT">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FreeFormat.DataTiming";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class LinCommunication::DataTiming -->
   <xsd:complexType abstract="false" mixed="false" name="DATA-TIMING">
      <xsd:annotation>
         <xsd:documentation>A LIN specific extension of the common RelativelyScheduledTiming. The extension maps the LIN specific free data frames into SystemTemplate. The base type keeps scheduling for those free data frames applicable.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:RELATIVELY-SCHEDULED-TIMING"/>
         <xsd:group ref="AR:DATA-TIMING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataElements::DataWriteAccess -->
   <xsd:group name="DATA-WRITE-ACCESS">
      <xsd:annotation>
         <xsd:documentation>The presence of a DataWriteAccess means that the RunnableEntity will potentially modify the DataElementPrototype in the PPortPrototype. The RunnableEntity has free access to the DataElementPrototype while it is running. The RunnableEntity has the responsibility to make sure that the DataElementPrototype is in a consistent state when it returns. When using DataWriteAccess the new values of the DataElementPrototype is not made available via the communication infrastructure before the RunnableEntity returns (exits the "Running" state).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataWriteAccess"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-ELEMENT-IREF" type="AR:DATA-WRITE-ACCESS--DATA-ELEMENT-IREF">
            <xsd:annotation>
               <xsd:documentation>The data element that is going to be written to by this runnable.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="dataElement.DataWriteAccess";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataElements::DataWriteAccess -->
   <xsd:complexType abstract="false" mixed="false" name="DATA-WRITE-ACCESS">
      <xsd:annotation>
         <xsd:documentation>The presence of a DataWriteAccess means that the RunnableEntity will potentially modify the DataElementPrototype in the PPortPrototype. The RunnableEntity has free access to the DataElementPrototype while it is running. The RunnableEntity has the responsibility to make sure that the DataElementPrototype is in a consistent state when it returns. When using DataWriteAccess the new values of the DataElementPrototype is not made available via the communication infrastructure before the RunnableEntity returns (exits the "Running" state).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataWriteAccess"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:DATA-WRITE-ACCESS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class _instanceRef::DataWriteAccess_dataElement -->
   <xsd:group name="DATA-WRITE-ACCESS--DATA-ELEMENT-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataWriteAccess_dataElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="P-PORT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataWriteAccess_dataElement.pPortPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="10"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:P-PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="1" name="DATA-ELEMENT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DataWriteAccess_dataElement.dataElementPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.target</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:DATA-ELEMENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class _instanceRef::DataWriteAccess_dataElement -->
   <xsd:complexType abstract="false" mixed="false" name="DATA-WRITE-ACCESS--DATA-ELEMENT-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DataWriteAccess_dataElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:DATA-WRITE-ACCESS--DATA-ELEMENT-IREF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <xsd:simpleType name="DATATYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ARRAY-TYPE"/>
         <xsd:enumeration value="BOOLEAN-TYPE"/>
         <xsd:enumeration value="CHAR-TYPE"/>
         <xsd:enumeration value="INTEGER-TYPE"/>
         <xsd:enumeration value="OPAQUE-TYPE"/>
         <xsd:enumeration value="REAL-TYPE"/>
         <xsd:enumeration value="RECORD-TYPE"/>
         <xsd:enumeration value="STRING-TYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- complex type for class CoreCommunication::DcmIPdu -->
   <xsd:complexType abstract="false" mixed="false" name="DCM-I-PDU">
      <xsd:annotation>
         <xsd:documentation>Represents the I-PDU's handled by Dcm.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DcmIPdu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:I-PDU"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Fibex4Multiplatform::DefaultValueElement -->
   <xsd:group name="DEFAULT-VALUE-ELEMENT">
      <xsd:annotation>
         <xsd:documentation>The default value consists of a number of elements. Each element is one byte long and the number of elements is specified by SduLength.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DefaultValueElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ELEMENT-BYTE-VALUE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The integer value of a freely defined data byte.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DefaultValueElement.elementByteValue";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ELEMENT-POSITION" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>This attribute specifies the byte position of the
            element within the default value</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DefaultValueElement.elementPosition";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Fibex4Multiplatform::DefaultValueElement -->
   <xsd:complexType abstract="false" mixed="false" name="DEFAULT-VALUE-ELEMENT">
      <xsd:annotation>
         <xsd:documentation>The default value consists of a number of elements. Each element is one byte long and the number of elements is specified by SduLength.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DefaultValueElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:DEFAULT-VALUE-ELEMENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ApplicationAttributes::DelegatedPortAnnotation -->
   <xsd:group name="DELEGATED-PORT-ANNOTATION">
      <xsd:annotation>
         <xsd:documentation>Annotation to a "delegated port" to specify the Signal Fan In or Signal Fan Out inside the Composition Type.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DelegatedPortAnnotation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SIGNAL-FAN" type="AR:SIGNAL-FAN-ENUM">
            <xsd:annotation>
               <xsd:documentation>Specify the Signal Fan In or Signal Fan Out inside the Composition Type</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DelegatedPortAnnotation.signalFan";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ApplicationAttributes::DelegatedPortAnnotation -->
   <xsd:complexType abstract="false" mixed="false" name="DELEGATED-PORT-ANNOTATION">
      <xsd:annotation>
         <xsd:documentation>Annotation to a "delegated port" to specify the Signal Fan In or Signal Fan Out inside the Composition Type.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DelegatedPortAnnotation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:GENERAL-ANNOTATION"/>
         <xsd:group ref="AR:DELEGATED-PORT-ANNOTATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Composition::DelegationConnectorPrototype -->
   <xsd:group name="DELEGATION-CONNECTOR-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>A delegation connector delegates one inner PortPrototype  (a port of a component that is used inside the composition) to a outer PortPrototype of compatible type that belongs directly to the composition (a port that is owned by the composition).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DelegationConnectorPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpStructureElement</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="INNER-PORT-IREF" type="AR:DELEGATION-CONNECTOR-PROTOTYPE--INNER-PORT-IREF">
            <xsd:annotation>
               <xsd:documentation>Connects these ports. The role (inner, outer) of those ports is derived from the context (port of composition or port of inner component).
            The port that belongs to the ComponentPrototype in the composition</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="innerPort.DelegationConnectorPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="OUTER-PORT-REF">
            <xsd:annotation>
               <xsd:documentation>The port that is located on the outside of the CompositionType</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DelegationConnectorPrototype.outerPort";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Composition::DelegationConnectorPrototype -->
   <xsd:complexType abstract="false" mixed="false" name="DELEGATION-CONNECTOR-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>A delegation connector delegates one inner PortPrototype  (a port of a component that is used inside the composition) to a outer PortPrototype of compatible type that belongs directly to the composition (a port that is owned by the composition).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DelegationConnectorPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpStructureElement</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:DELEGATION-CONNECTOR-PROTOTYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class _instanceRef::DelegationConnectorPrototype_innerPort -->
   <xsd:group name="DELEGATION-CONNECTOR-PROTOTYPE--INNER-PORT-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DelegationConnectorPrototype_innerPort"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPONENT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DelegationConnectorPrototype_innerPort.componentPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="10"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMPONENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="1" name="PORT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DelegationConnectorPrototype_innerPort.portPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.target</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class _instanceRef::DelegationConnectorPrototype_innerPort -->
   <xsd:complexType abstract="false" mixed="false" name="DELEGATION-CONNECTOR-PROTOTYPE--INNER-PORT-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DelegationConnectorPrototype_innerPort"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:DELEGATION-CONNECTOR-PROTOTYPE--INNER-PORT-IREF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ECUResourceTemplate::DelegationHWConnection -->
   <xsd:group name="DELEGATION-HW-CONNECTION">
      <xsd:annotation>
         <xsd:documentation>Is used to connect HWPorts of a HWContainer with HWPorts of the contained HWElements.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DelegationHWConnection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="INNER-PORT-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the HWPort of the connected inner HWElement. 
            A single HWPort can only be referenced by exactly one DelegationHWConnection.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DelegationHWConnection.innerPort";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:HW-PORT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="OUTER-PORT-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the HWPort of the connected outer HWElement. 
            A single HWPort can only be referenced by exactly one DelegationHWConnection.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DelegationHWConnection.outerPort";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:HW-PORT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUResourceTemplate::DelegationHWConnection -->
   <xsd:complexType abstract="false" mixed="false" name="DELEGATION-HW-CONNECTION">
      <xsd:annotation>
         <xsd:documentation>Is used to connect HWPorts of a HWContainer with HWPorts of the contained HWElements.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DelegationHWConnection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HW-CONNECTION"/>
         <xsd:group ref="AR:DELEGATION-HW-CONNECTION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Implementation::Dependency -->
   <xsd:group name="DEPENDENCY">
      <xsd:annotation>
         <xsd:documentation>General dependency, typically on the existence of another artifact.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Dependency"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="USAGES">
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element maxOccurs="unbounded" minOccurs="0" name="USAGE" type="AR:DEPENDENCY-USAGE-ENUM">
                     <xsd:annotation>
                        <xsd:documentation>Specification during for which process step(s) this dependency is required.</xsd:documentation>
                        <xsd:appinfo source="tags">mmt.qualifiedName="Dependency.usage";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
                     </xsd:annotation>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class Implementation::DependencyOnFile -->
   <xsd:group name="DEPENDENCY-ON-FILE">
      <xsd:annotation>
         <xsd:documentation>Dependency on the existence of a certain file.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DependencyOnFile"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="XFILE" type="AR:XFILE-SO">
            <xsd:annotation>
               <xsd:documentation>The specified file needs to exist.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DependencyOnFile.xfile";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Implementation::DependencyOnFile -->
   <xsd:complexType abstract="false" mixed="false" name="DEPENDENCY-ON-FILE">
      <xsd:annotation>
         <xsd:documentation>Dependency on the existence of a certain file.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DependencyOnFile"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:DEPENDENCY"/>
         <xsd:group ref="AR:DEPENDENCY-ON-FILE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Implementation::DependencyOnLibrary -->
   <xsd:group name="DEPENDENCY-ON-LIBRARY">
      <xsd:annotation>
         <xsd:documentation>A specific file dependency: without the library that implementation cannot be used (compiled, linked, executed, ...).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DependencyOnLibrary"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-VERSION" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Maximum version compatible with implementation. If not set, there is limitation on the upper version.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DependencyOnLibrary.maxVersion";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MIN-VERSION" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Minimum version compatible with implementation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DependencyOnLibrary.minVersion";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Implementation::DependencyOnLibrary -->
   <xsd:complexType abstract="false" mixed="false" name="DEPENDENCY-ON-LIBRARY">
      <xsd:annotation>
         <xsd:documentation>A specific file dependency: without the library that implementation cannot be used (compiled, linked, executed, ...).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DependencyOnLibrary"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:DEPENDENCY"/>
         <xsd:group ref="AR:DEPENDENCY-ON-FILE"/>
         <xsd:group ref="AR:DEPENDENCY-ON-LIBRARY"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="DEPENDENCY-ON-LIBRARY--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="DEPENDENCY-ON-LIBRARY"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- complex type for class ECUCParameterDefTemplate::DerivedBooleanParamDef -->
   <xsd:complexType abstract="false" mixed="false" name="DERIVED-BOOLEAN-PARAM-DEF">
      <xsd:annotation>
         <xsd:documentation>Derived value is of type Boolean</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DerivedBooleanParamDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PARAM-CONF-MULTIPLICITY"/>
         <xsd:group ref="AR:COMMON-CONFIGURATION-ATTRIBUTES"/>
         <xsd:group ref="AR:CONFIG-PARAMETER"/>
         <xsd:group ref="AR:BOOLEAN-PARAM-DEF"/>
         <xsd:group ref="AR:DERIVED-PARAM-TYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- complex type for class ECUCParameterDefTemplate::DerivedEnumerationParamDef -->
   <xsd:complexType abstract="false" mixed="false" name="DERIVED-ENUMERATION-PARAM-DEF">
      <xsd:annotation>
         <xsd:documentation>Derived value is an Enumeration.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DerivedEnumerationParamDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PARAM-CONF-MULTIPLICITY"/>
         <xsd:group ref="AR:COMMON-CONFIGURATION-ATTRIBUTES"/>
         <xsd:group ref="AR:CONFIG-PARAMETER"/>
         <xsd:group ref="AR:ENUMERATION-PARAM-DEF"/>
         <xsd:group ref="AR:DERIVED-PARAM-TYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- complex type for class ECUCParameterDefTemplate::DerivedFloatParamDef -->
   <xsd:complexType abstract="false" mixed="false" name="DERIVED-FLOAT-PARAM-DEF">
      <xsd:annotation>
         <xsd:documentation>Derived value is of type Float</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DerivedFloatParamDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PARAM-CONF-MULTIPLICITY"/>
         <xsd:group ref="AR:COMMON-CONFIGURATION-ATTRIBUTES"/>
         <xsd:group ref="AR:CONFIG-PARAMETER"/>
         <xsd:group ref="AR:FLOAT-PARAM-DEF"/>
         <xsd:group ref="AR:DERIVED-PARAM-TYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- complex type for class ECUCParameterDefTemplate::DerivedIntegerParamDef -->
   <xsd:complexType abstract="false" mixed="false" name="DERIVED-INTEGER-PARAM-DEF">
      <xsd:annotation>
         <xsd:documentation>Derived value is of type Integer.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DerivedIntegerParamDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PARAM-CONF-MULTIPLICITY"/>
         <xsd:group ref="AR:COMMON-CONFIGURATION-ATTRIBUTES"/>
         <xsd:group ref="AR:CONFIG-PARAMETER"/>
         <xsd:group ref="AR:INTEGER-PARAM-DEF"/>
         <xsd:group ref="AR:DERIVED-PARAM-TYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUCParameterDefTemplate::DerivedParamType -->
   <xsd:group name="DERIVED-PARAM-TYPE">
      <xsd:annotation>
         <xsd:documentation>Allows to define configuration items that are calculated based on the value of 
      * other parameters values
      * elements (attributes /classes) defined in other AUTOSAR templates such as System template and SW component template.
      A calculation definition is given which defines how Configuration Editors and
      Generators can calculate the value from other values when needed to display/use
      the configuration item.
      The actual value is stored in the "value" attribute of the derived parameter.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DerivedParamType";xml.sequenceOffset="40"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CALCULATION-FORMULA" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Definition of the formula used to calculate the value of the configuration element.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DerivedParamType.calculationFormula";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CALCULATION-LANGUAGE" type="AR:CALCULATION-LANGUAGE">
            <xsd:annotation>
               <xsd:documentation>Definition of the languag used to specify the formula in attribute calculationFormula.
            Currentlfy, only informal definition of the formula is supported.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DerivedParamType.calculationLanguage";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::DerivedStringParamDef -->
   <xsd:complexType abstract="false" mixed="false" name="DERIVED-STRING-PARAM-DEF">
      <xsd:annotation>
         <xsd:documentation>Derived value is of type String.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DerivedStringParamDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PARAM-CONF-MULTIPLICITY"/>
         <xsd:group ref="AR:COMMON-CONFIGURATION-ATTRIBUTES"/>
         <xsd:group ref="AR:CONFIG-PARAMETER"/>
         <xsd:group ref="AR:STRING-PARAM-DEF"/>
         <xsd:group ref="AR:DERIVED-PARAM-TYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- complex type for class ServiceNeeds::DiagnosticCommunicationNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="DIAGNOSTIC-COMMUNICATION-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs on the configuration of the  Diagnostic Communication Manager for one "user".

      Details are an expert task for AUTOSAR Release 4.0.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticCommunicationNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- complex type for class ServiceNeeds::DiagnosticEventNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="DIAGNOSTIC-EVENT-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs on the configuration of the Diagnostic Event Manager for one diagnostic event. Its name can be regarded as a symbol identifying the diagnostic event from the viewpoint of the component or module which owns this class.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DiagnosticEventNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="DIAGNOSTIC-EVENT-NEEDS--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="DIAGNOSTIC-EVENT-NEEDS"/>
         <xsd:enumeration value="SWC-DIAGNOSTIC-EVENT-NEEDS"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Peripherals::DigitalIO -->
   <xsd:group name="DIGITAL-IO">
      <xsd:annotation>
         <xsd:documentation>Digital Input/Output peripherals provide the capability to send/receive data in a digital manner. Each digital input has an electrical range. When the voltage is less than a specified level, the input is represents logical low '0'. On the opposite when the voltage is higher than a specified value the input represents logical high '1'. A digital I/O can usually be programmed to be either an input or output. It can also be programmed to logically invert the input or output. The maximum frequency of a digital input or output is related to how fast the PU can read or write to the digital I/O register. It's very common for a digital I/O to have different functionality. One example is when a timer has an external clock signal associated with a digital I/O. In this case the maximum frequency is defined by the performance of the timer counter and can be found in the electrical characteristic of the peripheral datasheet.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DigitalIO"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="EDGE-DETECTION" type="AR:DIGITAL-IO-EDGE-DETECTION-ENUM">
            <xsd:annotation>
               <xsd:documentation>A general digital input can be enabled to trigger an interrupt on a falling, rising or both edges of an input signal. A clock, compare or count input on a timer can be programmed to increase, decrease or store the timer value if a change on the input pin has occurred. The condition for this change can be programmed to trigger an event  in the same manner as for a digital input.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DigitalIO.edgeDetection";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Peripherals::DigitalIO -->
   <xsd:complexType abstract="false" mixed="false" name="DIGITAL-IO">
      <xsd:annotation>
         <xsd:documentation>Digital Input/Output peripherals provide the capability to send/receive data in a digital manner. Each digital input has an electrical range. When the voltage is less than a specified level, the input is represents logical low '0'. On the opposite when the voltage is higher than a specified value the input represents logical high '1'. A digital I/O can usually be programmed to be either an input or output. It can also be programmed to logically invert the input or output. The maximum frequency of a digital input or output is related to how fast the PU can read or write to the digital I/O register. It's very common for a digital I/O to have different functionality. One example is when a timer has an external clock signal associated with a digital I/O. In this case the maximum frequency is defined by the performance of the timer counter and can be found in the electrical characteristic of the peripheral datasheet.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DigitalIO"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HW-ELEMENT"/>
         <xsd:group ref="AR:PERIPHERAL"/>
         <xsd:group ref="AR:DIGITAL-IO"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- complex type for class ECUElectronics::DiscreteECUElectronics -->
   <xsd:complexType abstract="false" mixed="false" name="DISCRETE-ECU-ELECTRONICS">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DiscreteECUElectronics"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HW-ELEMENT"/>
         <xsd:group ref="AR:ECU-ELECTRONICS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class SensorActuator::DisplayHW -->
   <xsd:group name="DISPLAY-HW">
      <xsd:annotation>
         <xsd:documentation>The Display HW element derives from HW Sensor Actuator and can be connected to a PU via a serial or parallel interface.
      For the parallel mode the display can be connected to the data bus and address bus of a PU or to a peripheral.
      The most common serial interface for displays are:
      - I2C
      - SPI
      The most common physical interface for high resolution displays are the LVDS interface (Low Voltage Differential Signalling). This interface has three different lines for colours (RGB) and additional lines for control signals.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DisplayHW"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BACKLIGHT" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Defines whether the display has a background lighting. This eases the readability of the displays during bad daylight conditions.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DisplayHW.backlight";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="BRIGHTNESS" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Defines the visibility of the display.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DisplayHW.brightness";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="BTYPE-OF-CHARACTERS" type="AR:DISPLAY-HW-TYPE-OF-CHARACTERS-ENUM">
            <xsd:annotation>
               <xsd:documentation>If the display can present numerical, alpha-numerical, semi-graphical or graphical objects.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DisplayHW.btypeOfCharacters";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CHARACTER-GENERATOR" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>If the display has an in-built character generator.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DisplayHW.characterGenerator";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CHARACTER-SET" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Defines which character set that can be handled by the display. There is a number of standardised character sets like ISO-8859-1 or Unicode.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DisplayHW.characterSet";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COLOUR" type="AR:DISPLAY-HW-COLOUR-ENUM">
            <xsd:annotation>
               <xsd:documentation>If the display can show objects in monochrome, grey scale or in colour.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DisplayHW.colour";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RESOLUTION-RATION" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Defines the ratio of the display resolution in horizontal versus vertical direction (e.g. 16 to 9).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DisplayHW.resolutionRation";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RESOLUTION-X" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Defines the number of the smallest graphical elements which can be displayed in horizontal direction.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DisplayHW.resolutionX";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RESOLUTION-Y" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Defines the number of the smallest graphical elements which can be displayed in vertical direction.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DisplayHW.resolutionY";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RESPONSE-TIME" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Defines how long it takes for the display to show a changed element at -20 degree C.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DisplayHW.responseTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VIEWING-ANGLE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Defines the angle range where the display can be observed.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DisplayHW.viewingAngle";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SensorActuator::DisplayHW -->
   <xsd:complexType abstract="false" mixed="false" name="DISPLAY-HW">
      <xsd:annotation>
         <xsd:documentation>The Display HW element derives from HW Sensor Actuator and can be connected to a PU via a serial or parallel interface.
      For the parallel mode the display can be connected to the data bus and address bus of a PU or to a peripheral.
      The most common serial interface for displays are:
      - I2C
      - SPI
      The most common physical interface for high resolution displays are the LVDS interface (Low Voltage Differential Signalling). This interface has three different lines for colours (RGB) and additional lines for control signals.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DisplayHW"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HW-ELEMENT"/>
         <xsd:group ref="AR:SENSOR-ACTUATOR-HW"/>
         <xsd:group ref="AR:DISPLAY-HW"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- complex type for class Units::DisplayName -->
   <xsd:complexType abstract="false" mixed="true" name="DISPLAY-NAME">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DisplayName"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0"/>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class AdminData::DocRevision -->
   <xsd:group name="DOC-REVISION">
      <xsd:annotation>
         <xsd:documentation>Use &lt;docRevision&gt; , to generate information on the corresponding document version.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DocRevision";xml.sequenceOffset="20"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="REVISION-LABEL" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Use revisionLabel, to enter the version number of the document, or the document section to which administrative is applied.. The syntax is free and refers to the configuration management plan respectively the version management tool being used.
            Therefore it is still kept as String.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DocRevision.revisionLabel";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REVISION-LABEL-P-1" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Use revisionLabelP1, to enter the version number of the ** of the document, or the document section to which administrative is applied.. The syntax is free and refers to the configuration management plan respectively the version management tool being used. This element is used, if the document or document section is the result of a merge process in which two branches are merged in to one new revision.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DocRevision.revisionLabelP1";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REVISION-LABEL-P-2" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Use revisionLabelP1, to enter the version number of the ** of the document, or the document section to which administrative is applied.. The syntax is free and refers to the configuration management plan respectively the version management tool being used. This element is used, if the document or document section is the result of a merge process in which two branches are merged in to one new revision.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DocRevision.revisionLabelP2";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="STATE" type="AR:SL-DATA-10">
            <xsd:annotation>
               <xsd:documentation>&lt;state&gt; represents the current state of the current file according to the configuration management plan.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DocRevision.state";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ISSUED-BY" type="AR:SL-DATA-10">
            <xsd:annotation>
               <xsd:documentation>This element contains the name of the person who initiated the document revision. If the initiator cannot be referenced as &lt;teamMember&gt; in the current document his name can be given in this element.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DocRevision.issuedBy";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="60"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATE" type="xsd:dateTime">
            <xsd:annotation>
               <xsd:documentation>This specifies the time, when the object in question was released</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DocRevision.date";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="80"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODIFICATIONS">
            <xsd:annotation>
               <xsd:documentation>Use &lt;modification&gt; to record what has changed in a document in comparison to its predecessor.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DocRevision.modification";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="true";xml.roleWrapperElement="true";xml.sequenceOffset="100";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="MODIFICATION" type="AR:MODIFICATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class AdminData::DocRevision -->
   <xsd:complexType abstract="false" mixed="false" name="DOC-REVISION">
      <xsd:annotation>
         <xsd:documentation>Use &lt;docRevision&gt; , to generate information on the corresponding document version.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DocRevision";xml.sequenceOffset="20"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:DOC-REVISION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DocumentationBlock::DocumentationBlock -->
   <xsd:group name="DOCUMENTATION-BLOCK">
      <xsd:annotation>
         <xsd:documentation>This class represents a documentation block.It represents a sequence of paragraphs. Main intention is to provide References to external objects which are not processed by AUTOSAR-tooling.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DocumentationBlock"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixed,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice>
         <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element maxOccurs="unbounded" minOccurs="0" name="P" type="AR:ML-DATA-1">
               <xsd:annotation>
                  <xsd:documentation>Use &lt;p&gt; to create a paragraph for continuous texts.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="DocumentationBlock.p";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="50"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
         </xsd:choice>
      </xsd:choice>
   </xsd:group>
   <!-- complex type for class DocumentationBlock::DocumentationBlock -->
   <xsd:complexType abstract="false" mixed="false" name="DOCUMENTATION-BLOCK">
      <xsd:annotation>
         <xsd:documentation>This class represents a documentation block.It represents a sequence of paragraphs. Main intention is to provide References to external objects which are not processed by AUTOSAR-tooling.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DocumentationBlock"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixed,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:DOCUMENTATION-BLOCK"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CoreCommunication::DynamicPart -->
   <xsd:group name="DYNAMIC-PART">
      <xsd:annotation>
         <xsd:documentation>Dynamic part of a multiplexed I-Pdu. 
      Reserved space which is used to transport varying SignalIPdus at the same position, controlled by the corresponding selectorFieldCode.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DynamicPart"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DYNAMIC-PART-ALTERNATIVES">
            <xsd:annotation>
               <xsd:documentation>Com IPdu alternatives that are transmitted  in the Dynamic Part of the MultiplexedIPdu.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="dynamicPartAlternative.DynamicPart";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="DYNAMIC-PART-ALTERNATIVE" type="AR:DYNAMIC-PART-ALTERNATIVE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::DynamicPart -->
   <xsd:complexType abstract="false" mixed="false" name="DYNAMIC-PART">
      <xsd:annotation>
         <xsd:documentation>Dynamic part of a multiplexed I-Pdu. 
      Reserved space which is used to transport varying SignalIPdus at the same position, controlled by the corresponding selectorFieldCode.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DynamicPart"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:MULTIPLEXED-PART"/>
         <xsd:group ref="AR:DYNAMIC-PART"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CoreCommunication::DynamicPartAlternative -->
   <xsd:group name="DYNAMIC-PART-ALTERNATIVE">
      <xsd:annotation>
         <xsd:documentation>One of the Com IPdu alternatives that are transmitted in the Dynamic Part of the MultiplexedIPdu. The selectorFieldCode specifies which Com IPdu is contained in the DynamicPart within a certain transmission of a multiplexed PDU.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DynamicPartAlternative"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="I-PDU-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to a Com IPdu which is routed to the IPduM module and is combined to a multiplexedPdu.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DynamicPartAlternative.iPdu";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SIGNAL-I-PDU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INITIAL-DYNAMIC-PART" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Dynamic part that shall be used to initialize this multiplexed IPdu.

            Constraint: Only one "DynamicPartAlternative" in a "DynamicPart" shall be the initialDynamicPart.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DynamicPartAlternative.initialDynamicPart";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SELECTOR-FIELD-CODE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The selector field is part of a multiplexed IPdu. It consists of contiguous bits. The value of the selector field selects the layout of the dynamic part of the IPdu.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="DynamicPartAlternative.selectorFieldCode";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::DynamicPartAlternative -->
   <xsd:complexType abstract="false" mixed="false" name="DYNAMIC-PART-ALTERNATIVE">
      <xsd:annotation>
         <xsd:documentation>One of the Com IPdu alternatives that are transmitted in the Dynamic Part of the MultiplexedIPdu. The selectorFieldCode specifies which Com IPdu is contained in the DynamicPart within a certain transmission of a multiplexed PDU.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="DynamicPartAlternative"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:DYNAMIC-PART-ALTERNATIVE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ECUResourceTemplate::ECU -->
   <xsd:group name="ECU">
      <xsd:annotation>
         <xsd:documentation>The ECU provides information about an ECU and its internal hardware elements. The described hardware elements are related to some extent to basic software configuration and the AUTOSAR generation process.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ECU"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpType</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECU-ABSTRACTION-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the software component describing the ECU Abstraction software module for this ECU.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ECU.ecuAbstraction";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMPONENT-TYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUResourceTemplate::ECU -->
   <xsd:complexType abstract="false" mixed="false" name="ECU">
      <xsd:annotation>
         <xsd:documentation>The ECU provides information about an ECU and its internal hardware elements. The described hardware elements are related to some extent to basic software configuration and the AUTOSAR generation process.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ECU"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpType</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HW-ELEMENT"/>
         <xsd:group ref="AR:HW-ELEMENT-CONTAINER"/>
         <xsd:group ref="AR:ECU"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="ECU--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ECU"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- complex type for class Peripherals::ECUCommunicationPort -->
   <xsd:complexType abstract="false" mixed="false" name="ECU-COMMUNICATION-PORT">
      <xsd:annotation>
         <xsd:documentation>A specialization of a Communication HW Port that is availabe for the inter ECU communication.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ECUCommunicationPort"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HW-PORT"/>
         <xsd:group ref="AR:PERIPHERAL-HW-PORT"/>
         <xsd:group ref="AR:COMMUNICATION-HW-PORT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="ECU-COMMUNICATION-PORT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ECU-COMMUNICATION-PORT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ECUElectronics::ECUElectronics -->
   <xsd:group name="ECU-ELECTRONICS">
      <xsd:annotation>
         <xsd:documentation>The abstract class ECU Electronics HW Element contains all elements and attributes common for all kind of ECU Electronics.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ECUElectronics"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CAN-BE-DISABLED" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Defines if the ECU Electronic can be enabled and disabled.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ECUElectronics.canBeDisabled";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class ECUResourceMapping::ECUMapping -->
   <xsd:group name="ECU-MAPPING">
      <xsd:annotation>
         <xsd:documentation>ECUMapping allows to assign an ECU hardware type (defined in the ECU Resource Template) to an ECUInstance used in a physical topology.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ECUMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMM-CONTROLLER-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>The ECUMapping contains the mapping of all CommunicationControllers of the ECU.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="commControllerMapping.ECUMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="COMMUNICATION-CONTROLLER-MAPPING" type="AR:COMMUNICATION-CONTROLLER-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECU-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the EcuInstance in the System Template</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ECUMapping.ecuInstance";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ECU-INSTANCE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECU-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the Ecu description in the ECU Resource Template</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ECUMapping.ecu";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ECU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PORT-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>The ECUMapping contains the mapping of all HW Ports of the ECU.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="portMapping.ECUMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="HW-PORT-MAPPING" type="AR:HW-PORT-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUResourceMapping::ECUMapping -->
   <xsd:complexType abstract="false" mixed="false" name="ECU-MAPPING">
      <xsd:annotation>
         <xsd:documentation>ECUMapping allows to assign an ECU hardware type (defined in the ECU Resource Template) to an ECUInstance used in a physical topology.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ECUMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ECU-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ExecutionTime::ECUPrototype -->
   <xsd:group name="ECU-PROTOTYPE">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ECUPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="E-CU-TREF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ECUPrototype.ECU";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">isOfType</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ECU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ExecutionTime::ECUPrototype -->
   <xsd:complexType abstract="false" mixed="false" name="ECU-PROTOTYPE">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ECUPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:ECU-PROTOTYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- complex type for class Inlines::EType -->
   <xsd:complexType abstract="false" mixed="true" name="E-TYPE">
      <xsd:annotation>
         <xsd:documentation>This is an emphasized text. As a compromise it contains some rendering oriented attributes such as color and font.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0"/>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Components::EcuAbstractionComponentType -->
   <xsd:group name="ECU-ABSTRACTION-COMPONENT-TYPE">
      <xsd:annotation>
         <xsd:documentation>The ECUAbstraction is a special AtomicSoftwareComponent that sits between a component that wants to access ECUperiphery and the Microcontroller Abstraction. The EcuAbstractionComponentType introduces the possibility to link from the software representation to its hardware description provided by the ECU Resource Template.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcuAbstractionComponentType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpType</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BSW-MODULE-DESCRIPTION-REFS">
            <xsd:annotation>
               <xsd:documentation>Reference from the EcuAbstractionComponentType to the Basic Software Module Description describing the BSW part of the ECU Abstraction Component.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcuAbstractionComponentType.bswModuleDescription";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="BSW-MODULE-DESCRIPTION-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:BSW-MODULE-DESCRIPTION--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="HARDWARE-ELEMENT-REFS">
            <xsd:annotation>
               <xsd:documentation>Reference from the EcuAbstractionComponentType to the description of the used HWElements.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcuAbstractionComponentType.hardwareElement";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="HARDWARE-ELEMENT-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:HW-ELEMENT--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Components::EcuAbstractionComponentType -->
   <xsd:complexType abstract="false" mixed="false" name="ECU-ABSTRACTION-COMPONENT-TYPE">
      <xsd:annotation>
         <xsd:documentation>The ECUAbstraction is a special AtomicSoftwareComponent that sits between a component that wants to access ECUperiphery and the Microcontroller Abstraction. The EcuAbstractionComponentType introduces the possibility to link from the software representation to its hardware description provided by the ECU Resource Template.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcuAbstractionComponentType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpType</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COMPONENT-TYPE"/>
         <xsd:group ref="AR:ECU-ABSTRACTION-COMPONENT-TYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUCDescriptionTemplate::EcuConfiguration -->
   <xsd:group name="ECU-CONFIGURATION">
      <xsd:annotation>
         <xsd:documentation>This represents the anchor point of the ECU configuration description.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcuConfiguration"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECU-EXTRACT-REF">
            <xsd:annotation>
               <xsd:documentation>Represents the extract of the System Configuration that is relevant for the ECU configured with that ECU Configuration Description.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcuConfiguration.ecuExtract";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SYSTEM--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECU-SW-COMPOSITION-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the EcuSwComposition which holds the AUTOSAR Service Software Components.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcuConfiguration.ecuSwComposition";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ECU-SW-COMPOSITION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODULE-REFS">
            <xsd:annotation>
               <xsd:documentation>References to the configuration of individual software modules that are present on this ECU.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcuConfiguration.module";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="MODULE-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:MODULE-CONFIGURATION--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCDescriptionTemplate::EcuConfiguration -->
   <xsd:complexType abstract="false" mixed="false" name="ECU-CONFIGURATION">
      <xsd:annotation>
         <xsd:documentation>This represents the anchor point of the ECU configuration description.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcuConfiguration"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ECU-CONFIGURATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class CoreTopology::EcuInstance -->
   <xsd:group name="ECU-INSTANCE">
      <xsd:annotation>
         <xsd:documentation>ECUInstances are used to define the ECUs used in the topology. The type of the ECU is defined by a reference to an ECU specified with the ECU resource description.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcuInstance"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ASSOCIATED-I-PDU-GROUP-REFS">
            <xsd:annotation>
               <xsd:documentation>With this reference it is possible to identify which IPduGroups are applicable for which CommunicationConnector/ ECU.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcuInstance.associatedIPduGroup";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ASSOCIATED-I-PDU-GROUP-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:I-PDU-GROUP--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ASSOCIATED-PDUR-I-PDU-GROUP-REFS">
            <xsd:annotation>
               <xsd:documentation>With this reference it is possible to identify which PduR IPdu Groups are applicable for which CommunicationConnector/ ECU.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcuInstance.associatedPdurIPduGroup";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ASSOCIATED-PDUR-I-PDU-GROUP-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:PDUR-I-PDU-GROUP--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COM-CONFIGURATION-ID" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>This ID is returned by a call to Com_GetConfigurationId()</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcuInstance.comConfigurationId";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COM-PROCESSING-PERIOD" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>The COM scheduling time is used in order to be able to calculate the worst case bus timing. The processing period shall be specified
            AUTOSAR conform in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcuInstance.comProcessingPeriod";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COM-PROCESSING-PERIOD-GW" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Optional signal Routing processing period of the COM scheduling in order to be able to calculate the worst case bus timing. Only applicable if a different processing period for Tx and Routing shall be respected.
            If not present the "comProcessingPeriod" attribute shall be used for Tx and Gateway operation.
            The processing period shall be specified AUTOSAR conform in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcuInstance.comProcessingPeriodGw";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COM-PROCESSING-PERIOD-RX" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Optional Rx processing period of the COM scheduling in order to be able to calculate the worst case bus timing.
            Only applicable if a different processing period for Tx and Rx shall be respected. If not present the "comProcessingPeriod" attribute shall be used for Tx and Rx operation. The processing period shall be specified AUTOSAR conform in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcuInstance.comProcessingPeriodRx";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMM-CONTROLLERS">
            <xsd:annotation>
               <xsd:documentation>CommunicationControllers of the ECU.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="commController.EcuInstance";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CAN-COMMUNICATION-CONTROLLER" type="AR:CAN-COMMUNICATION-CONTROLLER"/>
                  <xsd:element name="COMMUNICATION-CONTROLLER" type="AR:COMMUNICATION-CONTROLLER"/>
                  <xsd:element name="FLEXRAY-COMMUNICATION-CONTROLLER" type="AR:FLEXRAY-COMMUNICATION-CONTROLLER"/>
                  <xsd:element name="LIN-MASTER" type="AR:LIN-MASTER"/>
                  <xsd:element name="LIN-SLAVE" type="AR:LIN-SLAVE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONNECTORS">
            <xsd:annotation>
               <xsd:documentation>All channels controlled by a single controller.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="connector.EcuInstance";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CAN-COMMUNICATION-CONNECTOR" type="AR:CAN-COMMUNICATION-CONNECTOR"/>
                  <xsd:element name="COMMUNICATION-CONNECTOR" type="AR:COMMUNICATION-CONNECTOR"/>
                  <xsd:element name="FLEX-RAY-COMMUNICATION-CONNECTOR" type="AR:FLEX-RAY-COMMUNICATION-CONNECTOR"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DIAGNOSTIC-ADDRESS" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>An ECU specific ID for responses of diagnostic routines.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcuInstance.diagnosticAddress";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PDU-R-CONFIGURATION-ID" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>unique PDURconfiguration identifier</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcuInstance.pduRConfigurationId";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RESPONSE-ADDRESSS">
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element maxOccurs="unbounded" minOccurs="0" name="RESPONSE-ADDRESS" type="xsd:integer">
                     <xsd:annotation>
                        <xsd:documentation>An ECU specific ID for responses of diagnostic routines.</xsd:documentation>
                        <xsd:appinfo source="tags">mmt.qualifiedName="EcuInstance.responseAddress";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
                     </xsd:annotation>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SLEEP-MODE-SUPPORTED" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Specifies whether the ECU instance may be put to a "low power mode" TRUE: sleep mode is supported FALSE: sleep mode is not supported 

            Note: This flag may only be set to TRUE if the feature is supported by both hardware and basic software.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcuInstance.sleepModeSupported";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="WAKE-UP-OVER-BUS-SUPPORTED" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Driver support for wakeup over Bus.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcuInstance.wakeUpOverBusSupported";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreTopology::EcuInstance -->
   <xsd:complexType abstract="false" mixed="false" name="ECU-INSTANCE">
      <xsd:annotation>
         <xsd:documentation>ECUInstances are used to define the ECUs used in the topology. The type of the ECU is defined by a reference to an ECU specified with the ECU resource description.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcuInstance"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ECU-INSTANCE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="ECU-INSTANCE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ECU-INSTANCE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ECUCParameterDefTemplate::EcuParameterDefinition -->
   <xsd:group name="ECU-PARAMETER-DEFINITION">
      <xsd:annotation>
         <xsd:documentation>This represents the anchor point of an ECU Configuration Parameter Definition within the AUTOSAR templates structure.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcuParameterDefinition"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODULE-REFS">
            <xsd:annotation>
               <xsd:documentation>References to  the module definitions of individual software modules.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcuParameterDefinition.module";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="MODULE-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:MODULE-DEF--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::EcuParameterDefinition -->
   <xsd:complexType abstract="false" mixed="false" name="ECU-PARAMETER-DEFINITION">
      <xsd:annotation>
         <xsd:documentation>This represents the anchor point of an ECU Configuration Parameter Definition within the AUTOSAR templates structure.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcuParameterDefinition"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ECU-PARAMETER-DEFINITION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class SWmapping::EcuResourceEstimation -->
   <xsd:group name="ECU-RESOURCE-ESTIMATION">
      <xsd:annotation>
         <xsd:documentation>Resource estimations for RTE and BSW of a single ECU instance.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcuResourceEstimation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BSW-RESOURCE-ESTIMATION" type="AR:RESOURCE-CONSUMPTION">
            <xsd:annotation>
               <xsd:documentation>Estimation for the resource consumption of the basic software.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="bswResourceEstimation.EcuResourceEstimation";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECU-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the ECU this estimation is done for.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcuResourceEstimation.ecuInstance";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ECU-INSTANCE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RTE-RESOURCE-ESTIMATION" type="AR:RESOURCE-CONSUMPTION">
            <xsd:annotation>
               <xsd:documentation>Estimation for the resource consumption of the run time environment.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="rteResourceEstimation.EcuResourceEstimation";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-COMP-TO-ECU-MAPPING-REFS">
            <xsd:annotation>
               <xsd:documentation>References to  SwCompToEcuMappings that have been taken into account for the resource estimations. This way it is possible to define dfferent EcuResourceEstimations with different mappings, e.g. before and after mapping an additional SW component.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcuResourceEstimation.swCompToEcuMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SW-COMP-TO-ECU-MAPPING-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:SWC-TO-ECU-MAPPING--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SWmapping::EcuResourceEstimation -->
   <xsd:complexType abstract="false" mixed="false" name="ECU-RESOURCE-ESTIMATION">
      <xsd:annotation>
         <xsd:documentation>Resource estimations for RTE and BSW of a single ECU instance.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcuResourceEstimation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:ECU-RESOURCE-ESTIMATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- complex type for class ServiceNeeds::EcuStateMgrUserNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="ECU-STATE-MGR-USER-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs on the configuration of the ECU State  Manager for one "user". This class currently contains no attributes. Its name can be regarded as a symbol identifying the user  from the viewpoint of the component or module which owns this class.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcuStateMgrUserNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Services::EcuSwComposition -->
   <xsd:group name="ECU-SW-COMPOSITION">
      <xsd:annotation>
         <xsd:documentation>EcuSwComposition contains the complete Software Composition in an ECU, consisting both of application software components and service components.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcuSwComposition"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpStructureElement</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPONENTS">
            <xsd:annotation>
               <xsd:documentation>Service components used within one EcuSwComposition</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="component.EcuSwComposition";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SERVICE-COMPONENT-PROTOTYPE" type="AR:SERVICE-COMPONENT-PROTOTYPE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONNECTORS">
            <xsd:annotation>
               <xsd:documentation>The connectors used for connecting Service ports with the AtomicSoftwareComponents' service ports.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="connector.EcuSwComposition";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SERVICE-CONNECTOR-PROTOTYPE" type="AR:SERVICE-CONNECTOR-PROTOTYPE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECU-EXTRACT-REF">
            <xsd:annotation>
               <xsd:documentation>Represents the extract of the System Configuration which the referencing EcuSwComposition applies to, in particular the softwareComposition. As EcuSwComposition is only valid in the context of a given EcuConfiguration, this association needs to have the same target as the ecuExtract association from EcuConfiguration.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EcuSwComposition.ecuExtract";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SYSTEM--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Services::EcuSwComposition -->
   <xsd:complexType abstract="false" mixed="false" name="ECU-SW-COMPOSITION">
      <xsd:annotation>
         <xsd:documentation>EcuSwComposition contains the complete Software Composition in an ECU, consisting both of application software components and service components.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EcuSwComposition"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpStructureElement</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:ECU-SW-COMPOSITION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="ECU-SW-COMPOSITION--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ECU-SW-COMPOSITION"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class BasicElements::ElectricalRange -->
   <xsd:group name="ELECTRICAL-RANGE">
      <xsd:annotation>
         <xsd:documentation>Specifies electrical ranges for different applications within the ECU Resource Template.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ElectricalRange"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-CURRENT" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Maximum Current
            Unit: A</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ElectricalRange.maxCurrent";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-VOLTAGE" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Maximum voltage
            Unit: V</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ElectricalRange.maxVoltage";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MIN-CURRENT" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Minimum Current
            Unit: A</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ElectricalRange.minCurrent";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MIN-VOLTAGE" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Minimum voltage
            Unit: V</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ElectricalRange.minVoltage";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TYPICAL-CURRENT" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Typical Current
            Unit: A</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ElectricalRange.typicalCurrent";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TYPICAL-VOLTAGE" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Typical voltage
            Unit: V</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ElectricalRange.typicalVoltage";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BasicElements::ElectricalRange -->
   <xsd:complexType abstract="false" mixed="false" name="ELECTRICAL-RANGE">
      <xsd:annotation>
         <xsd:documentation>Specifies electrical ranges for different applications within the ECU Resource Template.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ElectricalRange"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:ELECTRICAL-RANGE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataMapping::EmptySignalMapping -->
   <xsd:group name="EMPTY-SIGNAL-MAPPING">
      <xsd:annotation>
         <xsd:documentation>According to the COM Specification, signal groups without signals are allowed. These have a "signalLength" = 0. In this case there shall be an "update-bit" configured.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EmptySignalMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYSTEM-SIGNAL-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to a SystemSignal with "signalLength" = 0 and an UpdateBit.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EmptySignalMapping.systemSignal";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SYSTEM-SIGNAL--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataMapping::EmptySignalMapping -->
   <xsd:complexType abstract="false" mixed="false" name="EMPTY-SIGNAL-MAPPING">
      <xsd:annotation>
         <xsd:documentation>According to the COM Specification, signal groups without signals are allowed. These have a "signalLength" = 0. In this case there shall be an "update-bit" configured.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EmptySignalMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:EMPTY-SIGNAL-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class EndToEndProtection::EndToEndDescription -->
   <xsd:group name="END-TO-END-DESCRIPTION">
      <xsd:annotation>
         <xsd:documentation>This meta-class contains information about end-to-end protection. The set of applicable attributes depends on the actual value of the category attribute of EndToEndProtection.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndDescription"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CATEGORY" type="xsd:NMTOKEN">
            <xsd:annotation>
               <xsd:documentation>The category represents the identification of the concrete E2E profile. The applicable values are specified in a semantic constraint and determine the applicable attributes of EndToEndDescription.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndDescription.category";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="-100"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-IDS">
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element maxOccurs="unbounded" minOccurs="0" name="DATA-ID" type="xsd:integer">
                     <xsd:annotation>
                        <xsd:documentation>This represents a unique numerical identifier. 
                     Note: ID is used for protection against masquerading. The details concerning the maximum number of values (this information is specific for each E2E profile) applicable for this attribute are controlled by a semantic constraint that depends on the category of the EndToEndProtection.</xsd:documentation>
                        <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndDescription.dataId";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="-90"</xsd:appinfo>
                     </xsd:annotation>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-ID-MODE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>There are three inclusion modes how the implicit two-byte Data ID is included in the one-byte CRC:

            * dataIDMode = 0: Two bytes are included in the CRC (double ID configuration) This is used in variant 1A.
            * dataIDMode = 1: One of the two bytes byte is included, alternating high and low byte, depending on parity of the counter (alternating ID configuration). For even counter low byte is included; For odd counters the high byte is included. This is used in variant 1B.
            * dataIDMode = 2: Only low byte is included, high byte is never used. This is applicable if the IDs in a particular system are 8 bits.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndDescription.dataIdMode";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="-85"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-LENGTH" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>This attribute represents the length of the Array representation of the Signal Group/DataElementPrototype including CRC and Counter in bits.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndDescription.dataLength";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="-80"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-DELTA-COUNTER-INIT" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Initial maximum allowed gap between two counter values of two consecutively received valid Data, i.e. how many subsequent lost data is accepted. For example, if the receiver gets Data with counter 1 and MaxDeltaCounterInit is 1, then at the next reception the receiver can accept Counters with values 2 and 3, but not 4.

            Note that if the receiver does not receive new Data at a consecutive read, then the receiver increments the tolerance by 1.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndDescription.maxDeltaCounterInit";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="-70"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CRC-OFFSET" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Bit offset of CRC from the beginning of the Array representation of the Signal Group/DataElementPrototype (MSB order, bit numbering: bit 0 is the least important). The offset shall be a multiplicity of 8 and it should be 0 whenever possible. For example, offset 8 means that the CRC will take the byte 1, i.e. bits 8..15. If crcOffset is not present the value is defined by the selected profile.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndDescription.crcOffset";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="-60"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COUNTER-OFFSET" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Bit offset of Counter from the beginning of the Array representation of the Signal Group/DataElementPrototype (MSB order, bit numbering: bit 0 is the least important). The offset shall be a multiplicity of 4 and it should be 8 whenever possible. For example, offset 8 means that the counter will take the low nibble of the byte 1, i.e. bits 8 .. 11. If counterOffset is not present the value is defined by the selected profile.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndDescription.counterOffset";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="-50"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class EndToEndProtection::EndToEndDescription -->
   <xsd:complexType abstract="false" mixed="false" name="END-TO-END-DESCRIPTION">
      <xsd:annotation>
         <xsd:documentation>This meta-class contains information about end-to-end protection. The set of applicable attributes depends on the actual value of the category attribute of EndToEndProtection.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndDescription"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:END-TO-END-DESCRIPTION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class EndToEndProtection::EndToEndProtection -->
   <xsd:group name="END-TO-END-PROTECTION">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to describe a particular end to end protection.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndProtection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="END-TO-END-PROFILE" type="AR:END-TO-END-DESCRIPTION">
            <xsd:annotation>
               <xsd:documentation>This represents the particular EndToEndDescription.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndProtection.endToEndProfile";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="END-TO-END-PROTECTION-DATA-ELEMENT-PROTOTYPES">
            <xsd:annotation>
               <xsd:documentation>Defines to which DataElementPrototypes in the roles of one sender and one or more receivers this EndToEndprotection shall apply.

            In case several senders are defined to transport the data there may exist several EndToEndProtectionDataElementPrototype elements.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndProtection.endToEndProtectionDataElementPrototype";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="END-TO-END-PROTECTION-DATA-ELEMENT-PROTOTYPE" type="AR:END-TO-END-PROTECTION-DATA-ELEMENT-PROTOTYPE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="END-TO-END-PROTECTION-I-SIGNAL-I-PDUS">
            <xsd:annotation>
               <xsd:documentation>Defines to which ISignalIPdu - ISignal pair this EndToEndProtection shall apply.

            In case several ISignals are used to transport the data (e.g. fan-out in the RTE) there may exist several EndToEndProtectionISignalIPdu definitions.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndProtection.endToEndProtectionISignalIPdu";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="END-TO-END-PROTECTION-I-SIGNAL-I-PDU" type="AR:END-TO-END-PROTECTION-I-SIGNAL-I-PDU"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class EndToEndProtection::EndToEndProtection -->
   <xsd:complexType abstract="false" mixed="false" name="END-TO-END-PROTECTION">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to describe a particular end to end protection.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndProtection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:END-TO-END-PROTECTION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class EndToEndProtection::EndToEndProtectionDataElementPrototype -->
   <xsd:group name="END-TO-END-PROTECTION-DATA-ELEMENT-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>It is possible to protect the data exchanged between software components. For this purpose, for each communication to be protected,  the user defines a separate EndToEndProtection (specifying a set of protection settings) and refers to a dataElement in the role of sender and to one or many dataElements in the role of receiver. For details, see End to End Library.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndProtectionDataElementPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="RECEIVER-IREFS">
            <xsd:annotation>
               <xsd:documentation>This represnets the receiver. Note that 1:n communication is supported for this use case.

            Can be optional if an ecu extract is provided and no receiver is part of the extract.
            This represnets the receiver. Note that 1:n communication is supported for this use case.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndProtectionDataElementPrototype.receiver";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="RECEIVER-IREF" type="AR:END-TO-END-PROTECTION-DATA-ELEMENT-PROTOTYPE--DATA-ELEMENT-IREF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SENDER-IREF" type="AR:END-TO-END-PROTECTION-DATA-ELEMENT-PROTOTYPE--DATA-ELEMENT-IREF">
            <xsd:annotation>
               <xsd:documentation>This represents the sender.

            Can be optional if an ecu extract is provided and the sender is part of the extract.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndProtectionDataElementPrototype.sender";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class EndToEndProtection::EndToEndProtectionDataElementPrototype -->
   <xsd:complexType abstract="false" mixed="false" name="END-TO-END-PROTECTION-DATA-ELEMENT-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>It is possible to protect the data exchanged between software components. For this purpose, for each communication to be protected,  the user defines a separate EndToEndProtection (specifying a set of protection settings) and refers to a dataElement in the role of sender and to one or many dataElements in the role of receiver. For details, see End to End Library.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndProtectionDataElementPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:END-TO-END-PROTECTION-DATA-ELEMENT-PROTOTYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class EndToEndProtection::EndToEndProtectionDataElementPrototype_dataElement -->
   <xsd:group name="END-TO-END-PROTECTION-DATA-ELEMENT-PROTOTYPE--DATA-ELEMENT-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndProtectionDataElementPrototype_dataElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="COMPONENT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndProtectionDataElementPrototype_dataElement.componentPrototype";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="10"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMPONENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PORT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndProtectionDataElementPrototype_dataElement.portPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="1" name="TARGET-DATA-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndProtectionDataElementPrototype_dataElement.targetDataPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.target</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:DATA-ELEMENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class EndToEndProtection::EndToEndProtectionDataElementPrototype_dataElement -->
   <xsd:complexType abstract="false" mixed="false" name="END-TO-END-PROTECTION-DATA-ELEMENT-PROTOTYPE--DATA-ELEMENT-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndProtectionDataElementPrototype_dataElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:END-TO-END-PROTECTION-DATA-ELEMENT-PROTOTYPE--DATA-ELEMENT-IREF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class EndToEndProtection::EndToEndProtectionISignalIPdu -->
   <xsd:group name="END-TO-END-PROTECTION-I-SIGNAL-I-PDU">
      <xsd:annotation>
         <xsd:documentation>It is possible to protect the inter-ECU data exchange of safety-related ISignal (refering to a SystemSignalGroup) at the level of COM IPdus using protection mechanisms provided by E2E Library. For each ISignal to be protected, a separate E2EProtectionISignalIPdu element must be created within the EndToEndProtectionSet. 

      The E2EProtectionISignalIPdu element refers to the ISignal that is to be protected and to the ISignalIPdu that transmits the protected ISignal. The information how the referenced ISignal shall be protected (through which E2E Profile and with which E2E settings) is defined in the EndToEndDescription element.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndProtectionISignalIPdu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-OFFSET" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>This attribute defines the beginning offset (in bits) of the Array representation of the Signal Group (including CRC, counter and application
            signal group) in the IPdu. This attribute is mandatory and the dataOffset shall always be defined.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndProtectionISignalIPdu.dataOffset";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="I-SIGNAL-GROUP-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the ISignal (representing a signal group) that is to be protected.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndProtectionISignalIPdu.iSignalGroup";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:I-SIGNAL--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="I-SIGNAL-I-PDU-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the SignalPdu that transmits the protected ISignal (group).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndProtectionISignalIPdu.iSignalIPdu";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SIGNAL-I-PDU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class EndToEndProtection::EndToEndProtectionISignalIPdu -->
   <xsd:complexType abstract="false" mixed="false" name="END-TO-END-PROTECTION-I-SIGNAL-I-PDU">
      <xsd:annotation>
         <xsd:documentation>It is possible to protect the inter-ECU data exchange of safety-related ISignal (refering to a SystemSignalGroup) at the level of COM IPdus using protection mechanisms provided by E2E Library. For each ISignal to be protected, a separate E2EProtectionISignalIPdu element must be created within the EndToEndProtectionSet. 

      The E2EProtectionISignalIPdu element refers to the ISignal that is to be protected and to the ISignalIPdu that transmits the protected ISignal. The information how the referenced ISignal shall be protected (through which E2E Profile and with which E2E settings) is defined in the EndToEndDescription element.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndProtectionISignalIPdu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:END-TO-END-PROTECTION-I-SIGNAL-I-PDU"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class EndToEndProtection::EndToEndProtectionSet -->
   <xsd:group name="END-TO-END-PROTECTION-SET">
      <xsd:annotation>
         <xsd:documentation>This represents a container for collection EndToEndProtectionInformation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndProtectionSet"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="END-TO-END-PROTECTIONS">
            <xsd:annotation>
               <xsd:documentation>This is one particular EndToEndProtection.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndProtectionSet.endToEndProtection";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="END-TO-END-PROTECTION" type="AR:END-TO-END-PROTECTION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class EndToEndProtection::EndToEndProtectionSet -->
   <xsd:complexType abstract="false" mixed="false" name="END-TO-END-PROTECTION-SET">
      <xsd:annotation>
         <xsd:documentation>This represents a container for collection EndToEndProtectionInformation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EndToEndProtectionSet"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:END-TO-END-PROTECTION-SET"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- complex type for class ECUCParameterDefTemplate::EnumerationLiteralDef -->
   <xsd:complexType abstract="false" mixed="false" name="ENUMERATION-LITERAL-DEF">
      <xsd:annotation>
         <xsd:documentation>Configuration parameter type for enumeration literals definition.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EnumerationLiteralDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUCParameterDefTemplate::EnumerationParamDef -->
   <xsd:group name="ENUMERATION-PARAM-DEF">
      <xsd:annotation>
         <xsd:documentation>Configuration parameter type for Enumeration.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EnumerationParamDef";xml.sequenceOffset="0"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DEFAULT-VALUE" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Default value of the enumeration configuration parameter. This string nees to be one of the literals specified for this enumeration.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EnumerationParamDef.defaultValue";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="LITERALS">
            <xsd:annotation>
               <xsd:documentation>Aggregation on the literals used to define this enumeration parameter.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="literal.EnumerationParamDef";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ENUMERATION-LITERAL-DEF" type="AR:ENUMERATION-LITERAL-DEF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::EnumerationParamDef -->
   <xsd:complexType abstract="false" mixed="false" name="ENUMERATION-PARAM-DEF">
      <xsd:annotation>
         <xsd:documentation>Configuration parameter type for Enumeration.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EnumerationParamDef";xml.sequenceOffset="0"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PARAM-CONF-MULTIPLICITY"/>
         <xsd:group ref="AR:COMMON-CONFIGURATION-ATTRIBUTES"/>
         <xsd:group ref="AR:CONFIG-PARAMETER"/>
         <xsd:group ref="AR:ENUMERATION-PARAM-DEF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUCDescriptionTemplate::EnumerationValue -->
   <xsd:group name="ENUMERATION-VALUE">
      <xsd:annotation>
         <xsd:documentation>Representing a configuration value of definition type EnumerationParamDef</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EnumerationValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VALUE" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Stores the chosen literal.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EnumerationValue.value";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCDescriptionTemplate::EnumerationValue -->
   <xsd:complexType abstract="false" mixed="false" name="ENUMERATION-VALUE">
      <xsd:annotation>
         <xsd:documentation>Representing a configuration value of definition type EnumerationParamDef</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EnumerationValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:PARAMETER-VALUE"/>
         <xsd:group ref="AR:ENUMERATION-VALUE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class BasicElements::ErrorDetectionCorrection -->
   <xsd:group name="ERROR-DETECTION-CORRECTION">
      <xsd:annotation>
         <xsd:documentation>Provides information on what extra bits are used for error detection and correction.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ErrorDetectionCorrection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CORRECTED-BITS" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>How many error bits can be corrected.
            Unit: Bit</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ErrorDetectionCorrection.correctedBits";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DETECTED-BITS" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>How many bit errors can be reconginsed.
            Unit: Bit</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ErrorDetectionCorrection.detectedBits";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EXTRA-BITS" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>How many extra bits are used for ensuring error detection and correction.
            Unit: Bit</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ErrorDetectionCorrection.extraBits";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BasicElements::ErrorDetectionCorrection -->
   <xsd:complexType abstract="false" mixed="false" name="ERROR-DETECTION-CORRECTION">
      <xsd:annotation>
         <xsd:documentation>Provides information on what extra bits are used for error detection and correction.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ErrorDetectionCorrection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:ERROR-DETECTION-CORRECTION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Timing::EventControlledTiming -->
   <xsd:group name="EVENT-CONTROLLED-TIMING">
      <xsd:annotation>
         <xsd:documentation>Specification of a event driven sending behavior. The PDU is sent n (numberOfRepeat + 1) times separated by the repetitionPeriod. If numberOfRepeats = 0, then the Pdu is sent just once.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EventControlledTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="NUMBER-OF-REPEATS" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Defines the number of repetitions for the Direct/N-Times transmission mode and the event driven part of Mixed transmission mode.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="EventControlledTiming.numberOfRepeats";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REPETITION-PERIOD" type="AR:TIME-RANGE-TYPE">
            <xsd:annotation>
               <xsd:documentation>If the EventControlledTiming is aggregated by the IPduTiming the repetitionPeriod specifies the time in seconds that elapses before the pdu can be sent the next time (Minimum repeat gap between two pdus).

            If the EventControlledTiming is aggregated by the SignalTriggering the repetitionPeriod specifies the time in seconds that elapses before the signal can be sent the next time (Minimum repeat gap between two signals).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="repetitionPeriod.EventControlledTiming";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Timing::EventControlledTiming -->
   <xsd:complexType abstract="false" mixed="false" name="EVENT-CONTROLLED-TIMING">
      <xsd:annotation>
         <xsd:documentation>Specification of a event driven sending behavior. The PDU is sent n (numberOfRepeat + 1) times separated by the repetitionPeriod. If numberOfRepeats = 0, then the Pdu is sent just once.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="EventControlledTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:EVENT-CONTROLLED-TIMING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- complex type for class InternalBehavior::ExclusiveArea -->
   <xsd:complexType abstract="false" mixed="false" name="EXCLUSIVE-AREA">
      <xsd:annotation>
         <xsd:documentation>Prevents an executable entity running in the area from being preempted.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ExclusiveArea"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="EXCLUSIVE-AREA--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="EXCLUSIVE-AREA"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="EXECUTABLE-ENTITY--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="BSW-INTERRUPT-ENTITY"/>
         <xsd:enumeration value="BSW-MODULE-ENTITY"/>
         <xsd:enumeration value="BSW-SCHEDULABLE-ENTITY"/>
         <xsd:enumeration value="RUNNABLE-ENTITY"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ExecutionTime::ExecutionTime -->
   <xsd:group name="EXECUTION-TIME">
      <xsd:annotation>
         <xsd:documentation>Base class for several means how to describe the ExecutionTime of software. The required context information is provided through this class.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ExecutionTime"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECU" type="AR:ECU-PROTOTYPE">
            <xsd:annotation>
               <xsd:documentation>Provides information on a ECUPrototype based on one ECU type.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ecu.ExecutionTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EXCLUSIVE-AREA-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the ExclusiveArea this execution time is provided for.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ExecutionTime.exclusiveArea";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:EXCLUSIVE-AREA--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EXTERNAL-LIBRARY-REFS">
            <xsd:annotation>
               <xsd:documentation>If this dependency is specified, the execution time of the library code is included in the execution time data for the runnable.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ExecutionTime.externalLibrary";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="EXTERNAL-LIBRARY-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:DEPENDENCY-ON-LIBRARY--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="HARDWARE-CONFIGURATION" type="AR:HARDWARE-CONFIGURATION">
            <xsd:annotation>
               <xsd:documentation>Provides information on the HardwareConfiguration used to specify this ExecutionTime.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="hardwareConfiguration.ExecutionTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MEMORY-SECTION-LOCATIONS">
            <xsd:annotation>
               <xsd:documentation>Provides information on the MemorySectionLocation which is involved in the ExecutionTime description.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="memorySectionLocation.ExecutionTime";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="MEMORY-SECTION-LOCATION" type="AR:MEMORY-SECTION-LOCATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RUNNABLE-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the runnable this execution time is provided for.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ExecutionTime.runnable";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:EXECUTABLE-ENTITY--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SOFTWARE-CONTEXT" type="AR:SOFTWARE-CONTEXT">
            <xsd:annotation>
               <xsd:documentation>Provides information on the detailed SoftwareContext used to provide the ExecutionTime description.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="softwareContext.ExecutionTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ExecutionTime::ExecutionTime -->
   <xsd:complexType abstract="false" mixed="false" name="EXECUTION-TIME">
      <xsd:annotation>
         <xsd:documentation>Base class for several means how to describe the ExecutionTime of software. The required context information is provided through this class.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ExecutionTime"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:EXECUTION-TIME"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="FIBEX-ELEMENT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CAN-CLUSTER"/>
         <xsd:enumeration value="COMMUNICATION-CLUSTER"/>
         <xsd:enumeration value="DCM-I-PDU"/>
         <xsd:enumeration value="ECU-INSTANCE"/>
         <xsd:enumeration value="FLEXRAY-CLUSTER"/>
         <xsd:enumeration value="FRAME"/>
         <xsd:enumeration value="GATEWAY"/>
         <xsd:enumeration value="I-PDU-GROUP"/>
         <xsd:enumeration value="I-SIGNAL"/>
         <xsd:enumeration value="LIN-CLUSTER"/>
         <xsd:enumeration value="MULTIPLEXED-I-PDU"/>
         <xsd:enumeration value="N-PDU"/>
         <xsd:enumeration value="NM-PDU"/>
         <xsd:enumeration value="PDUR-I-PDU-GROUP"/>
         <xsd:enumeration value="SIGNAL-I-PDU"/>
         <xsd:enumeration value="SUBSTITUTION-FRAME"/>
         <xsd:enumeration value="USER-DEFINED-I-PDU"/>
         <xsd:enumeration value="USER-DEFINED-PDU"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class FlexrayTopology::FlexRayCommunicationConnector -->
   <xsd:group name="FLEX-RAY-COMMUNICATION-CONNECTOR">
      <xsd:annotation>
         <xsd:documentation>FlexRay specific attributes to the CommunicationConnector</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexRayCommunicationConnector"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="WAKE-UP-CHANNEL" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Referenced channel used by the node to send a wakeup pattern. (pWakeupChannel)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexRayCommunicationConnector.wakeUpChannel";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class FlexrayTopology::FlexRayCommunicationConnector -->
   <xsd:complexType abstract="false" mixed="false" name="FLEX-RAY-COMMUNICATION-CONNECTOR">
      <xsd:annotation>
         <xsd:documentation>FlexRay specific attributes to the CommunicationConnector</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexRayCommunicationConnector"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COMMUNICATION-CONNECTOR"/>
         <xsd:group ref="AR:FLEX-RAY-COMMUNICATION-CONNECTOR"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class TransportProtocols::FlexRayTpConnection -->
   <xsd:group name="FLEX-RAY-TP-CONNECTION">
      <xsd:annotation>
         <xsd:documentation>A connection within a channel identifies the sender and the receiver of this particular communication.

      The FlexRayTp module routes a Pdu through this connection.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexRayTpConnection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DIRECT-TP-SDU-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the IPdu that is segmented by the Transport Protocol. 

            The source address of the transmitted NPdu is determined by the configured source CommunicationConnector.
            The target address of the transmitted NPdu is determined by the configured target CommunicationConnector.

            To support the low-level routing of NPdu's the NPdu is a specialization of an IPdu. More details can be found in the NPdu class description. Nevertheless the FlexRayTpConnection must not reference a NPdu with this tpSdu reference.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexRayTpConnection.directTpSdu";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:I-PDU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FLOW-CONTROL-PDU-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the  Flow Control NPdu.

            The Flow Control network protocol data unit (FC N_PDU) is identified by the Flow Control protocol control information (FC N_PCI). The Flow Control network protocol data unit (FC N_PDU) instructs a sending network entity to start, stop or resume transmission of CF N_PDUs. The Flow Control network protocol data unit shall be sent by the receiving network layer entity to the sending network layer entity, when ready to receive more data, after correct reception of:

            a) First Frame network protocol data unit (FF N_PDU) 
            b) the last Consecutive Frame network protocol data unit (CF N_PDU) of a block of Consecutive Frames (CF N_PDU) if further Consecutive Frame network protocol data unit (CF N_PDU) need(s) to be sent.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexRayTpConnection.flowControlPdu";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:N-PDU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MULTICAST-REF">
            <xsd:annotation>
               <xsd:documentation>TP address for 1:n connections.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexRayTpConnection.multicast";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:TP-ADDRESS--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REVERSED-TP-SDU-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the IPdu that is segmented by the Transport Protocol. 

            If support of both sending and receiving is used, this association references the IPdu used for the additional second direction.

            The source address of the transmitted NPdu is determined by the configured target CommunicationConnector.

            The target address of the transmitted NPdu is determined by the configured source CommunicationConnector.

            To support the low-level routing of NPdu's the NPdu is a specialization of an IPdu. More details can be found in the NPdu class description. Nevertheless the FlexRayTpConnection must not reference a NPdu with this tpSdu reference.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexRayTpConnection.reversedTpSdu";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:I-PDU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SOURCE-REF">
            <xsd:annotation>
               <xsd:documentation>The source of the TP connection.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexRayTpConnection.source";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:FLEXRAY-TP-NODE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TARGET-REFS">
            <xsd:annotation>
               <xsd:documentation>The target of the TP connection.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexRayTpConnection.target";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="TARGET-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:FLEXRAY-TP-NODE--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TRANSMIT-PDU-REFS">
            <xsd:annotation>
               <xsd:documentation>Reference to an NPdu (Single Frame, First Frame or Consecutive Frame).

            The Single Frame network protocol data unit (SF N_PDU) shall be sent out by the sending network entity and can be received by one or multiple receiving network entities.
            The Single Frame (SF N_PDU) shall be sent out to transfer a service data unit that can be transferred via a single service request to the data link layer. This network protocol data unit shall be sent to transfer unsegmented messages.

            The First Frame network protocol data unit (FF N_PDU) identifies the first network protocol data unit (N_PDU) of a segmented message transmitted by a network sending entity and received by a receiving network entity. 

            The Consecutive Frame network protocol data unit (CF N_PDU) transfers segments (N_Data) of the service data unit message data (&amp;lt;MessageData&amp;gt;). All network protocol data units (N_PDUs) transmitted by the sending entity after the First Frame network protocol data unit (FF N_PDU) shall be encoded as Consecutive Frames network protocol data units (CF N_PDUs).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexRayTpConnection.transmitPdu";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="TRANSMIT-PDU-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:N-PDU--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TransportProtocols::FlexRayTpConnection -->
   <xsd:complexType abstract="false" mixed="false" name="FLEX-RAY-TP-CONNECTION">
      <xsd:annotation>
         <xsd:documentation>A connection within a channel identifies the sender and the receiver of this particular communication.

      The FlexRayTp module routes a Pdu through this connection.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexRayTpConnection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:FLEX-RAY-TP-CONNECTION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class FlexrayTopology::FlexrayCluster -->
   <xsd:group name="FLEXRAY-CLUSTER">
      <xsd:annotation>
         <xsd:documentation>FlexRay specific attributes to the physicalCluster</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ACTION-POINT-OFFSET" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The offset of the action point in networks</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.actionPointOffset";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="BIT" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Nominal bit time (= 1 / fx:SPEED). gdBit = cSamplesPerBit * gdSampleClockPeriod. Unit: seconds (gdBit)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.bit";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="BUS-GUARDIAN-ENABLE-PART" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Bus Guardian Inter Slot Gap (ISG) part that follows a guarded schedule element. Unit macroticks</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.busGuardianEnablePart";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CAS-RX-LOW-MAX" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Upper limit of the Collision Avoidance Symbol (CAS) acceptance window. Unit:bitDuration</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.casRxLowMax";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CAS-RX-LOW-MIN" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Lower limit of the Collision Avoidance Symbol (CAS) acceptance window. Unit:bitDuration</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.casRxLowMin";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COLD-START-ATTEMPTS" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The maximum number of times that a node in this cluster is permitted to attempt to start the cluster by initiating schedule synchronization</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.coldStartAttempts";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CYCLE" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Length of the cycle. Unit: seconds</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.cycle";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CYCLE-COUNT-MAX" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Maximum cycle counter value in a given cluster. Remark: Set to 63 for FlexRay Protocol 2.1 Rev. A compliance.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.cycleCountMax";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DYNAMIC-SLOT-IDLE-PHASE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The duration of the dynamic slot idle phase in minislots.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.dynamicSlotIdlePhase";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="IGNORE-AFTER-TX" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Duration for which the bitstrobing is paused after transmission [gdBit].</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.ignoreAfterTx";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="LISTEN-NOISE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Upper limit for the start up and wake up listen timeout in the presence of noise. Expressed as a multiple of the cluster constant pdListenTimeout. Unit microticks</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.listenNoise";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MACRO-INITIAL-OFFSET" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>number of macroticks which describe the distance between the static slot boundary and the closed macrotick boundary of the secondary time reference point using the initial configured macrotick length</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.macroInitialOffset";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MACRO-PER-CYCLE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The number of macroticks in a communication cycle</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.macroPerCycle";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MACROTICK-DURATION" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Duration of the cluster wide nominal macrotick, expressed in seconds</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.macrotickDuration";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-INITIALISATION-ERROR" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>The maximum error that a node may have after initialization. Unit: seconds</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.maxInitialisationError";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-PROPAGATION-DELAY" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Maximum propagation delay of a Cluster (in seconds).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.maxPropagationDelay";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-WITHOUT-CLOCK-CORRECTION-FATAL" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Threshold concerning vClockCorrectionFailedCounter. Defines the number of consecutive even/odd Cycle pairs with missing clock correction terms that will cause the protocol to transition from the POC:normal active or POC:normal passive state into the POC:halt state.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.maxWithoutClockCorrectionFatal";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-WITHOUT-CLOCK-CORRECTION-PASSIVE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Threshold concerning vClockCorrectionFailedCounter. Defines the number of consecutive even/odd Cycle pairs with missing clock correction terms that will cause the protocol to transition from the POC:normal active state to the POC:normal passive state.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.maxWithoutClockCorrectionPassive";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MIN-PROPAGATION-DELAY" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Minimum propagation delay of a Cluster (in seconds).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.minPropagationDelay";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MINISLOT-ACTION-POINT-OFFSET" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The Offset of the action point within a minislot. Unit: macroticks</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.minislotActionPointOffset";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MINISLOT-DURATION" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The duration of a minislot (dynamic segment). Unit: macroticks.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.minislotDuration";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NETWORK-IDLE-TIME" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The duration of the network idle time in macroticks</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.networkIdleTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NETWORK-MANAGEMENT-VECTOR-LENGTH" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Length of the Network Management vector on a cluster. Unit: Bytes</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.networkManagementVectorLength";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-DATA-CYCLE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Number of FlexRay Communication Cycles needed to transmit the Nm Data PDUs of  all FlexRay Nm Ecus of this FlexRayNmCluster.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.nmDataCycle";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-READY-SLEEP-COUNT" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Numbers of repetitions in the ready sleep state before NM switches to bus sleep mode. On a value of "1", the NM-State Machine will leave the Ready Sleep State after one NM Repetition Cycle with no "keep awake" votes.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.nmReadySleepCount";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-REMOTE-SLEEP-INDICATION-TIME" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Timeout for Remote Sleep Indication in seconds. It defines the time how long it shall take to recognize that all other nodes are ready to sleep.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.nmRemoteSleepIndicationTime";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-REPEAT-MESSAGE-TIME" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Timeout for Repeat Message State in seconds. Defines the time how long the NM shall stay in the Repeat Message State.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.nmRepeatMessageTime";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-REPETITION-CYCLE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Number of FlexRay Communication Cycles used to repeat the transmission of the Nm vote PDUs of all FlexRay NmEcus of this FlexRayNmCluster.  This value must be an integral multiple of nmVotingCycle.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.nmRepetitionCycle";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-VOTING-CYCLE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Number of FlexRay CommunicationCycles needed to transmit the Nm vote of Pdus of all FlexRay NmEcus of this FlexRayNmCluster.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.nmVotingCycle";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NUMBER-OF-CYCLES" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Total number of cycles until a temporal transmission pattern is repeated. The CycleCounter of an AbsolutelyScheduledTiming is evaluated against this parameter.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.numberOfCycles";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NUMBER-OF-MINISLOTS" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>number of Minislots in the dynamic segment.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.numberOfMinislots";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NUMBER-OF-STATIC-SLOTS" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The number of static slots in the static segment.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.numberOfStaticSlots";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="OFFSET-CORRECTION-MAX" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Cluster global magnitude of the maximum permissible offset correction value Unit: seconds (gOffsetCorrectionMax)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.offsetCorrectionMax";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="OFFSET-CORRECTION-START" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Start of the offset correction phase within the Network Idle Time (NIT), expressed as the number of macroticks from the start of cycle. Unit: macroticks</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.offsetCorrectionStart";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PAYLOAD-LENGTH-STATIC" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Globally configured payload length of a static frame. Unit: 16-bit WORDS.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.payloadLengthStatic";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SAMPLE-CLOCK-PERIOD" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Sample clock period. Unit: seconds</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.sampleClockPeriod";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="STATIC-SLOT-DURATION" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The duration of a slot in the static segment. Unit: macroticks</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.staticSlotDuration";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYMBOL-WINDOW" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The duration of the symbol window. Unit: macroticks</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.symbolWindow";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYMBOL-WINDOW-ACTION-POINT-OFFSET" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Number of macroticks the action point offset is from the beginning of the symbol window [Macroticks].</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.symbolWindowActionPointOffset";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYNC-FRAME-ID-COUNT-MAX" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Maximum number of distinct syncframe identifiers present in a given cluster. This parameter maps to FlexRay Protocol 2.1  Rev. A parameter gSyncNodeMax.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.syncFrameIDCountMax";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TRANSMISSION-START-SEQUENCE-DURATION" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Number of bits in the Transmission Start Sequence [gdBits].</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.transmissionStartSequenceDuration";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="WAKEUP-RX-IDLE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Number of bits used by the node to test the duration of the 'idle' or HIGH phase of a received wakeup. 
            Unit:bitDuration
            Remarks: This parameter maps to FlexRay Protocol 2.1 Rev. A parameter gdWakeupSymbolRxIdle.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.wakeupRxIdle";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="WAKEUP-RX-LOW" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Number of bits used by the node to test the duration of the LOW phase of a received wakeup. Unit:bitDuration 
            Remarks: This parameter maps to FlexRay Protocol 2.1 Rev. A parameter gdWakeupSymbolRxLow.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.wakeupRxLow";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="WAKEUP-RX-WINDOW" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The size of the window used to detect wakeups [gdBit]. 
            Remarks: This parameter maps to FlexRay Protocol 2.1 Rev. A parameter gdWakeupSymbolRxWindow.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.wakeupRxWindow";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="WAKEUP-TX-ACTIVE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Number of bits used by the node to transmit the LOW phase of awakeup symbol and  the HIGH and LOW phases of a WUDOP. Unit:bitDuration. Remarks: This parameter maps to FlexRay Protocol 2.1 Rev. A parameter gdWakeupSymbolTxLow.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.wakeupTxActive";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="WAKEUP-TX-IDLE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Number of bits used by the node to transmit the 'idle' part of a
            wakeup symbol. Unit: gDbit.
            Remarks: This parameter maps to FlexRay Protocol 2.1 Rev. A parameter gdWakeupSymbolTxIdle.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster.wakeupTxIdle";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class FlexrayTopology::FlexrayCluster -->
   <xsd:complexType abstract="false" mixed="false" name="FLEXRAY-CLUSTER">
      <xsd:annotation>
         <xsd:documentation>FlexRay specific attributes to the physicalCluster</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCluster"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COMMUNICATION-CLUSTER"/>
         <xsd:group ref="AR:FLEXRAY-CLUSTER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class FlexrayTopology::FlexrayCommunicationController -->
   <xsd:group name="FLEXRAY-COMMUNICATION-CONTROLLER">
      <xsd:annotation>
         <xsd:documentation>FlexRay bus specific communication port attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ACCEPTED-STARTUP-RANGE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Expanded range of measured clock deviation allowed for startup frames during integration. Unit:microtick</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.acceptedStartupRange";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ALLOW-HALT-DUE-TO-CLOCK" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Boolean flag that controls the transition to the POC:halt state due to a clock synchronization errors. 
            If set to true, the Communication Controller is allowed to transition to POC:halt. 
            If set to false, the Communication Controller will not transition to the POC:halt state but will enter or remain in the normal POC (passive State).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.allowHaltDueToClock";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ALLOW-PASSIVE-TO-ACTIVE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Number of consecutive even/odd cycle pairs that must have valid clock correction terms before the Communication Controller will be allowed to transition from the POC:normal passive state to POC:normal active state. If set to 0, the Communication Controller is not allowed to transition from POC:norm</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.allowPassiveToActive";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CLUSTER-DRIFT-DAMPING" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The cluster drift damping factor used in clock synchronization rate correction in microticks</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.clusterDriftDamping";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DECODING-CORRECTION" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Value used by the receiver to calculate the difference between primary time reference point and secondary time reference point. Unit: Microticks (pDecodingCorrection)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.decodingCorrection";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DELAY-COMPENSATION-A" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Value used to compensate for reception delays on channel A Unit: Microticks
            This optional parameter shall only be filled out if channel A is used.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.delayCompensationA";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DELAY-COMPENSATION-B" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Value used to compensate for reception delays on channel B. Unit: Microticks
            This optional parameter shall only be filled out if channel B is used.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.delayCompensationB";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DYNAMIC-SEGMENT-ENABLE" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Boolean flag that configures the Bus Guardian Schedule
            Monitoring Service to expect transmissions within
            the dynamic segment.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.dynamicSegmentEnable";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EXTERN-OFFSET-CORRECTION" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Fixed amount added or subtracted to the calculated offset correction term to facilitate external offset correction, expressed in node-local microticks.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.externOffsetCorrection";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EXTERN-RATE-CORRECTION" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Fixed amount added or subtracted to the calculated rate correction term to facilitate external rate correction, expressed in node-local microticks.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.externRateCorrection";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EXTERNAL-SYNC" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Flag indicating whether the node is externally synchronized (operating as Time Gateway Sink in an TT-E Time Triggered External Sync cluster) or locally synchronized.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.externalSync";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FALL-BACK-INTERNAL" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Flag indicating whether a Time Gateway Sink node will switch to local clock operation when synchronization with the Time Gateway Source node is lost (pFallBackInternal = true) or will instead go to POC:ready (pFallBackInternal = false).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.fallBackInternal";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FLEXRAY-FIFOS">
            <xsd:annotation>
               <xsd:documentation>One First In First Out (FIFO) queued receive structure, defining the admittance criteria to the FIFO.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="flexrayFifo.FlexrayCommunicationController";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="FLEXRAY-FIFO-CONFIGURATION" type="AR:FLEXRAY-FIFO-CONFIGURATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="KEY-SLOT-ID" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>ID of the slot used to transmit the startup frame, sync frame, or designated single slot frame.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.keySlotID";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="KEY-SLOT-ONLY-ENABLED" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Flag indicating whether or not the node shall enter key slot only mode following startup.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.keySlotOnlyEnabled";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="KEY-SLOT-USED-FOR-START-UP" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Flag indicating whether the Key Slot is used to transmit a startup frame.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.keySlotUsedForStartUp";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="KEY-SLOT-USED-FOR-SYNC" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Flag indicating whether the Key Slot is used to transmit a sync frame.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.keySlotUsedForSync";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="LATEST-TX" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The number of the last minislot in which a transmission can start in the dynamic segment for the respective node</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.latestTX";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="LISTEN-TIMEOUT" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Upper limit for the start up listen timeout and wake up listen timeout. Unit: Microticks</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.listenTimeout";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MACRO-INITIAL-OFFSET-A" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Integer number of macroticks between the static slot boundary and the closest macrotick boundary of the secondary time reference point based on the nominal macrotick duration. (pMacroInitialOffset)
            This optional parameter shall only be filled out if channel A is used.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.macroInitialOffsetA";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MACRO-INITIAL-OFFSET-B" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Integer number of macroticks between the static slot boundary and the closest macrotick boundary of the secondary time reference point based on the nominal macrotick duration. (pMacroInitialOffset)
            This optional parameter shall only be filled out if channel B is used.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.macroInitialOffsetB";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAXIMUM-DYNAMIC-PAYLOAD-LENGTH" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Maximum payload length for the dynamic channel of a frame in 16 bit WORDS.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.maximumDynamicPayloadLength";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MICRO-INITIAL-OFFSET-A" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Number of microticks between the closest macrotick boundary described by gMacroInitialOffset and the secondary time reference point.  The parameter depends on pDelayCompensationA and therefore it has to be set independently for each channel.
            This optional parameter shall only be filled out if channel A is used.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.microInitialOffsetA";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MICRO-INITIAL-OFFSET-B" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Number of microticks between the closest macrotick boundary described by gMacroInitialOffset and the secondary time reference point.  The parameter depends on pDelayCompensationB and therefore it has to be set independently for each channel. 
            This optional parameter shall only be filled out if channel B is used.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.microInitialOffsetB";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MICRO-PER-CYCLE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The nominal number of microticks in a communication cycle</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.microPerCycle";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MICRO-PER-MACRO-NOM" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Number of microticks per nominal macrotick that all implementations must support.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.microPerMacroNom";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MICROTICK-DURATION" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Duration of a microtick. This attribute can be derived from samplePerMicrotick and gdSampleClockPeriod. 
            Unit: seconds</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.microtickDuration";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-CONTROL-BIT-VECTOR-ENABLED" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Enables control bit vector support.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.nmControlBitVectorEnabled";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-NODE-DETECTION-ENABLED" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Enables the Request Repeat Message Request support. Only valid if nmNodeIdEnabled is set to true.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.nmNodeDetectionEnabled";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-SOURCE-NODE-IDENTIFIER-ENABLED" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Switch for enabling SourceNodeIdentifier support.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.nmSourceNodeIdentifierEnabled";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-USER-DATA-ENABLED" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Switch for enabling user data support.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.nmUserDataEnabled";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-VECTOR-EARLY-UPDATE" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Flag indicating when the update of the Network Management Vector in the CHI shall take place. If set to false, the update shall take place after the NIT. If set to true, the update shall take place after the end of the static segment.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.nmVectorEarlyUpdate";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="OFFSET-CORRECTION-OUT" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Magnitude of the maximum permissible offset correction value. Unit:microtick (pOffsetCorrectionOut)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.offsetCorrectionOut";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RATE-CORRECTION-OUT" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Magnitude of the maximum permissible rate correction value and the maximum drift offset between two nodes operating with unsynchronized clocks for one communication cycle. Unit:Microticks (pRateCorrectionOut)

            Remarks: This parameter maps to FlexRay 
            Protocol 2.1 Rev. A parameter pdMaxDrift.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.rateCorrectionOut";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SAMPLES-PER-MICROTICK" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Number of samples per microtick</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.samplesPerMicrotick";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SECOND-KEY-SLOT-ID" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>ID of the second Key slot, in which a second startup frame shall be sent in TT-L Time Triggered Local Master Sync or TT-E Time Triggered External Sync mode. If this parameter is set to zero the node does not have a second key slot.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.secondKeySlotId";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="START-UP-NODE" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Indicates that the node is a startup node (startup frame configured; connected to gChannels)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.startUpNode";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYNC-SLOT" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The number of the static slot in which a sync frame shall be sent, if a sync frame shall be sent</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.syncSlot";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TWO-KEY-SLOT-MODE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Flag indicating whether node operates as a startup node in a TT-E Time Triggered External Sync or TT-L Time Triggered Local Master Sync cluster.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.twoKeySlotMode";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="WAKE-UP-PATTERN" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Number of repetitions of the Tx-wakeup symbol to be sent during the CC_WakeupSend state of this Node in the cluster</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController.wakeUpPattern";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class FlexrayTopology::FlexrayCommunicationController -->
   <xsd:complexType abstract="false" mixed="false" name="FLEXRAY-COMMUNICATION-CONTROLLER">
      <xsd:annotation>
         <xsd:documentation>FlexRay bus specific communication port attributes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayCommunicationController"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COMMUNICATION-CONTROLLER"/>
         <xsd:group ref="AR:FLEXRAY-COMMUNICATION-CONTROLLER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class FlexrayTopology::FlexrayFifoConfiguration -->
   <xsd:group name="FLEXRAY-FIFO-CONFIGURATION">
      <xsd:annotation>
         <xsd:documentation>One First In First Out (FIFO) queued receive structure, defining the admittance criteria to the FIFO, and mandating the ability to admit messages into the FIFO based on Message Id filtering criteria.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayFifoConfiguration"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ADMIT-WITHOUT-MESSAGE-ID" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Boolean configuration which determines whether or not frames received in the dynamic segment that don't contain a message ID will be admitted into the FIFO.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayFifoConfiguration.admitWithoutMessageId";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="BASE-CYCLE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>FIFO cycle counter acceptance criteria.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayFifoConfiguration.baseCycle";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CHANNEL-REFS">
            <xsd:annotation>
               <xsd:documentation>Fifo channel admittance criteria.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayFifoConfiguration.channel";pureMM.maxOccurs="2";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="2" minOccurs="0">
                  <xsd:element name="CHANNEL-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:FLEXRAY-PHYSICAL-CHANNEL--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CYCLE-REPETITION" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>FIFO cycle counter acceptance criteria.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayFifoConfiguration.cycleRepetition";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FIFO-DEPTH" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Fifo Depth.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayFifoConfiguration.fifoDepth";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FIFO-RANGES">
            <xsd:annotation>
               <xsd:documentation>FIFO Frame Id range acceptance criteria.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="fifoRange.FlexrayFifoConfiguration";pureMM.maxOccurs="-1";pureMM.minOccurs="2"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="FLEXRAY-FIFO-RANGE" type="AR:FLEXRAY-FIFO-RANGE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MSG-ID-MASK" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>FIFO message identifier acceptance criteria (Mask filter).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayFifoConfiguration.msgIdMask";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MSG-ID-MATCH" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>FIFO message identifier acceptance criteria (Match filter).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayFifoConfiguration.msgIdMatch";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class FlexrayTopology::FlexrayFifoConfiguration -->
   <xsd:complexType abstract="false" mixed="false" name="FLEXRAY-FIFO-CONFIGURATION">
      <xsd:annotation>
         <xsd:documentation>One First In First Out (FIFO) queued receive structure, defining the admittance criteria to the FIFO, and mandating the ability to admit messages into the FIFO based on Message Id filtering criteria.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayFifoConfiguration"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:FLEXRAY-FIFO-CONFIGURATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class FlexrayTopology::FlexrayFifoRange -->
   <xsd:group name="FLEXRAY-FIFO-RANGE">
      <xsd:annotation>
         <xsd:documentation>FIFO Frame Id range acceptance criteria.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayFifoRange"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="RANGE-MAX" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Max Range.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayFifoRange.rangeMax";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RANGE-MIN" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Min Range.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayFifoRange.rangeMin";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class FlexrayTopology::FlexrayFifoRange -->
   <xsd:complexType abstract="false" mixed="false" name="FLEXRAY-FIFO-RANGE">
      <xsd:annotation>
         <xsd:documentation>FIFO Frame Id range acceptance criteria.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayFifoRange"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:FLEXRAY-FIFO-RANGE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class FlexrayCommunication::FlexrayFrameTriggering -->
   <xsd:group name="FLEXRAY-FRAME-TRIGGERING">
      <xsd:annotation>
         <xsd:documentation>FlexRay specific attributes to the FrameTriggering</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayFrameTriggering"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ABSOLUTELY-SCHEDULED-TIMINGS">
            <xsd:annotation>
               <xsd:documentation>Specification of a sending behaviour where the exact time for the frames transmission is guaranteed.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="absolutelyScheduledTiming.FlexrayFrameTriggering";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ABSOLUTELY-SCHEDULED-TIMING" type="AR:ABSOLUTELY-SCHEDULED-TIMING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PAYLOAD-PREAMBLE-INDICATOR" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Switching the Payload Preamble bit.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayFrameTriggering.payloadPreambleIndicator";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class FlexrayCommunication::FlexrayFrameTriggering -->
   <xsd:complexType abstract="false" mixed="false" name="FLEXRAY-FRAME-TRIGGERING">
      <xsd:annotation>
         <xsd:documentation>FlexRay specific attributes to the FrameTriggering</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayFrameTriggering"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:FRAME-TRIGGERING"/>
         <xsd:group ref="AR:FLEXRAY-FRAME-TRIGGERING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class TransportProtocols::FlexrayIsoTpConnection -->
   <xsd:group name="FLEXRAY-ISO-TP-CONNECTION">
      <xsd:annotation>
         <xsd:documentation>A connection identifies the sender and the receiver of this particular communication. The FlexRayIsoTp module routes a Pdu through this connection. 

      In a System Description the references to the PduPools are mandatory. In an ECU Extract these references can be optional:
      On unicast connections these references are always mandatory.
      On multicast the txPduPool is mandatory on the sender side. The rxPduPool is mandatory on the receiver side. On Gateway ECUs both references are mandatory.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayIsoTpConnection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BANDWIDTH-LIMITATION" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Specifies whether the connection requires a  bandwidth limitation or not.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayIsoTpConnection.bandwidthLimitation";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DIRECT-TP-SDU-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the IPdu that is segmented by the Transport Protocol. 

            To support the low-level routing of NPdu's the NPdu is a specialization of an IPdu. More details can be found in the NPdu class description. Nevertheless the FlexrayIsoTpConnection must not reference a NPdu with this tpSdu reference.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayIsoTpConnection.directTpSdu";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:I-PDU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MULTICAST-REF">
            <xsd:annotation>
               <xsd:documentation>TP address for 1:n connections.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayIsoTpConnection.multicast";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:TP-ADDRESS--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RECEIVER-REFS">
            <xsd:annotation>
               <xsd:documentation>The target of the TP connection.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayIsoTpConnection.receiver";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="RECEIVER-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:FLEXRAY-ISO-TP-NODE--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REVERSED-TP-SDU-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the IPdu that is segmented by the Transport Protocol. If support of both sending and receiving is used, this association references the IPdu used for the additional second direction.

            To support the low-level routing of NPdu's the NPdu is a specialization of an IPdu. More details can be found in the NPdu class description. Nevertheless the FlexrayIsoTpConnection must not reference a NPdu with this tpSdu reference.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayIsoTpConnection.reversedTpSdu";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:I-PDU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RX-PDU-POOL-REF">
            <xsd:annotation>
               <xsd:documentation>A connection has a reference to a set of NPdus (FrTpRxPduPool) which are defined for receiving data via this particular connection.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayIsoTpConnection.rxPduPool";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:FLEXRAY-ISO-TP-PDU-POOL--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TP-CONNECTION-CONTROL-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the connection control.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayIsoTpConnection.tpConnectionControl";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:FLEXRAY-ISO-TP-CONNECTION-CONTROL--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TRANSMITTER-REF">
            <xsd:annotation>
               <xsd:documentation>The source of the TP connection.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayIsoTpConnection.transmitter";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:FLEXRAY-ISO-TP-NODE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TX-PDU-POOL-REF">
            <xsd:annotation>
               <xsd:documentation>A connection has a reference to a set of NPdus (FrTpTxPduPool) which are defined for sending data via this particular connection.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayIsoTpConnection.txPduPool";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:FLEXRAY-ISO-TP-PDU-POOL--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TransportProtocols::FlexrayIsoTpConnection -->
   <xsd:complexType abstract="false" mixed="false" name="FLEXRAY-ISO-TP-CONNECTION">
      <xsd:annotation>
         <xsd:documentation>A connection identifies the sender and the receiver of this particular communication. The FlexRayIsoTp module routes a Pdu through this connection. 

      In a System Description the references to the PduPools are mandatory. In an ECU Extract these references can be optional:
      On unicast connections these references are always mandatory.
      On multicast the txPduPool is mandatory on the sender side. The rxPduPool is mandatory on the receiver side. On Gateway ECUs both references are mandatory.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayIsoTpConnection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:FLEXRAY-ISO-TP-CONNECTION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class TransportProtocols::FlexrayIsoTpConnectionControl -->
   <xsd:group name="FLEXRAY-ISO-TP-CONNECTION-CONTROL">
      <xsd:annotation>
         <xsd:documentation>Configuration parameters to control a FlexRay TP connection.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayIsoTpConnectionControl"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ACK-TYPE" type="AR:TP-ACK-TYPE">
            <xsd:annotation>
               <xsd:documentation>This parameter defines the type of acknowledgement which is used for the specific channel. For FlexrayIsoTp only noAck and ackWithRt shall be used.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayIsoTpConnectionControl.ackType";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-AR" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>This parameter defines the maximum number of trying to send a frame when a TIMEOUT AR occurs (depending on whether retry is configured).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayIsoTpConnectionControl.maxAr";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-AS" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>This parameter defines the maximum number of trying to send a frame when a TIMEOUT AS occurs (depending on whether retry is configured)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayIsoTpConnectionControl.maxAs";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-BUFFER-SIZE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>This parameter is only relevant when having retry activated. It limits the maximal buffer size the FrTp can choose in order to limit the amount of Tx buffer that will be requested at the sender side in a segmented transfer.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayIsoTpConnectionControl.maxBufferSize";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-FC-WAIT" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>This attribute defines the maximum number of FlowControl N-PDUs with FlowState "WAIT".</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayIsoTpConnectionControl.maxFcWait";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-FR-IF" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>This parameter defines the maximum number of trying to send a frame when the FrIf returns an error</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayIsoTpConnectionControl.maxFrIf";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-NUMBER-OF-NPDU-PER-CYCLE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>This parameter limits the number of N-Pdus the sender is allowed to transmit within a FlexRay cycle.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayIsoTpConnectionControl.maxNumberOfNpduPerCycle";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-RETRIES" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>This parameter defines the maximum number of retries (if retry is configured for the particular channel).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayIsoTpConnectionControl.maxRetries";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SEPARATION-CYCLE-EXPONENT" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Exponent to calculate the minimum number of "Separation Cycles" the sender has to wait for the next transmission of an FrTp N-Pdu.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayIsoTpConnectionControl.separationCycleExponent";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIME-BR" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Time (in seconds) until transmission of the next FlowControl N-PDU.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayIsoTpConnectionControl.timeBr";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIME-BUFFER" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>This parameter defines the time of waiting for the next try to get a Tx or Rx buffer.

            This parameter is equivalent to the temporal distance between two FC.WT N-Pdus in case the buffer request returns busy.

            Specified in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayIsoTpConnectionControl.timeBuffer";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIME-FR-IF" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>This parameter defines the time of waiting for the next try to send. Specified in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayIsoTpConnectionControl.timeFrIf";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMEOUT-AR" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>This parameter states the timeout between the PDU transmit request of the Transport Layer to the FlexRay Interface and the corresponding confirmation of the FlexRay Interface on the receiver side (for FC or AF). Specified in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayIsoTpConnectionControl.timeoutAr";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMEOUT-AS" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>This attribute states the timeout between the PDU transmit request for the first PDU of the group used in the current connection of the Transport Layer to the FlexRay Interface and the corresponding confirmation of the FlexRay Interface (when having sent the last PDU of the group used in this connection) on the sender side (SF-x, FF-x, CF or FC (in case of Transmit Cancellation)). Specified in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayIsoTpConnectionControl.timeoutAs";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMEOUT-BS" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>This parameter defines the timeout in seconds for waiting for an FC or AF on the sender side in a 1:1 connection.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayIsoTpConnectionControl.timeoutBs";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMEOUT-CR" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>This parameter defines the timeout value in seconds for waiting for a CF or FF-x (in case of retry) after receiving the last CF or after sending an FC or AF on the receiver side. Specified in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayIsoTpConnectionControl.timeoutCr";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TransportProtocols::FlexrayIsoTpConnectionControl -->
   <xsd:complexType abstract="false" mixed="false" name="FLEXRAY-ISO-TP-CONNECTION-CONTROL">
      <xsd:annotation>
         <xsd:documentation>Configuration parameters to control a FlexRay TP connection.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayIsoTpConnectionControl"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:FLEXRAY-ISO-TP-CONNECTION-CONTROL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="FLEXRAY-ISO-TP-CONNECTION-CONTROL--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="FLEXRAY-ISO-TP-CONNECTION-CONTROL"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class TransportProtocols::FlexrayIsoTpEcu -->
   <xsd:group name="FLEXRAY-ISO-TP-ECU">
      <xsd:annotation>
         <xsd:documentation>ECU specific TP configuration parameters. Each TpEcu element has a reference to exactly one ECUInstance in the topology.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayIsoTpEcu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CYCLE-TIME-MAIN-FUNCTION" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>The period between successive calls to the Main Function of the AUTOSAR TP. Specified in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayIsoTpEcu.cycleTimeMainFunction";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECU-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>Connection to the ECUInstance in the Topology.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayIsoTpEcu.ecuInstance";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ECU-INSTANCE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FULL-DUPLEX-ENABLED" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>The full duplex mechanisms is enabled if this attribute is set to true. Otherwise half duplex is enabled.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayIsoTpEcu.fullDuplexEnabled";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TransportProtocols::FlexrayIsoTpEcu -->
   <xsd:complexType abstract="false" mixed="false" name="FLEXRAY-ISO-TP-ECU">
      <xsd:annotation>
         <xsd:documentation>ECU specific TP configuration parameters. Each TpEcu element has a reference to exactly one ECUInstance in the topology.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayIsoTpEcu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:FLEXRAY-ISO-TP-ECU"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- complex type for class TransportProtocols::FlexrayIsoTpNode -->
   <xsd:complexType abstract="false" mixed="false" name="FLEXRAY-ISO-TP-NODE">
      <xsd:annotation>
         <xsd:documentation>TP Node (Sender or Receiver) provides the TP Address and the connection to the Topology description.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayIsoTpNode"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:TP-NODE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="FLEXRAY-ISO-TP-NODE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="FLEXRAY-ISO-TP-NODE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class TransportProtocols::FlexrayIsoTpPduPool -->
   <xsd:group name="FLEXRAY-ISO-TP-PDU-POOL">
      <xsd:annotation>
         <xsd:documentation>FlexrayTpPduPool is a set of N-PDUs which are defined for FrTp sending or receiving purpose.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayIsoTpPduPool"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="N-PDU-REFS">
            <xsd:annotation>
               <xsd:documentation>Reference to NPdus that are part of the PduPool.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayIsoTpPduPool.nPdu";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="N-PDU-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:N-PDU--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TransportProtocols::FlexrayIsoTpPduPool -->
   <xsd:complexType abstract="false" mixed="false" name="FLEXRAY-ISO-TP-PDU-POOL">
      <xsd:annotation>
         <xsd:documentation>FlexrayTpPduPool is a set of N-PDUs which are defined for FrTp sending or receiving purpose.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayIsoTpPduPool"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:FLEXRAY-ISO-TP-PDU-POOL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="FLEXRAY-ISO-TP-PDU-POOL--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="FLEXRAY-ISO-TP-PDU-POOL"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class FlexrayTopology::FlexrayPhysicalChannel -->
   <xsd:group name="FLEXRAY-PHYSICAL-CHANNEL">
      <xsd:annotation>
         <xsd:documentation>FlexRay specific attributes to the physicalChannel</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayPhysicalChannel"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CHANNEL-NAME" type="AR:FLEXRAY-CHANNEL-NAME">
            <xsd:annotation>
               <xsd:documentation>Name of the channel (Channel A or Channel B).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayPhysicalChannel.channelName";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PDU-POOLS">
            <xsd:annotation>
               <xsd:documentation>Optional configuration of FlexRay TP Pdu Pools (shall only be used for Flexray ISO TP configuration).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="pduPool.FlexrayPhysicalChannel";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="FLEXRAY-ISO-TP-PDU-POOL" type="AR:FLEXRAY-ISO-TP-PDU-POOL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TP-CONNECTION-CONTROLS">
            <xsd:annotation>
               <xsd:documentation>Optional configuration of FlexRay ISO TP Connection Controls (shall only be used for Flexray ISO TP configuration).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="tpConnectionControl.FlexrayPhysicalChannel";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="FLEXRAY-ISO-TP-CONNECTION-CONTROL" type="AR:FLEXRAY-ISO-TP-CONNECTION-CONTROL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TP-ECUSS">
            <xsd:annotation>
               <xsd:documentation>Optional collection of TP Ecus with ECU specific Flexray ISO Tp configuration parameters.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="tpEcus.FlexrayPhysicalChannel";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="FLEXRAY-ISO-TP-ECU" type="AR:FLEXRAY-ISO-TP-ECU"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class FlexrayTopology::FlexrayPhysicalChannel -->
   <xsd:complexType abstract="false" mixed="false" name="FLEXRAY-PHYSICAL-CHANNEL">
      <xsd:annotation>
         <xsd:documentation>FlexRay specific attributes to the physicalChannel</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayPhysicalChannel"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PHYSICAL-CHANNEL"/>
         <xsd:group ref="AR:FLEXRAY-PHYSICAL-CHANNEL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="FLEXRAY-PHYSICAL-CHANNEL--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="FLEXRAY-PHYSICAL-CHANNEL"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class TransportProtocols::FlexrayTpChannel -->
   <xsd:group name="FLEXRAY-TP-CHANNEL">
      <xsd:annotation>
         <xsd:documentation>A channel is a group of connections sharing several properties.

      The FlexRay Transport Layer supports several channels. These channels can work concurrently, thus each of them requires its own state machine and management data structures and its own PDU-IDs.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpChannel"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ACK-TYPE" type="AR:TP-ACK-TYPE">
            <xsd:annotation>
               <xsd:documentation>Type of Acknowledgement.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpChannel.ackType";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EXTENDED-ADDRESSING" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Adressing Type of this connection:
            true: Two Bytes
            false: One Byte</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpChannel.extendedAddressing";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FLOW-CONTROL-PDU-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the  Flow Control NPdu.

            The Flow Control network protocol data unit (FC N_PDU) is identified by the Flow Control protocol control information (FC N_PCI). The Flow Control network protocol data unit (FC N_PDU) instructs a sending network entity to start, stop or resume transmission of CF N_PDUs. The Flow Control network protocol data unit shall be sent by the receiving network layer entity to the sending network layer entity, when ready to receive more data, after correct reception of:</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpChannel.flowControlPdu";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:N-PDU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-AR" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>This parameter defines the maximum number of trying to send a frame when a TIMEOUT AR occurs (depending on whether retry is configured).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpChannel.maxAr";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-AS" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>This parameter defines the maximum number of trying to send a frame when a TIMEOUT AS occurs (depending on whether retry is configured).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpChannel.maxAs";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-BS" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>This parameter is only relevant when having retry activated. It limits the maximal block size the FrTp can choose in order to limit the amount of Tx buffer that will be requested at the sender side in a segmented transfer.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpChannel.maxBs";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-BUFFER-REQUEST" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>This parameter defines the maximum number of trying to get a buffer (Transmit / Receive), depending of the return value of PduR_FrTpProvideTxBuffer / PduR_FrTpProvideRxBuffer and on whether retry is configured.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpChannel.maxBufferRequest";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-FR-IF" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>This parameter defines the maximum number of trying to send a frame when the FrIf returns an error.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpChannel.maxFrIf";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-RETRIES" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>This parameter defines the maximum number of retries (if retry is configured for the particular channel).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpChannel.maxRetries";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAXIMUM-MESSAGE-LENGTH" type="AR:MAXIMUM-MESSAGE-LENGTH-TYPE">
            <xsd:annotation>
               <xsd:documentation>This specifies the maximum message length for the particular channel.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpChannel.maximumMessageLength";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MINIMUM-SEPARATION-TIME" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>This attribute defines the minimum amount of time (separation Time) between two succeeding CFs. Specified in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpChannel.minimumSeparationTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MULTICAST-SEGMENTATION" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>This attribute defines whether segmentation within a 1:n connection is allowed or not.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpChannel.multicastSegmentation";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PDU-POOLS">
            <xsd:annotation>
               <xsd:documentation>A FlexRayTpChannel contains a pool of NPdus.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="pduPool.FlexrayTpChannel";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="N-PDU" type="AR:N-PDU"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIME-BR" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>This parameter defines the time in seconds between receiving the last CF of a block or an FF-x (or SF-x) and sending out an FC or AF.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpChannel.timeBr";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIME-BUFFER" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>This parameter defines the time in seconds of waiting for the next try (if retry is activated) to get a Tx or Rx buffer.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpChannel.timeBuffer";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIME-CS" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>This parameter defines the time in seconds between the sending of two consecutive frames or between a  consecutive frame and a flow control (for Transmit Cancellation) or between reception of an flow control or Acknowledgement Frame and sending of the next consecutive frame or a  flow control (for Transmit Cancellation).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpChannel.timeCs";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIME-FR-IF" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>This parameter defines the time in seconds of waiting for the next try (if retry is activated) to send via FrIf_Transmit. Specified in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpChannel.timeFrIf";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMEOUT-AR" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>This parameter states the timeout in seconds between the PDU transmit request of the Transport Layer to the FlexRay Interface and the corresponding confirmation of the FlexRay Interface on the receiver side (for FC or AF).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpChannel.timeoutAr";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMEOUT-AS" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>This parameter states the timeout in seconds between the PDU transmit request for the first PDU of the group used in the current connection of the Transport Layer to the FlexRay Interface and the corresponding confirmation of the FlexRay Interface (when having sent the last PDU of the
            group used in this connection) on the sender side (SF-x, FF-x, CF).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpChannel.timeoutAs";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMEOUT-BS" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>This parameter defines the timeout in seconds for waiting for an FC or AF on the sender side in a 1:1 connection.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpChannel.timeoutBs";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMEOUT-CR" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>This parameter defines the timeout value in seconds for waiting for a CF or FF-x (in case of retry) after receiving the last CF or after sending an FC or AF on the receiver side.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpChannel.timeoutCr";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TP-CONNECTIONS">
            <xsd:annotation>
               <xsd:documentation>Group of connections that can be used in this channel.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="tpConnection.FlexrayTpChannel";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="FLEX-RAY-TP-CONNECTION" type="AR:FLEX-RAY-TP-CONNECTION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TRANSMIT-CANCELLATION" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>This attribute states whether Transmit Cancellation is supported on this channel.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpChannel.transmitCancellation";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TransportProtocols::FlexrayTpChannel -->
   <xsd:complexType abstract="false" mixed="false" name="FLEXRAY-TP-CHANNEL">
      <xsd:annotation>
         <xsd:documentation>A channel is a group of connections sharing several properties.

      The FlexRay Transport Layer supports several channels. These channels can work concurrently, thus each of them requires its own state machine and management data structures and its own PDU-IDs.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpChannel"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:FLEXRAY-TP-CHANNEL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- complex type for class TransportProtocols::FlexrayTpNode -->
   <xsd:complexType abstract="false" mixed="false" name="FLEXRAY-TP-NODE">
      <xsd:annotation>
         <xsd:documentation>TP Node (Sender or Receiver) provides the TP Address and the connection to the Topology description.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FlexrayTpNode"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:TP-NODE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="FLEXRAY-TP-NODE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="FLEXRAY-TP-NODE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ECUCParameterDefTemplate::FloatParamDef -->
   <xsd:group name="FLOAT-PARAM-DEF">
      <xsd:annotation>
         <xsd:documentation>Configuration parameter type for Float.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FloatParamDef";xml.sequenceOffset="0"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DEFAULT-VALUE" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Default value of the float configuration parameter.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FloatParamDef.defaultValue";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>max value allowed for the parameter defined.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FloatParamDef.max";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MIN" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>min value allowed for the parameter defined.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FloatParamDef.min";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::FloatParamDef -->
   <xsd:complexType abstract="false" mixed="false" name="FLOAT-PARAM-DEF">
      <xsd:annotation>
         <xsd:documentation>Configuration parameter type for Float.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FloatParamDef";xml.sequenceOffset="0"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PARAM-CONF-MULTIPLICITY"/>
         <xsd:group ref="AR:COMMON-CONFIGURATION-ATTRIBUTES"/>
         <xsd:group ref="AR:CONFIG-PARAMETER"/>
         <xsd:group ref="AR:FLOAT-PARAM-DEF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUCDescriptionTemplate::FloatValue -->
   <xsd:group name="FLOAT-VALUE">
      <xsd:annotation>
         <xsd:documentation>Representing a configuration value of definition type FloatParamDef</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FloatValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VALUE" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Stores the value of the Float parameter.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FloatValue.value";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCDescriptionTemplate::FloatValue -->
   <xsd:complexType abstract="false" mixed="false" name="FLOAT-VALUE">
      <xsd:annotation>
         <xsd:documentation>Representing a configuration value of definition type FloatParamDef</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FloatValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:PARAMETER-VALUE"/>
         <xsd:group ref="AR:FLOAT-VALUE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class SignalPaths::ForbiddenSignalPath -->
   <xsd:group name="FORBIDDEN-SIGNAL-PATH">
      <xsd:annotation>
         <xsd:documentation>The ForbiddenSignalPath describes the physical channels which an element must not take in the topology. Such a signal path can be a constraint for the communication matrix,  because such a path has an effect on the frame generation and the frame path.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ForbiddenSignalPath"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="OPERATIONS">
            <xsd:annotation>
               <xsd:documentation>Reference to the operation arguments of one operation which must not take the predefined way in the topology.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="operation.ForbiddenSignalPath";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SWC-TO-SWC-OPERATION-ARGUMENTS" type="AR:SWC-TO-SWC-OPERATION-ARGUMENTS"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PHYSICAL-CHANNEL-REFS">
            <xsd:annotation>
               <xsd:documentation>The SwcToSwcSignal must not be transmitted on one of these physical channels.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ForbiddenSignalPath.physicalChannel";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="PHYSICAL-CHANNEL-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:PHYSICAL-CHANNEL--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SIGNALS">
            <xsd:annotation>
               <xsd:documentation>The data element which must not take the predefined way in the topology.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="signal.ForbiddenSignalPath";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SWC-TO-SWC-SIGNAL" type="AR:SWC-TO-SWC-SIGNAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SignalPaths::ForbiddenSignalPath -->
   <xsd:complexType abstract="false" mixed="false" name="FORBIDDEN-SIGNAL-PATH">
      <xsd:annotation>
         <xsd:documentation>The ForbiddenSignalPath describes the physical channels which an element must not take in the topology. Such a signal path can be a constraint for the communication matrix,  because such a path has an effect on the frame generation and the frame path.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ForbiddenSignalPath"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:FORBIDDEN-SIGNAL-PATH"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ECUCParameterDefTemplate::ForeignReferenceParamDef -->
   <xsd:group name="FOREIGN-REFERENCE-PARAM-DEF">
      <xsd:annotation>
         <xsd:documentation>Specify a reference to an XML description of an entity desribed in another AUTOSAR template.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ForeignReferenceParamDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DESTINATION-TYPE" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>The type in the AUTOSAR Metamodel to which' instance this reference is allowed to point to.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ForeignReferenceParamDef.destinationType";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::ForeignReferenceParamDef -->
   <xsd:complexType abstract="false" mixed="false" name="FOREIGN-REFERENCE-PARAM-DEF">
      <xsd:annotation>
         <xsd:documentation>Specify a reference to an XML description of an entity desribed in another AUTOSAR template.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ForeignReferenceParamDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PARAM-CONF-MULTIPLICITY"/>
         <xsd:group ref="AR:COMMON-CONFIGURATION-ATTRIBUTES"/>
         <xsd:group ref="AR:FOREIGN-REFERENCE-PARAM-DEF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class CoreCommunication::Frame -->
   <xsd:group name="FRAME">
      <xsd:annotation>
         <xsd:documentation>Data frame which is sent over a communication medium. This element describes the pure Layout of a frame sent on a channel.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Frame"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="FRAME-LENGTH" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The used length (in bytes)  of the referencing frame. Should not be confused with a static byte length reserved for each frame by some platforms (e.g. FlexRay).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Frame.frameLength";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PDU-TO-FRAME-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>A frames layout as a sequence of Pdus.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="pduToFrameMapping.Frame";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="PDU-TO-FRAME-MAPPING" type="AR:PDU-TO-FRAME-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::Frame -->
   <xsd:complexType abstract="false" mixed="false" name="FRAME">
      <xsd:annotation>
         <xsd:documentation>Data frame which is sent over a communication medium. This element describes the pure Layout of a frame sent on a channel.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Frame"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:FRAME"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="FRAME--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="FRAME"/>
         <xsd:enumeration value="SUBSTITUTION-FRAME"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Fibex4Multiplatform::FrameMapping -->
   <xsd:group name="FRAME-MAPPING">
      <xsd:annotation>
         <xsd:documentation>The entire source frame is mapped as it is onto the target frame (what in general is only possible inside of a common platform). In this case source and target frame should be the identical object.

      Each pair consists in a SOURCE and a TARGET referencing to a FrameTriggering.

      The Frame Mapping is not supported by the Autosar BSW. The existence is optional and has been incorporated into the System Template mainly for compatibility in order to allow interchange between FIBEX and AUTOSAR descriptions.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FrameMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SOURCE-FRAME-REF">
            <xsd:annotation>
               <xsd:documentation>Source destination of the referencing mapping.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FrameMapping.sourceFrame";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:FRAME-TRIGGERING--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TARGET-FRAME-REF">
            <xsd:annotation>
               <xsd:documentation>Target destination of the referencing mapping.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FrameMapping.targetFrame";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:FRAME-TRIGGERING--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Fibex4Multiplatform::FrameMapping -->
   <xsd:complexType abstract="false" mixed="false" name="FRAME-MAPPING">
      <xsd:annotation>
         <xsd:documentation>The entire source frame is mapped as it is onto the target frame (what in general is only possible inside of a common platform). In this case source and target frame should be the identical object.

      Each pair consists in a SOURCE and a TARGET referencing to a FrameTriggering.

      The Frame Mapping is not supported by the Autosar BSW. The existence is optional and has been incorporated into the System Template mainly for compatibility in order to allow interchange between FIBEX and AUTOSAR descriptions.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FrameMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:FRAME-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- complex type for class CoreCommunication::FramePort -->
   <xsd:complexType abstract="false" mixed="false" name="FRAME-PORT">
      <xsd:annotation>
         <xsd:documentation>Connectors reception or send port on the referenced channel referenced by a FrameTriggering.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FramePort"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COMM-CONNECTOR-PORT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="FRAME-PORT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="FRAME-PORT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class CoreCommunication::FrameTriggering -->
   <xsd:group name="FRAME-TRIGGERING">
      <xsd:annotation>
         <xsd:documentation>The FrameTriggering describes the instance of a frame sent on a channel and defines the manner of triggering (timing information) and identification of a frame on the channel, on which it is sent.

      For the same frame, if Frame Triggerings exist on more than one channel of the same cluster the fan-out/in is handled by the Bus interface.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FrameTriggering"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="FRAME-PORT-REFS">
            <xsd:annotation>
               <xsd:documentation>This reference allows to specify explicitly which Frame is received/sent by the connected ECU on the connected channel.

            This reference shall be provided to every FramePort on every ECU in the System which sends and/or receives the Frame.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FrameTriggering.framePort";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="FRAME-PORT-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:FRAME-PORT--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FRAME-REF">
            <xsd:annotation>
               <xsd:documentation>One frame can be triggered on different channels. If a frame has no frame triggering, it won&amp;rsquo;t be sent at all. A frame triggering has assigned exactly one frame, which it triggers.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FrameTriggering.frame";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:FRAME--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="I-PDU-TRIGGERING-REFS">
            <xsd:annotation>
               <xsd:documentation>This reference provides the relationship to the IPduTriggerings that are implemented by the FrameTriggering. The reference is optional since no IPduTriggering can be defined for NmPdus.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FrameTriggering.iPduTriggering";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="I-PDU-TRIGGERING-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:I-PDU-TRIGGERING--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <xsd:simpleType name="FRAME-TRIGGERING--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CAN-FRAME-TRIGGERING"/>
         <xsd:enumeration value="FLEXRAY-FRAME-TRIGGERING"/>
         <xsd:enumeration value="LIN-FRAME-TRIGGERING"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class LinCommunication::FreeFormat -->
   <xsd:group name="FREE-FORMAT">
      <xsd:annotation>
         <xsd:documentation>Representing freely defined data.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FreeFormat"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BYTE-VALUES">
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element maxOccurs="unbounded" minOccurs="0" name="BYTE-VALUE" type="xsd:integer">
                     <xsd:annotation>
                        <xsd:documentation>The integer Value of a freely defined data byte.</xsd:documentation>
                        <xsd:appinfo source="tags">mmt.qualifiedName="FreeFormat.ByteValue";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
                     </xsd:annotation>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class LinCommunication::FreeFormat -->
   <xsd:complexType abstract="false" mixed="false" name="FREE-FORMAT">
      <xsd:annotation>
         <xsd:documentation>Representing freely defined data.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FreeFormat"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:FREE-FORMAT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class BasicElements::FrequencyRange -->
   <xsd:group name="FREQUENCY-RANGE">
      <xsd:annotation>
         <xsd:documentation>Class describing minimum, maximum and typical frequencies.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FrequencyRange"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-FREQUENCY" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Maximum frequency.
            Unit: Herz</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FrequencyRange.maxFrequency";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MIN-FREQUENCY" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Minimum frequency.
            Unit: Herz</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FrequencyRange.minFrequency";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TYPICAL-FREQUENCY" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Typical frequency.
            Unit: Herz</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="FrequencyRange.typicalFrequency";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BasicElements::FrequencyRange -->
   <xsd:complexType abstract="false" mixed="false" name="FREQUENCY-RANGE">
      <xsd:annotation>
         <xsd:documentation>Class describing minimum, maximum and typical frequencies.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FrequencyRange"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:FREQUENCY-RANGE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- complex type for class Inlines::Ft -->
   <xsd:complexType abstract="false" mixed="true" name="FT">
      <xsd:annotation>
         <xsd:documentation>Use &lt;ft&gt; , to create a footnote.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Ft"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0"/>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- complex type for class ServiceNeeds::FunctionInhibitionNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="FUNCTION-INHIBITION-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs on the configuration of the Function Inhibition Manager for one Function Identifier (FID). This class currently contains no attributes. Its name can be regarded as a symbol identifying the FID  from the viewpoint of the component or module which owns this class.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FunctionInhibitionNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="FUNCTION-INHIBITION-NEEDS--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="FUNCTION-INHIBITION-NEEDS"/>
         <xsd:enumeration value="SWC-FUNCTION-INHIBITION-NEEDS"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- complex type for class ECUCParameterDefTemplate::FunctionNameDef -->
   <xsd:complexType abstract="false" mixed="false" name="FUNCTION-NAME-DEF">
      <xsd:annotation>
         <xsd:documentation>Configuration parameter type for Function Names like those used to specify callback functions.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FunctionNameDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PARAM-CONF-MULTIPLICITY"/>
         <xsd:group ref="AR:COMMON-CONFIGURATION-ATTRIBUTES"/>
         <xsd:group ref="AR:CONFIG-PARAMETER"/>
         <xsd:group ref="AR:STRING-PARAM-DEF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- complex type for class ECUCDescriptionTemplate::FunctionNameValue -->
   <xsd:complexType abstract="false" mixed="false" name="FUNCTION-NAME-VALUE">
      <xsd:annotation>
         <xsd:documentation>Representing a configuration value of definition type FunctionNameDef</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="FunctionNameValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:PARAMETER-VALUE"/>
         <xsd:group ref="AR:STRING-VALUE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Fibex4Multiplatform::Gateway -->
   <xsd:group name="GATEWAY">
      <xsd:annotation>
         <xsd:documentation>A gateway is an ECU that is connected to two or more clusters (channels, but not redundant), and performs a frame, Pdu or signal mapping between them.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Gateway"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECU-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Gateway.ecu";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ECU-INSTANCE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FRAME-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>Frame Gateway: The entire source frame is mapped as it is onto the target frame (what in general is only possible inside of a common platform). In this case source and target frame should be the identical object.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="frameMapping.Gateway";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="FRAME-MAPPING" type="AR:FRAME-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="I-PDU-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>IPdu Gateway: Arranges those IPdus that are transferred by the gateway from one channel to the other in pairs and defines the mapping between them.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="iPduMapping.Gateway";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="I-PDU-MAPPING" type="AR:I-PDU-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SIGNAL-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>Signal Gateway: Arranges those signals that are transferred by the gateway from one channel to the other in pairs and defines the mapping between them.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="signalMapping.Gateway";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SIGNAL-MAPPING" type="AR:SIGNAL-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Fibex4Multiplatform::Gateway -->
   <xsd:complexType abstract="false" mixed="false" name="GATEWAY">
      <xsd:annotation>
         <xsd:documentation>A gateway is an ECU that is connected to two or more clusters (channels, but not redundant), and performs a frame, Pdu or signal mapping between them.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Gateway"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:GATEWAY"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Annotation::GeneralAnnotation -->
   <xsd:group name="GENERAL-ANNOTATION">
      <xsd:annotation>
         <xsd:documentation>This class represents textual comments (called annotations) which relate to the object in which it is aggregated. These are intended for use during the development process, to transfer information from one stage of the development process to the next one. 

      The approach is similar to the "yellow pads ..."

      This abstract class can be specialized in order to add some further formal properties.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="GeneralAnnotation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="LABEL" type="AR:ML-DATA-4">
            <xsd:annotation>
               <xsd:documentation>label is used as a long designator (similar to  longName) for objects which cannot be referenced.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="GeneralAnnotation.label";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ANNOTATION-ORIGIN" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>This element identifies the origin of the annotation. It is an arbitrary string since it can be an individual's name as well as the name of a tool or even the name of a process step.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="GeneralAnnotation.annotationOrigin";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ANNOTATION-TEXT" type="AR:REMARK">
            <xsd:annotation>
               <xsd:documentation>This is the text of the annotation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="GeneralAnnotation.annotationText";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class Peripherals::GeneralPurposeTimer -->
   <xsd:group name="GENERAL-PURPOSE-TIMER">
      <xsd:annotation>
         <xsd:documentation>Common attributes shared by all timer peripherals</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="GeneralPurposeTimer"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CLOCK-SOURCE-REF">
            <xsd:annotation>
               <xsd:documentation>The clock input to a timer can have different sources like the internal system clock or an external clock. If the clock is pre-scaled this information should be entered in the table.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="GeneralPurposeTimer.clockSource";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:OSCILLATOR--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PHASE-DETECTION" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Some timers have the possibility to detect signals from a quadrature rotating switch. There are two outputs signal from such a switch; the signals are 90 degrees phase shifted from each other. The rotation of the switch can then automatically be detected by a special function in a timer.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="GeneralPurposeTimer.phaseDetection";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RESOLUTION" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>For a timer the resolution defines the data width of the counter.
            Unit: Bits</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="GeneralPurposeTimer.resolution";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="THRESHOLD-VALUES">
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element maxOccurs="unbounded" minOccurs="0" name="THRESHOLD-VALUE" type="xsd:integer">
                     <xsd:annotation>
                        <xsd:documentation>The threshold is the definition of a counter value. When the counter has reached this value some action is performed, e.g. an interrupt can be generated.</xsd:documentation>
                        <xsd:appinfo source="tags">mmt.qualifiedName="GeneralPurposeTimer.thresholdValue";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
                     </xsd:annotation>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class ECUResourceTemplate::HWConnection -->
   <xsd:group name="HW-CONNECTION">
      <xsd:annotation>
         <xsd:documentation>Abstract class to specify the ability to connect HWPorts.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="HWConnection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONNECTED-PINS">
            <xsd:annotation>
               <xsd:documentation>A set of connections between HWPins of the connected HWPorts.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="connectedPin.HWConnection";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="PIN-HW-CONNECTION" type="AR:PIN-HW-CONNECTION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUResourceTemplate::HWContainer -->
   <xsd:complexType abstract="false" mixed="false" name="HW-CONTAINER">
      <xsd:annotation>
         <xsd:documentation>A HW Container is a group of HW Elements on the same hierarchical level and is an abstraction of composite HW Elements. The HW Container is a specialisation of a HW Element and therefore the HW Container has all elements of a HW Element.
      The values of elements of the HW Elements grouped in a HW Container may differ from the values of the elements of the HW Container.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="HWContainer"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HW-ELEMENT"/>
         <xsd:group ref="AR:HW-ELEMENT-CONTAINER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUResourceTemplate::HWElement -->
   <xsd:group name="HW-ELEMENT">
      <xsd:annotation>
         <xsd:documentation>The General HW Element specifies definitions valid for all specific HW Elements.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="HWElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="HW-ELEMENT-TEMPERATURE" type="AR:TEMPERATURE">
            <xsd:annotation>
               <xsd:documentation>For the placement of a HW Element within a car the temperature has to be considered the HW Element has been designed for.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="hwElementTemperature.HWElement";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PORTS">
            <xsd:annotation>
               <xsd:documentation>All the HWPorts this HWElement exposes. This also includes delegation HWPorts of HWContainers.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="port.HWElement";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="COMMUNICATION-HW-PORT" type="AR:COMMUNICATION-HW-PORT"/>
                  <xsd:element name="ECU-COMMUNICATION-PORT" type="AR:ECU-COMMUNICATION-PORT"/>
                  <xsd:element name="HW-PORT" type="AR:HW-PORT"/>
                  <xsd:element name="INTERRUPT-CONSUME-HW-PORT" type="AR:INTERRUPT-CONSUME-HW-PORT"/>
                  <xsd:element name="INTERRUPT-PRODUCE-HW-PORT" type="AR:INTERRUPT-PRODUCE-HW-PORT"/>
                  <xsd:element name="MEMORY-MAPPED-HW-PORT" type="AR:MEMORY-MAPPED-HW-PORT"/>
                  <xsd:element name="PERIPHERAL-HW-PORT" type="AR:PERIPHERAL-HW-PORT"/>
                  <xsd:element name="POWER-DRIVER-HW-PORT" type="AR:POWER-DRIVER-HW-PORT"/>
                  <xsd:element name="POWER-SUPPLY-HW-PORT" type="AR:POWER-SUPPLY-HW-PORT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SIGNAL-TRANSFORMATIONS">
            <xsd:annotation>
               <xsd:documentation>The Signal Transformation defines the conversion of the signal attached to a HW Port (direction In) and a signal attached to a HW Port (direction Out).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="signalTransformation.HWElement";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SIGNAL-TRANSFORMATION" type="AR:SIGNAL-TRANSFORMATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="STANDBY-CURRENT" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>The Standby Current is the current in state OFF. For HW Elements the Standby Current consists of the current needed by the logic to stay in the state OFF and the leakage current of the HW Element. For big HW Elements the leakage current can be up to several 100 microA.
            Standby Current is used to determine which elements are necessary to be switch off, when the car itself is in a standby mode. This can be done automatically or by the user.
            The value for the Standby Current can be entered for each HW Element and HW Container respectively. The user has to take care about these values and decides about the entries necessary for the calculation of the complete standby current. On the other side the sum for all HW Elements grouped in a HW Container may have a bigger value than the value for the HW Container itself. In this case the values for the HW Elements represent the worst case for each HW Element. 
            Unit: Ampere (A)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="HWElement.standbyCurrent";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SUPPORTS-SAFETY" type="AR:SUPPORTS-SAFETY">
            <xsd:annotation>
               <xsd:documentation>The ECU Resource Template provides the element Supports Safety storing the information about the supported safety mechanism.
            In the current version of the ECU Resource Template the element Supports Safety is optional. A HW Element uses this element if it provides a safety mechanism otherwise this element is missing in the description of the HW Element.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="supportsSafety.HWElement";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SUPPORTS-SECURITY" type="AR:SUPPORTS-SECURITY">
            <xsd:annotation>
               <xsd:documentation>The ECU Resource Template provides the element SupportsSecurity storing the information about the supported security mechanism.
            In the current version of the ECU Resource Template the element SupportsSecurity is optional. A HW Element uses this element if it provides a security mechanism otherwise this element is missing in the description of the HW Element.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="supportsSecurity.HWElement";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <xsd:simpleType name="HW-ELEMENT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ADC"/>
         <xsd:enumeration value="ACTUATOR-HW"/>
         <xsd:enumeration value="CCU"/>
         <xsd:enumeration value="CLOCK"/>
         <xsd:enumeration value="COMMUNICATION-PERIPHERAL"/>
         <xsd:enumeration value="COMMUNICATION-TRANSCEIVER"/>
         <xsd:enumeration value="DAC"/>
         <xsd:enumeration value="DIGITAL-IO"/>
         <xsd:enumeration value="DISCRETE-ECU-ELECTRONICS"/>
         <xsd:enumeration value="DISPLAY-HW"/>
         <xsd:enumeration value="ECU"/>
         <xsd:enumeration value="HW-CONTAINER"/>
         <xsd:enumeration value="OSCILLATOR"/>
         <xsd:enumeration value="PWD"/>
         <xsd:enumeration value="PWM"/>
         <xsd:enumeration value="PERIPHERAL"/>
         <xsd:enumeration value="POWER-DRIVER-HW-ELEMENT"/>
         <xsd:enumeration value="POWER-SUPPLY-HW-ELEMENT"/>
         <xsd:enumeration value="PROCESSING-UNIT"/>
         <xsd:enumeration value="PROVIDED-MEMORY-SEGMENT"/>
         <xsd:enumeration value="PROVIDED-NV-MEMORY-SEGMENT"/>
         <xsd:enumeration value="SENSOR-HW"/>
         <xsd:enumeration value="TIMER"/>
         <xsd:enumeration value="WATCH-DOG"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ECUResourceTemplate::HWElementContainer -->
   <xsd:group name="HW-ELEMENT-CONTAINER">
      <xsd:annotation>
         <xsd:documentation>Abstract class to enable the collection of HW Elements.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="HWElementContainer"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONNECTIONS">
            <xsd:annotation>
               <xsd:documentation>The connections gathered within the HWElementContainer.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="connection.HWElementContainer";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ASSEMBLY-HW-CONNECTION" type="AR:ASSEMBLY-HW-CONNECTION"/>
                  <xsd:element name="DELEGATION-HW-CONNECTION" type="AR:DELEGATION-HW-CONNECTION"/>
                  <xsd:element name="MEMORY-MAPPED-ASSEMBLY-HW-CONNECTION" type="AR:MEMORY-MAPPED-ASSEMBLY-HW-CONNECTION"/>
                  <xsd:element name="MEMORY-MAPPED-DELEGATION-HW-CONNECTION" type="AR:MEMORY-MAPPED-DELEGATION-HW-CONNECTION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONTAINED-ELEMENTS">
            <xsd:annotation>
               <xsd:documentation>The HW Elements contained in the HW Element Container.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="containedElement.HWElementContainer";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ADC" type="AR:ADC"/>
                  <xsd:element name="ACTUATOR-HW" type="AR:ACTUATOR-HW"/>
                  <xsd:element name="CCU" type="AR:CCU"/>
                  <xsd:element name="CLOCK" type="AR:CLOCK"/>
                  <xsd:element name="COMMUNICATION-PERIPHERAL" type="AR:COMMUNICATION-PERIPHERAL"/>
                  <xsd:element name="COMMUNICATION-TRANSCEIVER" type="AR:COMMUNICATION-TRANSCEIVER"/>
                  <xsd:element name="DAC" type="AR:DAC"/>
                  <xsd:element name="DIGITAL-IO" type="AR:DIGITAL-IO"/>
                  <xsd:element name="DISCRETE-ECU-ELECTRONICS" type="AR:DISCRETE-ECU-ELECTRONICS"/>
                  <xsd:element name="DISPLAY-HW" type="AR:DISPLAY-HW"/>
                  <xsd:element name="ECU" type="AR:ECU"/>
                  <xsd:element name="HW-CONTAINER" type="AR:HW-CONTAINER"/>
                  <xsd:element name="OSCILLATOR" type="AR:OSCILLATOR"/>
                  <xsd:element name="PWD" type="AR:PWD"/>
                  <xsd:element name="PWM" type="AR:PWM"/>
                  <xsd:element name="PERIPHERAL" type="AR:PERIPHERAL"/>
                  <xsd:element name="POWER-DRIVER-HW-ELEMENT" type="AR:POWER-DRIVER-HW-ELEMENT"/>
                  <xsd:element name="POWER-SUPPLY-HW-ELEMENT" type="AR:POWER-SUPPLY-HW-ELEMENT"/>
                  <xsd:element name="PROCESSING-UNIT" type="AR:PROCESSING-UNIT"/>
                  <xsd:element name="PROVIDED-MEMORY-SEGMENT" type="AR:PROVIDED-MEMORY-SEGMENT"/>
                  <xsd:element name="PROVIDED-NV-MEMORY-SEGMENT" type="AR:PROVIDED-NV-MEMORY-SEGMENT"/>
                  <xsd:element name="SENSOR-HW" type="AR:SENSOR-HW"/>
                  <xsd:element name="TIMER" type="AR:TIMER"/>
                  <xsd:element name="WATCH-DOG" type="AR:WATCH-DOG"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUResourceTemplate::HWPin -->
   <xsd:complexType abstract="false" mixed="false" name="HW-PIN">
      <xsd:annotation>
         <xsd:documentation>A HWPin is an elementary electrical interface of the HWElement.
      The HWPins of a HWPort can be clustered if there are some HWPins with the same behaviour.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="HWPin"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="HW-PIN--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="HW-PIN"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ECUResourceTemplate::HWPort -->
   <xsd:group name="HW-PORT">
      <xsd:annotation>
         <xsd:documentation>The general element HW Port is necessary to connect HW Elements and contains common elements for all different kind of HW Ports.
      HW Ports are required to be uniquely identifiable within the scope of a HW Element. This means to identify a specific HW Port it is necessary to prefix the HW Port name by the name of the HW Element (e.g."PU1/ADCPort3").</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="HWPort"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DIRECTION" type="AR:COMMUNICATION-DIRECTION-ENUM">
            <xsd:annotation>
               <xsd:documentation>The direction of a HW Port defines signal flow in the point of view of the HW Element the HW Port belongs to. The following attributes are allowed:</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="HWPort.direction";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PINS">
            <xsd:annotation>
               <xsd:documentation>These are the pins the HWPort assembles. If the HWPort does not have HWPins (because the HWPort is inside a micro) the set is empty.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="pin.HWPort";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="HW-PIN" type="AR:HW-PIN"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUResourceTemplate::HWPort -->
   <xsd:complexType abstract="false" mixed="false" name="HW-PORT">
      <xsd:annotation>
         <xsd:documentation>The general element HW Port is necessary to connect HW Elements and contains common elements for all different kind of HW Ports.
      HW Ports are required to be uniquely identifiable within the scope of a HW Element. This means to identify a specific HW Port it is necessary to prefix the HW Port name by the name of the HW Element (e.g."PU1/ADCPort3").</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="HWPort"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HW-PORT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="HW-PORT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="COMMUNICATION-HW-PORT"/>
         <xsd:enumeration value="ECU-COMMUNICATION-PORT"/>
         <xsd:enumeration value="HW-PORT"/>
         <xsd:enumeration value="INTERRUPT-CONSUME-HW-PORT"/>
         <xsd:enumeration value="INTERRUPT-PRODUCE-HW-PORT"/>
         <xsd:enumeration value="MEMORY-MAPPED-HW-PORT"/>
         <xsd:enumeration value="PERIPHERAL-HW-PORT"/>
         <xsd:enumeration value="POWER-DRIVER-HW-PORT"/>
         <xsd:enumeration value="POWER-SUPPLY-HW-PORT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ECUResourceMapping::HWPortMapping -->
   <xsd:group name="HW-PORT-MAPPING">
      <xsd:annotation>
         <xsd:documentation>HWPortMapping specifies the ECUCommunicationPort hardware (defined in the ECU Resource Template) to realize the specified CommunicationConnector in a physical topology.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="HWPortMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMMUNICATION-CONNECTOR-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the CommunicationConnector in the System Template</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="HWPortMapping.communicationConnector";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMMUNICATION-CONNECTOR--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECU-COMMUNICATION-PORT-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the Peripheral in the ECU Resource Template</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="HWPortMapping.ecuCommunicationPort";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ECU-COMMUNICATION-PORT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUResourceMapping::HWPortMapping -->
   <xsd:complexType abstract="false" mixed="false" name="HW-PORT-MAPPING">
      <xsd:annotation>
         <xsd:documentation>HWPortMapping specifies the ECUCommunicationPort hardware (defined in the ECU Resource Template) to realize the specified CommunicationConnector in a physical topology.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="HWPortMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:HW-PORT-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ResourceConsumption::HardwareConfiguration -->
   <xsd:group name="HARDWARE-CONFIGURATION">
      <xsd:annotation>
         <xsd:documentation>Describes in which mode the hardware is operating while providing the ExecutionTime.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="HardwareConfiguration"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ADDITIONAL-INFORMATION" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Specifies additional information on the HardwareConfiguration.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="HardwareConfiguration.additionalInformation";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PROCESSOR-MODE" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Specifies in which mode the processor is operating.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="HardwareConfiguration.processorMode";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PROCESSOR-SPEED" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Specifies the speed the processor is operating.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="HardwareConfiguration.processorSpeed";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ResourceConsumption::HardwareConfiguration -->
   <xsd:complexType abstract="false" mixed="false" name="HARDWARE-CONFIGURATION">
      <xsd:annotation>
         <xsd:documentation>Describes in which mode the hardware is operating while providing the ExecutionTime.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="HardwareConfiguration"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:HARDWARE-CONFIGURATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class HeapUsage::HeapUsage -->
   <xsd:group name="HEAP-USAGE">
      <xsd:annotation>
         <xsd:documentation>Describes the heap memory usage of a SW-Component.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="HeapUsage"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECU-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the ECU description this implementation is provided for.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="HeapUsage.ecu";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ECU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="HARDWARE-CONFIGURATION" type="AR:HARDWARE-CONFIGURATION">
            <xsd:annotation>
               <xsd:documentation>Contains information about the hardware context this heap usage is describing.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="hardwareConfiguration.HeapUsage";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SOFTWARE-CONTEXT" type="AR:SOFTWARE-CONTEXT">
            <xsd:annotation>
               <xsd:documentation>Contains details about the software context this heap usage is provided for.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="softwareContext.HeapUsage";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class CoreCommunication::IPdu -->
   <xsd:group name="I-PDU">
      <xsd:annotation>
         <xsd:documentation>The IPdu (Interaction Layer Protocol Data Unit) element is used to sum up the IPdus of AUTOSAR COM, DCM and IPduM. These Pdus are routed by the PduR. 

      In the AUTOSAR Layered Archtecture the NPdu is not a spezialisation of an IPdu. The NPdu is located under the IPdu to support the low-level routing of NPdu's. More details can be found in the NPdu class description.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IPdu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="LENGTH" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The size of the IPDU in bits.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IPdu.length";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="UNUSED-BIT-PATTERN" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>AUTOSAR COM fills not used areas of an IPDU with this bit-pattern. This attribute is mandatory to avoid undefined behavior. This byte-pattern will be repeated throughout the IPDU.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IPdu.unusedBitPattern";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <xsd:simpleType name="I-PDU--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="DCM-I-PDU"/>
         <xsd:enumeration value="MULTIPLEXED-I-PDU"/>
         <xsd:enumeration value="N-PDU"/>
         <xsd:enumeration value="SIGNAL-I-PDU"/>
         <xsd:enumeration value="USER-DEFINED-I-PDU"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class CoreCommunication::IPduGroup -->
   <xsd:group name="I-PDU-GROUP">
      <xsd:annotation>
         <xsd:documentation>The AUTOSAR COM Layer is able to start and to stop sending and receiving  configurable groups of I-Pdus during runtime. An I-Pdu group contains either Com I-Pdus or I-Pdu groups.

      When an I-Pdu group containing one or more other I-Pdu groups is started the contained I-Pdu groups shall also be started. When an I-Pdu group containing one or more other I-Pdu groups is stopped the contained I-Pdu groups shall also be stopped.

      Only a two level hierarchy of I-Pdu groups is allowed. An I-Pdu group that is part of an I-Pdu group must not contain I-Pdu groups.

      In the COM SRS document it is stated that "every IPdu must belong to exactly 1 I-Pdu group."
      This is true from a dedicated ECUs point of view, however in the system description handling a number of ECUs several IPdu Groups may reference to the same SignalIPdu.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IPduGroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMMUNICATION-DIRECTION" type="AR:COMMUNICATION-DIRECTION-TYPE">
            <xsd:annotation>
               <xsd:documentation>This attribute determines in which direction IPdus that are contained in this IPduGroup will be transmitted (communication direction can be either Send or Receive).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IPduGroup.communicationDirection";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMMUNICATION-MODE" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>This attribute defines the use-case for this IPduGroup (e.g. diagnostic, debugging etc.). For example, in a diagnostic mode all IPdus - which are not involved in diagnostic - are disabled. The use cases are not limited to a fixed enumeration and can be specified as a string.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IPduGroup.communicationMode";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONTAINED-I-PDU-GROUPS-REFS">
            <xsd:annotation>
               <xsd:documentation>An I-PDU group can be included in other I-Pdu groups.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IPduGroup.containedIPduGroups";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CONTAINED-I-PDU-GROUPS-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:I-PDU-GROUP--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="I-PDU-REFS">
            <xsd:annotation>
               <xsd:documentation>Reference to a set of SignalIPdus, which are contained in the I-Pdu Group.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IPduGroup.iPdu";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="I-PDU-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:SIGNAL-I-PDU--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::IPduGroup -->
   <xsd:complexType abstract="false" mixed="false" name="I-PDU-GROUP">
      <xsd:annotation>
         <xsd:documentation>The AUTOSAR COM Layer is able to start and to stop sending and receiving  configurable groups of I-Pdus during runtime. An I-Pdu group contains either Com I-Pdus or I-Pdu groups.

      When an I-Pdu group containing one or more other I-Pdu groups is started the contained I-Pdu groups shall also be started. When an I-Pdu group containing one or more other I-Pdu groups is stopped the contained I-Pdu groups shall also be stopped.

      Only a two level hierarchy of I-Pdu groups is allowed. An I-Pdu group that is part of an I-Pdu group must not contain I-Pdu groups.

      In the COM SRS document it is stated that "every IPdu must belong to exactly 1 I-Pdu group."
      This is true from a dedicated ECUs point of view, however in the system description handling a number of ECUs several IPdu Groups may reference to the same SignalIPdu.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IPduGroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:I-PDU-GROUP"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="I-PDU-GROUP--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="I-PDU-GROUP"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Fibex4Multiplatform::IPduMapping -->
   <xsd:group name="I-PDU-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Arranges those IPdus that are transferred by the gateway from one channel to the other in pairs and defines the mapping between them.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IPduMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="PDUR-TP-CHUNK-SIZE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Optionally defines the to be configured Pdu Router TpChunkSize for this routing relation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IPduMapping.pdurTpChunkSize";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SOURCE-I-PDU" type="AR:SOURCE-I-PDU-REF">
            <xsd:annotation>
               <xsd:documentation>Source destination of the referencing mapping.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="sourceIPdu.IPduMapping";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TARGET-I-PDU" type="AR:TARGET-I-PDU-REF">
            <xsd:annotation>
               <xsd:documentation>Target destination of the referencing mapping.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="targetIPdu.IPduMapping";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Fibex4Multiplatform::IPduMapping -->
   <xsd:complexType abstract="false" mixed="false" name="I-PDU-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Arranges those IPdus that are transferred by the gateway from one channel to the other in pairs and defines the mapping between them.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IPduMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:I-PDU-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- complex type for class CoreCommunication::IPduPort -->
   <xsd:complexType abstract="false" mixed="false" name="I-PDU-PORT">
      <xsd:annotation>
         <xsd:documentation>Connectors reception or send port on the referenced channel referenced by an IPduTriggering.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IPduPort"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COMM-CONNECTOR-PORT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="I-PDU-PORT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="I-PDU-PORT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class CoreCommunication::IPduTiming -->
   <xsd:group name="I-PDU-TIMING">
      <xsd:annotation>
         <xsd:documentation>AUTOSAR COM provides the possibility to define two different TRANSMISSION MODES for each I-PDU.

      The Transmission Mode of an I-PDU that is valid at a specific point in time is 
      selected using the values of the signals that are mapped to this I-PDU. For each I-PDU a Transmission Mode Selector is defined. The Transmission Mode Selector is calculated by evaluating the conditions for a subset of signals  (class TransmissionModeCondition in the System Template).

      The Transmission Mode Selector is defined to be true, if at least one Condition evaluates to true and is defined to be false, if all Conditions evaluate to false.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IPduTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CYCLIC-TIMING" type="AR:CYCLIC-TIMING">
            <xsd:annotation>
               <xsd:documentation>If the COM Transmission Mode is true the timing can be aggregated directly by the IPduTriggering.

            Additionally a Cyclic Timing can be defined as a Timing Requirement (for Lin, FlexRay). Timing Requirements are aggregated by the IPduTriggering/IPduTiming  element.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="cyclicTiming.IPduTiming";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EVENT-CONTROLLED-TIMING" type="AR:EVENT-CONTROLLED-TIMING">
            <xsd:annotation>
               <xsd:documentation>If the COM Transmission Mode is true the timing can be aggregated directly by the IPduTiming.

            Additionally an EventControlledTiming can be defined as a Timing Requirement (for Lin, FlexRay). Timing Requirements are aggregated by the IPduTriggering/IPduTiming element.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="eventControlledTiming.IPduTiming";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MINIMUM-DELAY" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Minimum Delay in seconds between successive transmissions of this I-PDU, independent of the Transmission Mode.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IPduTiming.minimumDelay";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REQUEST-CONTROLLED-TIMING" type="AR:REQUEST-CONTROLLED-TIMING">
            <xsd:annotation>
               <xsd:documentation>A RequestControlled Timing can be defined as a Timing Requirement. 

            Timing Requirements are aggregated by the IPduTriggering/IPduTiming element.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="requestControlledTiming.IPduTiming";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TRANSMISSION-MODE-DECLARATION" type="AR:TRANSMISSION-MODE-DECLARATION">
            <xsd:annotation>
               <xsd:documentation>AUTOSAR COM allows configuring statically two different transmission modes for each I-PDU (True and False). The Transmission Mode Selector evaluates the conditions for a subset of signals and decides the transmission mode. It is possible to switch between the transmission modes during runtime.

            In case only the TRUE transmission mode is used there is no need for the "TransmissionModeDeclaration" and its sub-structure.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="transmissionModeDeclaration.IPduTiming";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::IPduTiming -->
   <xsd:complexType abstract="false" mixed="false" name="I-PDU-TIMING">
      <xsd:annotation>
         <xsd:documentation>AUTOSAR COM provides the possibility to define two different TRANSMISSION MODES for each I-PDU.

      The Transmission Mode of an I-PDU that is valid at a specific point in time is 
      selected using the values of the signals that are mapped to this I-PDU. For each I-PDU a Transmission Mode Selector is defined. The Transmission Mode Selector is calculated by evaluating the conditions for a subset of signals  (class TransmissionModeCondition in the System Template).

      The Transmission Mode Selector is defined to be true, if at least one Condition evaluates to true and is defined to be false, if all Conditions evaluate to false.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IPduTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:I-PDU-TIMING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CoreCommunication::IPduTriggering -->
   <xsd:group name="I-PDU-TRIGGERING">
      <xsd:annotation>
         <xsd:documentation>The IPduTriggering describes on which channel the IPdu is transmitted.

      Depending on its relation to entities such channels and clusters it can be unambiguously deduced whether a fan-out is handled by the Pdu router or the Bus Interface. 

      If the fan-out is specified between different clusters it shall be handled by the Pdu Router.
      If the fan-out is specified between different channels of the same cluster it shall be handled by the Bus Interface.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IPduTriggering"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="I-PDU-PORT-REFS">
            <xsd:annotation>
               <xsd:documentation>This relationship specifies explicitly which IPdus are received/sent by the connected ECU on the connected channel.

            This reference shall be provided to every IPduPort on every ECU in the System which sends and/or receives the IPdu.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IPduTriggering.iPduPort";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="I-PDU-PORT-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:I-PDU-PORT--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="I-PDU-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the Pdu for which the IPdu triggering is defined. One IPdu can be triggered on different channels. The Pdu routing by the PduR is only allowed for IPdus and not for NmPdus and UserDefinedPdus. Nevertheless is the reference to the Pdu element necessary since the PduTriggering element is also used to specify the sending and receiving connections to EcuPorts.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IPduTriggering.iPdu";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PDU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="I-SIGNAL-TRIGGERING-REFS">
            <xsd:annotation>
               <xsd:documentation>This reference provides the relationship to the ISignalTriggerings that are implemented by the IPduTriggering. The reference is optional since no ISignalTriggering can be defined for DCM and Multiplexed Pdus.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IPduTriggering.iSignalTriggering";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="I-SIGNAL-TRIGGERING-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:I-SIGNAL-TRIGGERING--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMING-REQUIREMENT" type="AR:I-PDU-TIMING">
            <xsd:annotation>
               <xsd:documentation>Describes timing requirements on an I-PDU, handled by the bus interface, (Flexray or LIN). 
            For CAN the timing information must be equal to the timing specification on a signal IPdu.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="timingRequirement.IPduTriggering";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::IPduTriggering -->
   <xsd:complexType abstract="false" mixed="false" name="I-PDU-TRIGGERING">
      <xsd:annotation>
         <xsd:documentation>The IPduTriggering describes on which channel the IPdu is transmitted.

      Depending on its relation to entities such channels and clusters it can be unambiguously deduced whether a fan-out is handled by the Pdu router or the Bus Interface. 

      If the fan-out is specified between different clusters it shall be handled by the Pdu Router.
      If the fan-out is specified between different channels of the same cluster it shall be handled by the Bus Interface.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IPduTriggering"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:I-PDU-TRIGGERING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="I-PDU-TRIGGERING--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="I-PDU-TRIGGERING"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class CoreCommunication::ISignal -->
   <xsd:group name="I-SIGNAL">
      <xsd:annotation>
         <xsd:documentation>Signal of the Interaction Layer. The RTE supports a "signal fan-out" where the same System Signal is sent in different SignalIPdus to multiple receivers. 

      The System Signal is unique per System. To support the RTE "signal fan-out" each SignalIPdu  contains ISignals. If the same System Signal is to be mapped into several SignalIPdus there is one ISignal needed for each ISignalToIPduMapping. 

      ISignals describe the Interface between the Precompile configured RTE and the potentially Postbuild configured Com Stack (see ECUC Parameter Mapping). 

      In the case of the SystemSignalGroup an ISignal must be created for the SystemSignalGroup and for each SystemSignal contained in the SystemSignalGroup.
      If a mapping for the SystemSignalGroup is defined, only the UpdateIndicationBitPosition is relevant, and the startPosition shall be ignored.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ISignal"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYSTEM-SIGNAL-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the System Signal that is supposed to be transmitted in the ISignal.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ISignal.systemSignal";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ABSTRACT-SIGNAL--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::ISignal -->
   <xsd:complexType abstract="false" mixed="false" name="I-SIGNAL">
      <xsd:annotation>
         <xsd:documentation>Signal of the Interaction Layer. The RTE supports a "signal fan-out" where the same System Signal is sent in different SignalIPdus to multiple receivers. 

      The System Signal is unique per System. To support the RTE "signal fan-out" each SignalIPdu  contains ISignals. If the same System Signal is to be mapped into several SignalIPdus there is one ISignal needed for each ISignalToIPduMapping. 

      ISignals describe the Interface between the Precompile configured RTE and the potentially Postbuild configured Com Stack (see ECUC Parameter Mapping). 

      In the case of the SystemSignalGroup an ISignal must be created for the SystemSignalGroup and for each SystemSignal contained in the SystemSignalGroup.
      If a mapping for the SystemSignalGroup is defined, only the UpdateIndicationBitPosition is relevant, and the startPosition shall be ignored.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ISignal"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:I-SIGNAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="I-SIGNAL--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="I-SIGNAL"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class CoreCommunication::ISignalToIPduMapping -->
   <xsd:group name="I-SIGNAL-TO-I-PDU-MAPPING">
      <xsd:annotation>
         <xsd:documentation>An ISignalToIPduMapping describes the mapping of ISignals to ISignalIPdus and defines the position of the ISignal within an ISignalIPdu.

      This element does NOT describe signal or IPdu fan-out but is used to describe the COM Signal Gateway fan-out.  
      In case the ISignal/ISignalGroup is not part of the Signal Gateway the
      ISignal/ISignalGroup can only be mapped into one ISignalIPdu.
      In case the ISignal/ISignalGroup is part of the Signal Gateway several
      ISignalToIPduMappings of the same ISignal are supported.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ISignalToIPduMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="PACKING-BYTE-ORDER" type="AR:BYTE-ORDER-ENUM">
            <xsd:annotation>
               <xsd:documentation>This parameter defines the order of the bytes of the signal and the packing into the SignalIPdu. The byte ordering "Little Endian" (MostSignificantByteLast) and "Big Endian" (MostSignificantByteFirst) can be selected. 
            The value of this attribute impacts the absolute position of the signal into the SignalIPdu (see the startPosition attribute description).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ISignalToIPduMapping.packingByteOrder";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SIGNAL-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to a ISignal that is mapped into the SignalIPdu. 

            Several ISignalToPduMappings to the same ISignal are only relevant when the ECU handles the signal gateway.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ISignalToIPduMapping.signal";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:I-SIGNAL--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="START-POSITION" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>This parameter is necessary to describe the bitposition of a signal within an SignalIPdu.
            It denotes the least significant bit for "Little Endian" and the most significant bit for "Big Endian" packed signals within the IPdu (see the description of the packingByteOrder attribute).

            Bits within the IPdu are counted as follows (see the OSEK COM v3.0.3 specification) :
                  Bit 0 corresponds to Byte 0 Bit 0
                  Bit 1 corresponds to Byte 0 Bit 1
                  .....
                  Bit 8 corresponds to Byte 1 Bit 0
                  etc.

            Please note that the way the bytes will be actually sent on the bus does not impact this representation: they will always be seen by the software as a byte array. 
            Note also that the absolute position of the signal in the SignalIPdu is then determined by the definition of the packingByteOrder attribute of the signal.

            If a mapping for the SystemSignalGroup is defined, only the UpdateIndicationBitPosition is relevant, and the startPosition shall be ignored.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ISignalToIPduMapping.startPosition";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TRANSFER-PROPERTY" type="AR:TRANSFER-PROPERTY-ENUM">
            <xsd:annotation>
               <xsd:documentation>The triggered, triggeredOnChange, triggeredWithoutRepetition and triggeredOnChangeWithoutRepetition transferProperty causes immediate transmission of the IPdu, except if transmission mode Periodic or transmission mode NONE is defined for the IPdu. The Pending transfer property does not cause transmission of an IPdu.

            The immediate transmission of the IPdu is caused even if only one Signal of an IPdu has the transferProperty triggered, triggeredWithoutRepetition, triggeredOnChange, triggeredOnChangeWithoutRepetition and all other Signals have the transferProperty pending.

            Also for ISignals which refer to GroupSignals of a SystemSignalGroup this attribute is relevant and shall be evaluated:
            - If none of the ISignals belonging to the GroupSignals of a SystemSignalGroup have a transferProperty defined the transferProperty of the ISignal referring to the SystemSignalGroup is considered.
            - If at least one of the ISignals belonging to the GroupSignals of a SystemSignalGroup has a transferProperty defined all ISignals belonging to the GroupSignals of a SystemSignalGroup shall have a transferProperty defined as well. All of the transferProperties of the ISignals belonging to the GroupSignals of a SystemSignalGroup are considered.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ISignalToIPduMapping.transferProperty";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="UPDATE-INDICATION-BIT-POSITION" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The UpdateIndicationBit indicates to the receivers that the signal (or the signal group) was updated by the sender. Length is always one bit. The UpdateIndicationBitPosition attribute describes the position of the update bit within the SignalIPdu. 

            The updateIndicationBitPosition is determined by the definition of the packingByteOrder attribute. If Big Endian is specified, the updateIndicationBitPosition indicates the bit position of the most significant bit in the ISignalIPdu. If Little Endian is specified, the updateIndicationBitPosition indicates the bit position of the least significant bit in the ISignalIPdu.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ISignalToIPduMapping.updateIndicationBitPosition";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::ISignalToIPduMapping -->
   <xsd:complexType abstract="false" mixed="false" name="I-SIGNAL-TO-I-PDU-MAPPING">
      <xsd:annotation>
         <xsd:documentation>An ISignalToIPduMapping describes the mapping of ISignals to ISignalIPdus and defines the position of the ISignal within an ISignalIPdu.

      This element does NOT describe signal or IPdu fan-out but is used to describe the COM Signal Gateway fan-out.  
      In case the ISignal/ISignalGroup is not part of the Signal Gateway the
      ISignal/ISignalGroup can only be mapped into one ISignalIPdu.
      In case the ISignal/ISignalGroup is part of the Signal Gateway several
      ISignalToIPduMappings of the same ISignal are supported.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ISignalToIPduMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:I-SIGNAL-TO-I-PDU-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="I-SIGNAL-TO-I-PDU-MAPPING--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="I-SIGNAL-TO-I-PDU-MAPPING"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class CoreCommunication::ISignalTriggering -->
   <xsd:group name="I-SIGNAL-TRIGGERING">
      <xsd:annotation>
         <xsd:documentation>A ISignalTriggering defines the manner of triggering of a ISignal on the channel, on which it is sent.

      ISignalTriggering should only be used for defining timing constraints. Com does not know of signals related to a specific cluster or channel.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ISignalTriggering"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CYCLIC-TIMING" type="AR:CYCLIC-TIMING">
            <xsd:annotation>
               <xsd:documentation>Specification of a cyclic sending behavior.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="cyclicTiming.ISignalTriggering";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EVENT-CONTROLLED-TIMING" type="AR:EVENT-CONTROLLED-TIMING">
            <xsd:annotation>
               <xsd:documentation>Specification of a event driven sending behavior.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="eventControlledTiming.ISignalTriggering";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="I-SIGNAL-PORT-REFS">
            <xsd:annotation>
               <xsd:documentation>This relationship allows to specify explicitly which ISignals are received/sent by the connected ECU on the connected channel.

            This reference shall be provided to every SignalPort on every ECU in the System which sends and/or receives the Signal.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ISignalTriggering.iSignalPort";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="I-SIGNAL-PORT-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:SIGNAL-PORT--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SIGNAL-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the ISignal for which the ISignalTriggering is defined.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ISignalTriggering.signal";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:I-SIGNAL--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::ISignalTriggering -->
   <xsd:complexType abstract="false" mixed="false" name="I-SIGNAL-TRIGGERING">
      <xsd:annotation>
         <xsd:documentation>A ISignalTriggering defines the manner of triggering of a ISignal on the channel, on which it is sent.

      ISignalTriggering should only be used for defining timing constraints. Com does not know of signals related to a specific cluster or channel.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ISignalTriggering"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:I-SIGNAL-TRIGGERING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="I-SIGNAL-TRIGGERING--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="I-SIGNAL-TRIGGERING"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Identifiable::Identifiable -->
   <xsd:group name="IDENTIFIABLE">
      <xsd:annotation>
         <xsd:documentation>Instances of this class can be referred to by their identifier (while adhering to namespace borders).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Identifiable"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="1" name="SHORT-NAME" type="AR:IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>Use &lt;shortName&gt; to generate a short name for the context element, which enables it to be ** .</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Identifiable.shortName";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.enforceMinMultiplicity="true";xml.sequenceOffset="-100"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="LONG-NAME" type="AR:ML-DATA-4">
            <xsd:annotation>
               <xsd:documentation>Use &lt;longName&gt; to create a comprehensive name for the context element.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Identifiable.longName";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="-90"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DESC" type="AR:ML-DATA-2">
            <xsd:annotation>
               <xsd:documentation>&lt;desc&gt; represents a general but brief description of the object in question.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Identifiable.desc";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="-60"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CATEGORY" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>This element assigns a category to the parent element. The category can be used by a semantic checker in post-processes to ensure that the parent object is defined correctly i.e. has the right number of elements for example.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Identifiable.category";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="-50"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ADMIN-DATA" type="AR:ADMIN-DATA">
            <xsd:annotation>
               <xsd:documentation>&lt;adminData&gt; can be used to set administrative information for an element. This administration information is to be treated as metadata such as revision id or state of the file. There are basically four kinds of metadata

            * The language and/or used laguages.

            * Revision information covering e.g. revision number, state, release date, changes. Note that this information can be given in general as well as related to a particular company.

            * Document metadata specific for a company

            * Formatting controls that can affect layouts for example.

            * Revision information for the element.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Identifiable.adminData";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="-40"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INTRODUCTION" type="AR:DOCUMENTATION-BLOCK">
            <xsd:annotation>
               <xsd:documentation>This represents more information about how the object in question is built or is used. Therefore it is a DocumentationBlock.

            In this AUTOSAR Version it is intended to refer to external objexts which are not processed by AUTOSAR-tools.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Identifiable.introduction";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="-30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- attribute group for class Identifiable::Identifiable -->
   <xsd:attributeGroup name="IDENTIFIABLE">
      <xsd:annotation>
         <xsd:documentation>Instances of this class can be referred to by their identifier (while adhering to namespace borders).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Identifiable"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="UUID" type="xsd:string">
         <xsd:annotation>
            <xsd:documentation>The purpose of this attribute is to provide a globally unique identifier for an instance of a metaclass. The values of this attribute should be globally unique strings prefixed by the type of identifier.  For example, to include a
         DCE UUID as defined by The Open Group, the UUID would be preceded by "DCE:". The values of this attribute may be used to support merging of different AUTOSAR models. 
         The form of the UUID (Universally Unique Identifier) is taken from a standard defined by the Open Group (was Open Software Foundation). This standard is widely used, including by Microsoft for COM (GUIDs) and by many companies for DCE, which is based on CORBA. The method for generating these 128-bit IDs is published in the standard and the effectiveness and uniqueness of the IDs is not in practice disputed.
         If the id namespace is omitted, DCE is assumed. 
         An example is "DCE:2fac1234-31f8-11b4-a222-08002b34c003".</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Identifiable.uuid";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <xsd:simpleType name="IDENTIFIABLE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ADC"/>
         <xsd:enumeration value="AR-PACKAGE"/>
         <xsd:enumeration value="ACTUATOR-HW"/>
         <xsd:enumeration value="APPLICATION-ERROR"/>
         <xsd:enumeration value="APPLICATION-SOFTWARE-COMPONENT-TYPE"/>
         <xsd:enumeration value="ARGUMENT-PROTOTYPE"/>
         <xsd:enumeration value="ARRAY-ELEMENT"/>
         <xsd:enumeration value="ARRAY-SPECIFICATION"/>
         <xsd:enumeration value="ARRAY-TYPE"/>
         <xsd:enumeration value="ASSEMBLY-CONNECTOR-PROTOTYPE"/>
         <xsd:enumeration value="ASSEMBLY-HW-CONNECTION"/>
         <xsd:enumeration value="ASYNCHRONOUS-SERVER-CALL-POINT"/>
         <xsd:enumeration value="ASYNCHRONOUS-SERVER-CALL-RETURNS-EVENT"/>
         <xsd:enumeration value="BOOLEAN-LITERAL"/>
         <xsd:enumeration value="BOOLEAN-PARAM-DEF"/>
         <xsd:enumeration value="BOOLEAN-TYPE"/>
         <xsd:enumeration value="BSW-BEHAVIOR"/>
         <xsd:enumeration value="BSW-CYCLIC-EVENT"/>
         <xsd:enumeration value="BSW-IMPLEMENTATION"/>
         <xsd:enumeration value="BSW-INTERRUPT-ENTITY"/>
         <xsd:enumeration value="BSW-MODULE-DEPENDENCY"/>
         <xsd:enumeration value="BSW-MODULE-DESCRIPTION"/>
         <xsd:enumeration value="BSW-MODULE-ENTITY"/>
         <xsd:enumeration value="BSW-MODULE-ENTRY"/>
         <xsd:enumeration value="BSW-SCHEDULABLE-ENTITY"/>
         <xsd:enumeration value="BSW-SPORADIC-EVENT"/>
         <xsd:enumeration value="CCU"/>
         <xsd:enumeration value="CALPRM-ACCESS"/>
         <xsd:enumeration value="CALPRM-COMPONENT-TYPE"/>
         <xsd:enumeration value="CALPRM-ELEMENT-PROTOTYPE"/>
         <xsd:enumeration value="CALPRM-INTERFACE"/>
         <xsd:enumeration value="CAN-CLUSTER"/>
         <xsd:enumeration value="CAN-COMMUNICATION-CONNECTOR"/>
         <xsd:enumeration value="CAN-COMMUNICATION-CONTROLLER"/>
         <xsd:enumeration value="CAN-FRAME-TRIGGERING"/>
         <xsd:enumeration value="CAN-TP-NODE"/>
         <xsd:enumeration value="CHAR-LITERAL"/>
         <xsd:enumeration value="CHAR-TYPE"/>
         <xsd:enumeration value="CHOICE-CONTAINER-DEF"/>
         <xsd:enumeration value="CHOICE-REFERENCE-PARAM-DEF"/>
         <xsd:enumeration value="CLIENT-SERVER-INTERFACE"/>
         <xsd:enumeration value="CLOCK"/>
         <xsd:enumeration value="CODE"/>
         <xsd:enumeration value="COM-MGR-USER-NEEDS"/>
         <xsd:enumeration value="COMMUNICATION-CLUSTER"/>
         <xsd:enumeration value="COMMUNICATION-CONNECTOR"/>
         <xsd:enumeration value="COMMUNICATION-CONTROLLER"/>
         <xsd:enumeration value="COMMUNICATION-HW-PORT"/>
         <xsd:enumeration value="COMMUNICATION-PERIPHERAL"/>
         <xsd:enumeration value="COMMUNICATION-PROTOCOL"/>
         <xsd:enumeration value="COMMUNICATION-TRANSCEIVER"/>
         <xsd:enumeration value="COMPILER"/>
         <xsd:enumeration value="COMPLEX-DEVICE-DRIVER-COMPONENT-TYPE"/>
         <xsd:enumeration value="COMPONENT-PROTOTYPE"/>
         <xsd:enumeration value="COMPOSITION-TYPE"/>
         <xsd:enumeration value="COMPU-METHOD"/>
         <xsd:enumeration value="CONSTANT-REFERENCE"/>
         <xsd:enumeration value="CONSTANT-SPECIFICATION"/>
         <xsd:enumeration value="CONTAINER"/>
         <xsd:enumeration value="DAC"/>
         <xsd:enumeration value="DATA-CONSTR"/>
         <xsd:enumeration value="DATA-ELEMENT-PROTOTYPE"/>
         <xsd:enumeration value="DATA-READ-ACCESS"/>
         <xsd:enumeration value="DATA-RECEIVE-ERROR-EVENT"/>
         <xsd:enumeration value="DATA-RECEIVE-POINT"/>
         <xsd:enumeration value="DATA-RECEIVED-EVENT"/>
         <xsd:enumeration value="DATA-SEND-COMPLETED-EVENT"/>
         <xsd:enumeration value="DATA-SEND-POINT"/>
         <xsd:enumeration value="DATA-WRITE-ACCESS"/>
         <xsd:enumeration value="DCM-I-PDU"/>
         <xsd:enumeration value="DELEGATION-CONNECTOR-PROTOTYPE"/>
         <xsd:enumeration value="DELEGATION-HW-CONNECTION"/>
         <xsd:enumeration value="DEPENDENCY-ON-FILE"/>
         <xsd:enumeration value="DEPENDENCY-ON-LIBRARY"/>
         <xsd:enumeration value="DERIVED-BOOLEAN-PARAM-DEF"/>
         <xsd:enumeration value="DERIVED-ENUMERATION-PARAM-DEF"/>
         <xsd:enumeration value="DERIVED-FLOAT-PARAM-DEF"/>
         <xsd:enumeration value="DERIVED-INTEGER-PARAM-DEF"/>
         <xsd:enumeration value="DERIVED-STRING-PARAM-DEF"/>
         <xsd:enumeration value="DIAGNOSTIC-COMMUNICATION-NEEDS"/>
         <xsd:enumeration value="DIAGNOSTIC-EVENT-NEEDS"/>
         <xsd:enumeration value="DIGITAL-IO"/>
         <xsd:enumeration value="DISCRETE-ECU-ELECTRONICS"/>
         <xsd:enumeration value="DISPLAY-HW"/>
         <xsd:enumeration value="ECU"/>
         <xsd:enumeration value="ECU-COMMUNICATION-PORT"/>
         <xsd:enumeration value="ECU-MAPPING"/>
         <xsd:enumeration value="ECU-ABSTRACTION-COMPONENT-TYPE"/>
         <xsd:enumeration value="ECU-CONFIGURATION"/>
         <xsd:enumeration value="ECU-INSTANCE"/>
         <xsd:enumeration value="ECU-PARAMETER-DEFINITION"/>
         <xsd:enumeration value="ECU-STATE-MGR-USER-NEEDS"/>
         <xsd:enumeration value="ECU-SW-COMPOSITION"/>
         <xsd:enumeration value="END-TO-END-PROTECTION"/>
         <xsd:enumeration value="END-TO-END-PROTECTION-SET"/>
         <xsd:enumeration value="ENUMERATION-LITERAL-DEF"/>
         <xsd:enumeration value="ENUMERATION-PARAM-DEF"/>
         <xsd:enumeration value="EXCLUSIVE-AREA"/>
         <xsd:enumeration value="EXECUTION-TIME"/>
         <xsd:enumeration value="FLEX-RAY-COMMUNICATION-CONNECTOR"/>
         <xsd:enumeration value="FLEXRAY-CLUSTER"/>
         <xsd:enumeration value="FLEXRAY-COMMUNICATION-CONTROLLER"/>
         <xsd:enumeration value="FLEXRAY-FRAME-TRIGGERING"/>
         <xsd:enumeration value="FLEXRAY-ISO-TP-CONNECTION-CONTROL"/>
         <xsd:enumeration value="FLEXRAY-ISO-TP-NODE"/>
         <xsd:enumeration value="FLEXRAY-ISO-TP-PDU-POOL"/>
         <xsd:enumeration value="FLEXRAY-PHYSICAL-CHANNEL"/>
         <xsd:enumeration value="FLEXRAY-TP-NODE"/>
         <xsd:enumeration value="FLOAT-PARAM-DEF"/>
         <xsd:enumeration value="FOREIGN-REFERENCE-PARAM-DEF"/>
         <xsd:enumeration value="FRAME"/>
         <xsd:enumeration value="FRAME-PORT"/>
         <xsd:enumeration value="FUNCTION-INHIBITION-NEEDS"/>
         <xsd:enumeration value="FUNCTION-NAME-DEF"/>
         <xsd:enumeration value="GATEWAY"/>
         <xsd:enumeration value="HW-CONTAINER"/>
         <xsd:enumeration value="HW-PIN"/>
         <xsd:enumeration value="HW-PORT"/>
         <xsd:enumeration value="I-PDU-GROUP"/>
         <xsd:enumeration value="I-PDU-PORT"/>
         <xsd:enumeration value="I-PDU-TRIGGERING"/>
         <xsd:enumeration value="I-SIGNAL"/>
         <xsd:enumeration value="I-SIGNAL-TO-I-PDU-MAPPING"/>
         <xsd:enumeration value="I-SIGNAL-TRIGGERING"/>
         <xsd:enumeration value="IMPLEMENTATION"/>
         <xsd:enumeration value="INSTANCE-REFERENCE-PARAM-DEF"/>
         <xsd:enumeration value="INTEGER-LITERAL"/>
         <xsd:enumeration value="INTEGER-PARAM-DEF"/>
         <xsd:enumeration value="INTEGER-TYPE"/>
         <xsd:enumeration value="INTER-RUNNABLE-VARIABLE"/>
         <xsd:enumeration value="INTERNAL-BEHAVIOR"/>
         <xsd:enumeration value="INTERRUPT-CONSUME-HW-PORT"/>
         <xsd:enumeration value="INTERRUPT-PRODUCE-HW-PORT"/>
         <xsd:enumeration value="LIN-CLUSTER"/>
         <xsd:enumeration value="LIN-FRAME-TRIGGERING"/>
         <xsd:enumeration value="LIN-MASTER"/>
         <xsd:enumeration value="LIN-SCHEDULE-TABLE"/>
         <xsd:enumeration value="LIN-SLAVE"/>
         <xsd:enumeration value="LIN-TP-NODE"/>
         <xsd:enumeration value="LINKER"/>
         <xsd:enumeration value="LINKER-SYMBOL-DEF"/>
         <xsd:enumeration value="MEASURED-EXECUTION-TIME"/>
         <xsd:enumeration value="MEASURED-HEAP-USAGE"/>
         <xsd:enumeration value="MEASURED-STACK-USAGE"/>
         <xsd:enumeration value="MEMORY-MAPPED-ASSEMBLY-HW-CONNECTION"/>
         <xsd:enumeration value="MEMORY-MAPPED-DELEGATION-HW-CONNECTION"/>
         <xsd:enumeration value="MEMORY-MAPPED-HW-PORT"/>
         <xsd:enumeration value="MEMORY-SECTION"/>
         <xsd:enumeration value="MODE-DECLARATION"/>
         <xsd:enumeration value="MODE-DECLARATION-GROUP"/>
         <xsd:enumeration value="MODE-DECLARATION-GROUP-PROTOTYPE"/>
         <xsd:enumeration value="MODE-SWITCH-EVENT"/>
         <xsd:enumeration value="MODE-SWITCH-POINT"/>
         <xsd:enumeration value="MODE-SWITCHED-ACK-EVENT"/>
         <xsd:enumeration value="MODULE-CONFIGURATION"/>
         <xsd:enumeration value="MODULE-DEF"/>
         <xsd:enumeration value="MULTIPLEXED-I-PDU"/>
         <xsd:enumeration value="N-PDU"/>
         <xsd:enumeration value="NM-PDU"/>
         <xsd:enumeration value="NV-BLOCK-NEEDS"/>
         <xsd:enumeration value="OBD-CONTROL-SERVICE-NEEDS"/>
         <xsd:enumeration value="OBD-INFO-SERVICE-NEEDS"/>
         <xsd:enumeration value="OBD-MONITOR-SERVICE-NEEDS"/>
         <xsd:enumeration value="OBD-PID-SERVICE-NEEDS"/>
         <xsd:enumeration value="OBD-RATIO-SERVICE-NEEDS"/>
         <xsd:enumeration value="OPAQUE-LITERAL"/>
         <xsd:enumeration value="OPAQUE-TYPE"/>
         <xsd:enumeration value="OPERATION-INVOKED-EVENT"/>
         <xsd:enumeration value="OPERATION-PROTOTYPE"/>
         <xsd:enumeration value="OSCILLATOR"/>
         <xsd:enumeration value="P-PORT-PROTOTYPE"/>
         <xsd:enumeration value="PWD"/>
         <xsd:enumeration value="PWM"/>
         <xsd:enumeration value="PARAM-CONF-CONTAINER-DEF"/>
         <xsd:enumeration value="PDU-TO-FRAME-MAPPING"/>
         <xsd:enumeration value="PDUR-I-PDU-GROUP"/>
         <xsd:enumeration value="PER-INSTANCE-MEMORY"/>
         <xsd:enumeration value="PERIPHERAL"/>
         <xsd:enumeration value="PERIPHERAL-HW-PORT"/>
         <xsd:enumeration value="PHYSICAL-CHANNEL"/>
         <xsd:enumeration value="PHYSICAL-DIMENSION"/>
         <xsd:enumeration value="PNC-MAPPING"/>
         <xsd:enumeration value="PORT-GROUP"/>
         <xsd:enumeration value="POWER-DRIVER-HW-ELEMENT"/>
         <xsd:enumeration value="POWER-DRIVER-HW-PORT"/>
         <xsd:enumeration value="POWER-SUPPLY-HW-ELEMENT"/>
         <xsd:enumeration value="POWER-SUPPLY-HW-PORT"/>
         <xsd:enumeration value="PROCESSING-UNIT"/>
         <xsd:enumeration value="PROVIDED-MEMORY-SEGMENT"/>
         <xsd:enumeration value="PROVIDED-NV-MEMORY-SEGMENT"/>
         <xsd:enumeration value="R-PORT-PROTOTYPE"/>
         <xsd:enumeration value="REAL-LITERAL"/>
         <xsd:enumeration value="REAL-TYPE"/>
         <xsd:enumeration value="RECORD-ELEMENT"/>
         <xsd:enumeration value="RECORD-SPECIFICATION"/>
         <xsd:enumeration value="RECORD-TYPE"/>
         <xsd:enumeration value="REFERENCE-PARAM-DEF"/>
         <xsd:enumeration value="RESOURCE-CONSUMPTION"/>
         <xsd:enumeration value="ROUGH-ESTIMATE-HEAP-USAGE"/>
         <xsd:enumeration value="ROUGH-ESTIMATE-OF-EXECUTION-TIME"/>
         <xsd:enumeration value="ROUGH-ESTIMATE-STACK-USAGE"/>
         <xsd:enumeration value="RUNNABLE-ENTITY"/>
         <xsd:enumeration value="SDG-CAPTION"/>
         <xsd:enumeration value="SENDER-RECEIVER-INTERFACE"/>
         <xsd:enumeration value="SENSOR-ACTUATOR-SOFTWARE-COMPONENT-TYPE"/>
         <xsd:enumeration value="SENSOR-HW"/>
         <xsd:enumeration value="SERVICE-COMPONENT-PROTOTYPE"/>
         <xsd:enumeration value="SERVICE-COMPONENT-TYPE"/>
         <xsd:enumeration value="SERVICE-CONNECTOR-PROTOTYPE"/>
         <xsd:enumeration value="SERVICE-NEEDS"/>
         <xsd:enumeration value="SIGNAL-I-PDU"/>
         <xsd:enumeration value="SIGNAL-PORT"/>
         <xsd:enumeration value="SIMULATED-EXECUTION-TIME"/>
         <xsd:enumeration value="SOFTWARE-COMPOSITION"/>
         <xsd:enumeration value="STD"/>
         <xsd:enumeration value="STRING-LITERAL"/>
         <xsd:enumeration value="STRING-PARAM-DEF"/>
         <xsd:enumeration value="STRING-TYPE"/>
         <xsd:enumeration value="SUBSTITUTION-FRAME"/>
         <xsd:enumeration value="SUPERVISED-ENTITY-NEEDS"/>
         <xsd:enumeration value="SUPPORTED-DATA-TYPE"/>
         <xsd:enumeration value="SW-ADDR-METHOD"/>
         <xsd:enumeration value="SW-AXIS-TYPE"/>
         <xsd:enumeration value="SW-BASE-TYPE"/>
         <xsd:enumeration value="SW-CALPRM-PROTOTYPE"/>
         <xsd:enumeration value="SW-CLASS-ATTR-IMPL"/>
         <xsd:enumeration value="SW-CLASS-INSTANCE"/>
         <xsd:enumeration value="SW-CLASS-PROTOTYPE"/>
         <xsd:enumeration value="SW-CODE-SYNTAX"/>
         <xsd:enumeration value="SW-GENERIC-AXIS-PARAM-TYPE"/>
         <xsd:enumeration value="SW-RECORD-LAYOUT"/>
         <xsd:enumeration value="SW-SERVICE"/>
         <xsd:enumeration value="SW-SERVICE-ARG"/>
         <xsd:enumeration value="SW-SERVICE-PROTOTYPE"/>
         <xsd:enumeration value="SW-VARIABLE-PROTOTYPE"/>
         <xsd:enumeration value="SWC-COM-MGR-USER-NEEDS"/>
         <xsd:enumeration value="SWC-DIAGNOSTIC-COMMUNICATION-NEEDS"/>
         <xsd:enumeration value="SWC-DIAGNOSTIC-EVENT-NEEDS"/>
         <xsd:enumeration value="SWC-ECU-STATE-MGR-USER-NEEDS"/>
         <xsd:enumeration value="SWC-FUNCTION-INHIBITION-NEEDS"/>
         <xsd:enumeration value="SWC-IMPLEMENTATION"/>
         <xsd:enumeration value="SWC-NV-BLOCK-NEEDS"/>
         <xsd:enumeration value="SWC-OBD-CONTROL-SERVICE-NEEDS"/>
         <xsd:enumeration value="SWC-OBD-INFO-SERVICE-NEEDS"/>
         <xsd:enumeration value="SWC-OBD-MONITOR-SERVICE-NEEDS"/>
         <xsd:enumeration value="SWC-OBD-PID-SERVICE-NEEDS"/>
         <xsd:enumeration value="SWC-OBD-RATIO-SERVICE-NEEDS"/>
         <xsd:enumeration value="SWC-SUPERVISED-ENTITY-NEEDS"/>
         <xsd:enumeration value="SWC-TO-ECU-MAPPING"/>
         <xsd:enumeration value="SWC-TO-IMPL-MAPPING"/>
         <xsd:enumeration value="SYMBOLIC-NAME-REFERENCE-PARAM-DEF"/>
         <xsd:enumeration value="SYNCHRONOUS-SERVER-CALL-POINT"/>
         <xsd:enumeration value="SYSTEM"/>
         <xsd:enumeration value="SYSTEM-MAPPING"/>
         <xsd:enumeration value="SYSTEM-SIGNAL"/>
         <xsd:enumeration value="SYSTEM-SIGNAL-GROUP"/>
         <xsd:enumeration value="TIMER"/>
         <xsd:enumeration value="TIMING-EVENT"/>
         <xsd:enumeration value="TP-ADDRESS"/>
         <xsd:enumeration value="UNIT"/>
         <xsd:enumeration value="UNIT-GROUP"/>
         <xsd:enumeration value="USER-DEFINED-I-PDU"/>
         <xsd:enumeration value="USER-DEFINED-PDU"/>
         <xsd:enumeration value="WAIT-POINT"/>
         <xsd:enumeration value="WATCH-DOG"/>
         <xsd:enumeration value="WORST-CASE-EXECUTION-TIME"/>
         <xsd:enumeration value="WORST-CASE-HEAP-USAGE"/>
         <xsd:enumeration value="WORST-CASE-STACK-USAGE"/>
         <xsd:enumeration value="XDOC"/>
         <xsd:enumeration value="XFILE-SO"/>
         <xsd:enumeration value="XREF-TARGET"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- complex type for class Inlines::Ie -->
   <xsd:complexType abstract="false" mixed="true" name="IE">
      <xsd:annotation>
         <xsd:documentation>Use &lt;ie&gt; to create an index that is to appear in the index directory.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Ie"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0"/>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Implementation::Implementation -->
   <xsd:group name="IMPLEMENTATION">
      <xsd:annotation>
         <xsd:documentation>Description of an implementation a single software component or module.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Implementation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CODE-DESCRIPTORS">
            <xsd:annotation>
               <xsd:documentation>Specifies the provided implementation code.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="codeDescriptor.Implementation";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CODE" type="AR:CODE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CODE-GENERATOR" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Optional: code generator used.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Implementation.codeGenerator";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPILERS">
            <xsd:annotation>
               <xsd:documentation>Specifies the compiler for which this implementation has been released</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="compiler.Implementation";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="COMPILER" type="AR:COMPILER"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="IMPLEMENTATION-DEPENDENCIES">
            <xsd:annotation>
               <xsd:documentation>Specifies details on dependent software, modules or libraries.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="implementationDependency.Implementation";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.namePlural="IMPLEMENTATION-DEPENDENCIES"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="DEPENDENCY-ON-FILE" type="AR:DEPENDENCY-ON-FILE"/>
                  <xsd:element name="DEPENDENCY-ON-LIBRARY" type="AR:DEPENDENCY-ON-LIBRARY"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="LINKERS">
            <xsd:annotation>
               <xsd:documentation>Specifies the linker for which this implementation has been released.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="linker.Implementation";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="LINKER" type="AR:LINKER"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PROCESSOR-REFS">
            <xsd:annotation>
               <xsd:documentation>The processor the implementation is compatible with.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Implementation.processor";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="PROCESSOR-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:PROCESSING-UNIT--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PROGRAMMING-LANGUAGE" type="AR:PROGRAMMINGLANGUAGE-ENUM">
            <xsd:annotation>
               <xsd:documentation>Programming language the implementation was created in.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Implementation.programmingLanguage";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RESOURCE-CONSUMPTION" type="AR:RESOURCE-CONSUMPTION">
            <xsd:annotation>
               <xsd:documentation>All static and dynamic resources for each implementation are described  within the ResourceConsumption class.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="resourceConsumption.Implementation";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-MAJOR-VERSION" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Major version number of this implementation. The numbering is vendor specific.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Implementation.swMajorVersion";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-MINOR-VERSION" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Minor version number of this implementation. The numbering is vendor specific.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Implementation.swMinorVersion";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-PATCH-VERSION" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Patch version number of this implementation. The numbering is vendor specific.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Implementation.swPatchVersion";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VENDOR-ID" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Vendor ID of this Implementation according to the AUTOSAR vendor list</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Implementation.vendorId";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Implementation::Implementation -->
   <xsd:complexType abstract="false" mixed="false" name="IMPLEMENTATION">
      <xsd:annotation>
         <xsd:documentation>Description of an implementation a single software component or module.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Implementation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:IMPLEMENTATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUCParameterDefTemplate::ImplementationConfigClass -->
   <xsd:group name="IMPLEMENTATION-CONFIG-CLASS">
      <xsd:annotation>
         <xsd:documentation>Specifies which ConfigurationClass this parameter has in the individual ConfigurationVariants.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ImplementationConfigClass"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONFIG-CLASS" type="AR:CONFIGURATION-CLASS">
            <xsd:annotation>
               <xsd:documentation>Specifies the ConfigurationClass for the given ConfigurationVariant.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ImplementationConfigClass.configClass";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONFIG-VARIANT" type="AR:CONFIGURATION-VARIANT">
            <xsd:annotation>
               <xsd:documentation>Specifies the ConfigurationVariant the ConfigurationClass is specified for.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ImplementationConfigClass.configVariant";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::ImplementationConfigClass -->
   <xsd:complexType abstract="false" mixed="false" name="IMPLEMENTATION-CONFIG-CLASS">
      <xsd:annotation>
         <xsd:documentation>Specifies which ConfigurationClass this parameter has in the individual ConfigurationVariants.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ImplementationConfigClass"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IMPLEMENTATION-CONFIG-CLASS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataMapping::IndexedArrayElement -->
   <xsd:group name="INDEXED-ARRAY-ELEMENT">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IndexedArrayElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,indexedRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ARRAY-ELEMENT-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to an element in an array.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IndexedArrayElement.arrayElement";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ARRAY-ELEMENT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INDEX" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Position of an element in an array.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IndexedArrayElement.index";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataMapping::IndexedArrayElement -->
   <xsd:complexType abstract="false" mixed="false" name="INDEXED-ARRAY-ELEMENT">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IndexedArrayElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,indexedRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:INDEXED-ARRAY-ELEMENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ComponentLocalCalprm::InitValueAssignment -->
   <xsd:group name="INIT-VALUE-ASSIGNMENT">
      <xsd:annotation>
         <xsd:documentation>This represents the ablity to assign an initial value to a calibration parameter.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="InitValueAssignment"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="INIT-VALUE-REF">
            <xsd:annotation>
               <xsd:documentation>This is the init value.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InitValueAssignment.initValue";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.SequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:VALUE-SPECIFICATION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PARAMETER-REF">
            <xsd:annotation>
               <xsd:documentation>This is the parameter for which the initial value applies.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InitValueAssignment.parameter";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.SequenceOffset="10"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:CALPRM-ELEMENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class ECUCParameterDefTemplate::InstanceReferenceParamDef -->
   <xsd:group name="INSTANCE-REFERENCE-PARAM-DEF">
      <xsd:annotation>
         <xsd:documentation>Specify a reference to an XML description of an entity desribed in another AUTOSAR template using the INSTANCE REFERENCE semantics.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="InstanceReferenceParamDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DESTINATION-CONTEXT" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>The context in the AUTOSAR Metamodel to which' this reference is allowed to point to.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InstanceReferenceParamDef.destinationContext";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DESTINATION-TYPE" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>The type in the AUTOSAR Metamodel to which' instance this reference is allowed to point to.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InstanceReferenceParamDef.destinationType";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::InstanceReferenceParamDef -->
   <xsd:complexType abstract="false" mixed="false" name="INSTANCE-REFERENCE-PARAM-DEF">
      <xsd:annotation>
         <xsd:documentation>Specify a reference to an XML description of an entity desribed in another AUTOSAR template using the INSTANCE REFERENCE semantics.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="InstanceReferenceParamDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PARAM-CONF-MULTIPLICITY"/>
         <xsd:group ref="AR:COMMON-CONFIGURATION-ATTRIBUTES"/>
         <xsd:group ref="AR:INSTANCE-REFERENCE-PARAM-DEF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUCDescriptionTemplate::InstanceReferenceValue -->
   <xsd:group name="INSTANCE-REFERENCE-VALUE">
      <xsd:annotation>
         <xsd:documentation>InstanceReference representation in the ECU Configuration.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="InstanceReferenceValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VALUE-IREF" type="AR:INSTANCE-REFERENCE-VALUE--VALUE-IREF">
            <xsd:annotation>
               <xsd:documentation>InstanceReference representation in the ECU Configuration.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="value.InstanceReferenceValue";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCDescriptionTemplate::InstanceReferenceValue -->
   <xsd:complexType abstract="false" mixed="false" name="INSTANCE-REFERENCE-VALUE">
      <xsd:annotation>
         <xsd:documentation>InstanceReference representation in the ECU Configuration.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="InstanceReferenceValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:CONFIG-REFERENCE-VALUE"/>
         <xsd:group ref="AR:INSTANCE-REFERENCE-VALUE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class _instanceRef::InstanceReferenceValue_value -->
   <xsd:group name="INSTANCE-REFERENCE-VALUE--VALUE-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="InstanceReferenceValue_value"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="CONTEXT-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InstanceReferenceValue_value.context";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="10"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:IDENTIFIABLE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="1" name="VALUE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InstanceReferenceValue_value.value";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.target</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:IDENTIFIABLE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class _instanceRef::InstanceReferenceValue_value -->
   <xsd:complexType abstract="false" mixed="false" name="INSTANCE-REFERENCE-VALUE--VALUE-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="InstanceReferenceValue_value"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:INSTANCE-REFERENCE-VALUE--VALUE-IREF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Constants::IntegerLiteral -->
   <xsd:group name="INTEGER-LITERAL">
      <xsd:annotation>
         <xsd:documentation>Constant integer value.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IntegerLiteral"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VALUE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The value.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IntegerLiteral.value";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Constants::IntegerLiteral -->
   <xsd:complexType abstract="false" mixed="false" name="INTEGER-LITERAL">
      <xsd:annotation>
         <xsd:documentation>Constant integer value.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IntegerLiteral"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:DATA-PROTOTYPE"/>
         <xsd:group ref="AR:INTEGER-LITERAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUCParameterDefTemplate::IntegerParamDef -->
   <xsd:group name="INTEGER-PARAM-DEF">
      <xsd:annotation>
         <xsd:documentation>Configuration parameter type for Integer.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IntegerParamDef";xml.sequenceOffset="0"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DEFAULT-VALUE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Default value of the integer configuration parameter.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IntegerParamDef.defaultValue";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>max value allowed for the parameter defined.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IntegerParamDef.max";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MIN" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>min value allowed for the parameter defined.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IntegerParamDef.min";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::IntegerParamDef -->
   <xsd:complexType abstract="false" mixed="false" name="INTEGER-PARAM-DEF">
      <xsd:annotation>
         <xsd:documentation>Configuration parameter type for Integer.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IntegerParamDef";xml.sequenceOffset="0"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PARAM-CONF-MULTIPLICITY"/>
         <xsd:group ref="AR:COMMON-CONFIGURATION-ATTRIBUTES"/>
         <xsd:group ref="AR:CONFIG-PARAMETER"/>
         <xsd:group ref="AR:INTEGER-PARAM-DEF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- complex type for class Datatypes::IntegerType -->
   <xsd:complexType abstract="false" mixed="false" name="INTEGER-TYPE">
      <xsd:annotation>
         <xsd:documentation>This data-type are the integers in the interval defined by the Range.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IntegerType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpType</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PRIMITIVE-TYPE"/>
         <xsd:group ref="AR:RANGE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUCDescriptionTemplate::IntegerValue -->
   <xsd:group name="INTEGER-VALUE">
      <xsd:annotation>
         <xsd:documentation>Representing a configuration value of definition type IntegerParamDef</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IntegerValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VALUE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Stores the value of the Integer parameter.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IntegerValue.value";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCDescriptionTemplate::IntegerValue -->
   <xsd:complexType abstract="false" mixed="false" name="INTEGER-VALUE">
      <xsd:annotation>
         <xsd:documentation>Representing a configuration value of definition type IntegerParamDef</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IntegerValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:PARAMETER-VALUE"/>
         <xsd:group ref="AR:INTEGER-VALUE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class InterRunnableCommunication::InterRunnableVariable -->
   <xsd:group name="INTER-RUNNABLE-VARIABLE">
      <xsd:annotation>
         <xsd:documentation>Implement state message semantics for establishing communication among runnables of the same component.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="InterRunnableVariable"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMMUNICATION-APPROACH" type="AR:COMMUNICATION-APPROACH-TYPE">
            <xsd:annotation>
               <xsd:documentation>Communication among RunnableEntities resembles the approaches taken for the communication among software components. The explicit communication corresponds to DataReceivePoint/DataSendPoint. The implicit communication resembles DataReadAccess/DataWriteAccess</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InterRunnableVariable.communicationApproach";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INIT-VALUE-REF">
            <xsd:annotation>
               <xsd:documentation>This represents the initial value of the InterRunnabelVariable.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InterRunnableVariable.initValue";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:VALUE-SPECIFICATION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class InterRunnableCommunication::InterRunnableVariable -->
   <xsd:complexType abstract="false" mixed="false" name="INTER-RUNNABLE-VARIABLE">
      <xsd:annotation>
         <xsd:documentation>Implement state message semantics for establishing communication among runnables of the same component.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="InterRunnableVariable"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:DATA-PROTOTYPE"/>
         <xsd:group ref="AR:INTER-RUNNABLE-VARIABLE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="INTER-RUNNABLE-VARIABLE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="INTER-RUNNABLE-VARIABLE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class SwcInternalBehavior::InternalBehavior -->
   <xsd:group name="INTERNAL-BEHAVIOR">
      <xsd:annotation>
         <xsd:documentation>The internal behavior of an atomic software component describes the RTE relevant aspects of a component, i.e. the runnable entities and the events they respond to.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="InternalBehavior"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPONENT-REF">
            <xsd:annotation>
               <xsd:documentation>The component this behavior is defined for.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InternalBehavior.component";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ATOMIC-SOFTWARE-COMPONENT-TYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EVENTS">
            <xsd:annotation>
               <xsd:documentation>This is a RTEEvent specified for the particular InternalBehavior.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="event.InternalBehavior";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ASYNCHRONOUS-SERVER-CALL-RETURNS-EVENT" type="AR:ASYNCHRONOUS-SERVER-CALL-RETURNS-EVENT"/>
                  <xsd:element name="DATA-RECEIVE-ERROR-EVENT" type="AR:DATA-RECEIVE-ERROR-EVENT"/>
                  <xsd:element name="DATA-RECEIVED-EVENT" type="AR:DATA-RECEIVED-EVENT"/>
                  <xsd:element name="DATA-SEND-COMPLETED-EVENT" type="AR:DATA-SEND-COMPLETED-EVENT"/>
                  <xsd:element name="MODE-SWITCH-EVENT" type="AR:MODE-SWITCH-EVENT"/>
                  <xsd:element name="MODE-SWITCHED-ACK-EVENT" type="AR:MODE-SWITCHED-ACK-EVENT"/>
                  <xsd:element name="OPERATION-INVOKED-EVENT" type="AR:OPERATION-INVOKED-EVENT"/>
                  <xsd:element name="TIMING-EVENT" type="AR:TIMING-EVENT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EXCLUSIVE-AREAS">
            <xsd:annotation>
               <xsd:documentation>This specifies an ExclusiveArea for this InternalBehavior. The exclusiveArea is local to a software-component.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="exclusiveArea.InternalBehavior";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="EXCLUSIVE-AREA" type="AR:EXCLUSIVE-AREA"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INIT-VALUES">
            <xsd:annotation>
               <xsd:documentation>This represents the initial value for the owned parameter.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InternalBehavior.initValue";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="LOCAL-PARAMETER-INIT-VALUE-ASSIGNMENT" type="AR:LOCAL-PARAMETER-INIT-VALUE-ASSIGNMENT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INTER-RUNNABLE-VARIABLES">
            <xsd:annotation>
               <xsd:documentation>Implement state message semantics for establishing communication among RunnabelEntities of the same software-component.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="interRunnableVariable.InternalBehavior";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="INTER-RUNNABLE-VARIABLE" type="AR:INTER-RUNNABLE-VARIABLE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PER-INSTANCE-CALPRMS">
            <xsd:annotation>
               <xsd:documentation>the perInstanceCalprm is aggregated in the internal behavior, since it is read only. Therefore not protection mechanisms are necessary regardless which runnable performs the access</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="perInstanceCalprm.InternalBehavior";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CALPRM-ELEMENT-PROTOTYPE" type="AR:CALPRM-ELEMENT-PROTOTYPE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PER-INSTANCE-MEMORYS">
            <xsd:annotation>
               <xsd:documentation>Defines a per-instance memory object needed by this software component.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="perInstanceMemory.InternalBehavior";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="PER-INSTANCE-MEMORY" type="AR:PER-INSTANCE-MEMORY"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PORT-API-OPTIONS">
            <xsd:annotation>
               <xsd:documentation>Options for generating the signature of port-related calls from a runnable to the RTE and vice versa.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="portAPIOption.InternalBehavior";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="PORT-API-OPTION" type="AR:PORT-API-OPTION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RUNNABLES">
            <xsd:annotation>
               <xsd:documentation>This is a RunnableEntity specified for the particular InternalBehavior.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="runnable.behavior";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="RUNNABLE-ENTITY" type="AR:RUNNABLE-ENTITY"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SERVICE-NEEDSS">
            <xsd:annotation>
               <xsd:documentation>the requirements on an AUTOSAR Service defined by this InternalBehavior</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InternalBehavior.serviceNeeds";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="COM-MGR-USER-NEEDS" type="AR:COM-MGR-USER-NEEDS"/>
                  <xsd:element name="DIAGNOSTIC-COMMUNICATION-NEEDS" type="AR:DIAGNOSTIC-COMMUNICATION-NEEDS"/>
                  <xsd:element name="DIAGNOSTIC-EVENT-NEEDS" type="AR:DIAGNOSTIC-EVENT-NEEDS"/>
                  <xsd:element name="ECU-STATE-MGR-USER-NEEDS" type="AR:ECU-STATE-MGR-USER-NEEDS"/>
                  <xsd:element name="FUNCTION-INHIBITION-NEEDS" type="AR:FUNCTION-INHIBITION-NEEDS"/>
                  <xsd:element name="NV-BLOCK-NEEDS" type="AR:NV-BLOCK-NEEDS"/>
                  <xsd:element name="OBD-CONTROL-SERVICE-NEEDS" type="AR:OBD-CONTROL-SERVICE-NEEDS"/>
                  <xsd:element name="OBD-INFO-SERVICE-NEEDS" type="AR:OBD-INFO-SERVICE-NEEDS"/>
                  <xsd:element name="OBD-MONITOR-SERVICE-NEEDS" type="AR:OBD-MONITOR-SERVICE-NEEDS"/>
                  <xsd:element name="OBD-PID-SERVICE-NEEDS" type="AR:OBD-PID-SERVICE-NEEDS"/>
                  <xsd:element name="OBD-RATIO-SERVICE-NEEDS" type="AR:OBD-RATIO-SERVICE-NEEDS"/>
                  <xsd:element name="SERVICE-NEEDS" type="AR:SERVICE-NEEDS"/>
                  <xsd:element name="SUPERVISED-ENTITY-NEEDS" type="AR:SUPERVISED-ENTITY-NEEDS"/>
                  <xsd:element name="SWC-COM-MGR-USER-NEEDS" type="AR:SWC-COM-MGR-USER-NEEDS"/>
                  <xsd:element name="SWC-DIAGNOSTIC-COMMUNICATION-NEEDS" type="AR:SWC-DIAGNOSTIC-COMMUNICATION-NEEDS"/>
                  <xsd:element name="SWC-DIAGNOSTIC-EVENT-NEEDS" type="AR:SWC-DIAGNOSTIC-EVENT-NEEDS"/>
                  <xsd:element name="SWC-ECU-STATE-MGR-USER-NEEDS" type="AR:SWC-ECU-STATE-MGR-USER-NEEDS"/>
                  <xsd:element name="SWC-FUNCTION-INHIBITION-NEEDS" type="AR:SWC-FUNCTION-INHIBITION-NEEDS"/>
                  <xsd:element name="SWC-NV-BLOCK-NEEDS" type="AR:SWC-NV-BLOCK-NEEDS"/>
                  <xsd:element name="SWC-OBD-CONTROL-SERVICE-NEEDS" type="AR:SWC-OBD-CONTROL-SERVICE-NEEDS"/>
                  <xsd:element name="SWC-OBD-INFO-SERVICE-NEEDS" type="AR:SWC-OBD-INFO-SERVICE-NEEDS"/>
                  <xsd:element name="SWC-OBD-MONITOR-SERVICE-NEEDS" type="AR:SWC-OBD-MONITOR-SERVICE-NEEDS"/>
                  <xsd:element name="SWC-OBD-PID-SERVICE-NEEDS" type="AR:SWC-OBD-PID-SERVICE-NEEDS"/>
                  <xsd:element name="SWC-OBD-RATIO-SERVICE-NEEDS" type="AR:SWC-OBD-RATIO-SERVICE-NEEDS"/>
                  <xsd:element name="SWC-SUPERVISED-ENTITY-NEEDS" type="AR:SWC-SUPERVISED-ENTITY-NEEDS"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SHARED-CALPRMS">
            <xsd:annotation>
               <xsd:documentation>Defines parameter(s) or characteristic value(s) shared between ComponentPrototypes of the same ComponentType.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="sharedCalprm.InternalBehavior";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CALPRM-ELEMENT-PROTOTYPE" type="AR:CALPRM-ELEMENT-PROTOTYPE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SUPPORTS-MULTIPLE-INSTANTIATION" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Indicate whether the corresponding software-component can be multiply instantiated on one ECU. In this case the attribute will result in an appropriate component API on programming language level (with or without instance handle).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InternalBehavior.supportsMultipleInstantiation";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SwcInternalBehavior::InternalBehavior -->
   <xsd:complexType abstract="false" mixed="false" name="INTERNAL-BEHAVIOR">
      <xsd:annotation>
         <xsd:documentation>The internal behavior of an atomic software component describes the RTE relevant aspects of a component, i.e. the runnable entities and the events they respond to.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="InternalBehavior"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:INTERNAL-BEHAVIOR"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="INTERNAL-BEHAVIOR--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="INTERNAL-BEHAVIOR"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class GlobalConstraints::InternalConstrs -->
   <xsd:group name="INTERNAL-CONSTRS">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="InternalConstrs"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="LOWER-LIMIT" type="AR:LIMIT">
            <xsd:annotation>
               <xsd:documentation>This element specifies the lower limit of a closed, half-open or open interval. It can also be set to infinity by setting the attribute INTERVAL-TYPE to INFINITE. No value has to be set in the case of an infinite interval.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InternalConstrs.lowerLimit";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="UPPER-LIMIT" type="AR:LIMIT">
            <xsd:annotation>
               <xsd:documentation>This element specifies the upper limit of a closed, half-open or open interval. It can also be set to infinity by setting the attribute INTERVAL-TYPE to INFINITE. No value has to be set in the case of an infinite interval.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InternalConstrs.upperLimit";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SCALE-CONSTRS">
            <xsd:annotation>
               <xsd:documentation>This is one particular scale in which contributes to the data constraints.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InternalConstrs.scaleConstr";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="true";xml.roleWrapperElement="true";xml.sequenceOffset="40";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SCALE-CONSTR" type="AR:SCALE-CONSTR"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-GRADIENT" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>This element specifies the maximum slope that may be used in maps and curves.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InternalConstrs.maxGradient";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-DIFF" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Maximum difference that is permitted between two consecutive values if the constraint is applied to an axis.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InternalConstrs.maxDiff";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="60"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MONOTONY" type="AR:MONOTONY-ENUM">
            <xsd:annotation>
               <xsd:documentation>This element specifies the monotony characteristics of the current internal or physical limits. The following table shows the monotony characteristics which are to be filled through the corresponding values. If the element has no contents or if it is omitted, "no-monotony" is the default content.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InternalConstrs.monotony";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="70"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class GlobalConstraints::InternalConstrs -->
   <xsd:complexType abstract="false" mixed="false" name="INTERNAL-CONSTRS">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="InternalConstrs"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:INTERNAL-CONSTRS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ProcessingUnit::InterruptConsumeHWPort -->
   <xsd:group name="INTERRUPT-CONSUME-HW-PORT">
      <xsd:annotation>
         <xsd:documentation>This port represents the drain of an interrupt request, i.e. the HWElement (in the majority of cases this will be a ProcessingUnit) to which this HWPort is attached is capable of accepting interrupt requests.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="InterruptConsumeHWPort"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ACTIVATION-SOURCE" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Defines which hardware resource activate the interrupt. Typically any peripheral HW Element  can activate an interrupt.  E.g. CAN, SCI, SPI, Timer, ADC. Even simple digital I/O can activate an interrupt. Some microC have in this context dedicatated pins which act only as activation for interrupt. The connection from the according HW Element is made by the HW Port.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InterruptConsumeHWPort.activationSource";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="LATENCY" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Interrupt Latency: time passed from the occurrence of the interrupt request until the interrupt service routine is entered
            - HW: Register organisation; operations are necessary for context save.
            - SW: As SW can control the enabling/disabling of the interrupt SW determines a great part of the according time.
            - System: several constraints define the min/max times allowed for software to enable / disable interrupts.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InterruptConsumeHWPort.latency";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MASKABLE" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Defines if interrupts can be selected to be processed by the interrupt controller.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InterruptConsumeHWPort.maskable";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PRIORITY" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Some processing units offer different interrupt levels. It describes the priority in which the incoming interrupts are handled.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="InterruptConsumeHWPort.priority";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ProcessingUnit::InterruptConsumeHWPort -->
   <xsd:complexType abstract="false" mixed="false" name="INTERRUPT-CONSUME-HW-PORT">
      <xsd:annotation>
         <xsd:documentation>This port represents the drain of an interrupt request, i.e. the HWElement (in the majority of cases this will be a ProcessingUnit) to which this HWPort is attached is capable of accepting interrupt requests.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="InterruptConsumeHWPort"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HW-PORT"/>
         <xsd:group ref="AR:INTERRUPT-CONSUME-HW-PORT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- complex type for class ProcessingUnit::InterruptProduceHWPort -->
   <xsd:complexType abstract="false" mixed="false" name="INTERRUPT-PRODUCE-HW-PORT">
      <xsd:annotation>
         <xsd:documentation>This port represents the source of an interrupt request, i.e. the HWElement to which this port is attached is capable of raising interrupt requests.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="InterruptProduceHWPort"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HW-PORT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="INTERRUPT-PRODUCE-HW-PORT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="INTERRUPT-PRODUCE-HW-PORT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ApplicationAttributes::IoHwAbstractionServerAnnotation -->
   <xsd:group name="IO-HW-ABSTRACTION-SERVER-ANNOTATION">
      <xsd:annotation>
         <xsd:documentation>The IoHwAbstractionPort Annotation will only be used from a sensor- or an actuator component while interacting with the IoHwAbstraction layer</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IoHwAbstractionServerAnnotation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="AGE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>In case of a SET operation, the age will be interpreted as Delay while in a GET operation (input) it specifies the Lifetime of the signal within the IoHwAbstraction Layer</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IoHwAbstractionServerAnnotation.Age";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ARGUMENT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the corresponding ArgumentPrototype. The IoHwAbstractionServerAnnotation can be applied either to sender-receiver or to client-server communication. This association only applies in the latter case</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IoHwAbstractionServerAnnotation.argumentPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ARGUMENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="BSW-RANGE-MAX" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Specifies the maximum value of the Range the ECU-Signal is supposed to have</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IoHwAbstractionServerAnnotation.BswRangeMax";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="BSW-RANGE-MIN" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Specifies the maximum value of the Range the ECU-Signal is supposed to have.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IoHwAbstractionServerAnnotation.BswRangeMin";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="BSW-RESOLUTION" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>This value is determined by an appropriate combination of the range, the unit as well as the data-elements type, i.e. (BswRangeMax-BswRangeMin) / (2^datatypelength - 1)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IoHwAbstractionServerAnnotation.BswResolution";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-ELEMENT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the corresponding DataElementPrototype. The IoHwAbstractionServerAnnotation can be applied either to sender-receiver or to client-server communication. This association only applies in the former case</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IoHwAbstractionServerAnnotation.dataElementPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:DATA-ELEMENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FAILURE-MONITORING-REF">
            <xsd:annotation>
               <xsd:documentation>This is only applicable in SET operations. If it is enabled, the IoHwAbstraction layer will monitor the result of the operation and issue an diagnostic signal. This means especially, that an additional client-server port has to be created. Tools can use this information to cross-check whether for each data-element in a SET operation with FailureMonitoring enabled an additional port is created

            The referenced port monitors a failure in the to be monitored data-element of the IoHwAbstraction layer. The referenced port has to be another port of the same Actuator or Sensor Component.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IoHwAbstractionServerAnnotation.failureMonitoring";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FILTERING-DEBOUNCING" type="AR:FILTER-DEBOUNCING-ENUM">
            <xsd:annotation>
               <xsd:documentation>This attribute is used to indicate what kind of filtering/debouncing has been put to the signal in the IoHwAbstraction layer. 

            rawData means that no modification of the signal has been applied.This is the default value
            debounceData means that the signal is a mean value
            waitTimeData means that the signal is delivered by a GET operation after a certain amount of time</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IoHwAbstractionServerAnnotation.FilteringDebouncing";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PULSE-TEST" type="AR:PULSE-TEST-ENUM">
            <xsd:annotation>
               <xsd:documentation>This attribute indicates to the connected SensorActuatorSoftwareComponentType whether the DataElementPrototype can be used to generate pulse test sequences using the IoHwAbstraction layer</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IoHwAbstractionServerAnnotation.PulseTest";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SUPPORTS-REPORT-RUNNABLE" type="AR:REPORT-FEATURE">
            <xsd:annotation>
               <xsd:documentation>Calrifies whether a report RunnableEntity is supported,</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="supportsReportRunnable.IoHwAbstractionServerAnnotation";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SUPPORTS-WAKE-UP-RUNNABLE" type="AR:WAKE-UP">
            <xsd:annotation>
               <xsd:documentation>Clarifies whether a wake-up RunnableEntity is supported.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="supportsWakeUpRunnable.IoHwAbstractionServerAnnotation";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="UNIT" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>These are either electrical units like Volts (V) or time units like milliseconds (ms). The unit is set according to the ECU Input signal class which is either analogue or modulation</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="IoHwAbstractionServerAnnotation.Unit";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ApplicationAttributes::IoHwAbstractionServerAnnotation -->
   <xsd:complexType abstract="false" mixed="false" name="IO-HW-ABSTRACTION-SERVER-ANNOTATION">
      <xsd:annotation>
         <xsd:documentation>The IoHwAbstractionPort Annotation will only be used from a sensor- or an actuator component while interacting with the IoHwAbstraction layer</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="IoHwAbstractionServerAnnotation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:GENERAL-ANNOTATION"/>
         <xsd:group ref="AR:IO-HW-ABSTRACTION-SERVER-ANNOTATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- attribute group for class LanguageDataModel::L1 -->
   <xsd:attributeGroup name="L-1">
      <xsd:annotation>
         <xsd:documentation>ParagraphInOneParticularLanguage

      This is the text for a paragraph in one particular language. The language is denoted in the attribute l.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="L1"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="L" type="AR:L-ENUM">
         <xsd:annotation>
            <xsd:appinfo source="tags">mmt.qualifiedName="L1.l";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class LanguageDataModel::L1 -->
   <xsd:complexType abstract="false" mixed="true" name="L-1">
      <xsd:annotation>
         <xsd:documentation>ParagraphInOneParticularLanguage

      This is the text for a paragraph in one particular language. The language is denoted in the attribute l.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="L1"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:MIXED-CONTENT-1"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:L-1"/>
   </xsd:complexType>
   <!-- attribute group for class LanguageDataModel::L10 -->
   <xsd:attributeGroup name="L-10">
      <xsd:annotation>
         <xsd:documentation>MixedContentForPlainText in one particular language. The language is dentoted in the attribute l.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="L10"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="L" type="AR:L-ENUM">
         <xsd:annotation>
            <xsd:appinfo source="tags">mmt.qualifiedName="L10.l";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class LanguageDataModel::L10 -->
   <xsd:complexType abstract="false" mixed="true" name="L-10">
      <xsd:annotation>
         <xsd:documentation>MixedContentForPlainText in one particular language. The language is dentoted in the attribute l.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="L10"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0"/>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:L-10"/>
   </xsd:complexType>
   <!-- attribute group for class LanguageDataModel::L2 -->
   <xsd:attributeGroup name="L-2">
      <xsd:annotation>
         <xsd:documentation>MixedContentForOverviewParagraph in one particular language. The language is dentoted in the attribute l.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="L2"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="L" type="AR:L-ENUM">
         <xsd:annotation>
            <xsd:appinfo source="tags">mmt.qualifiedName="L2.l";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class LanguageDataModel::L2 -->
   <xsd:complexType abstract="false" mixed="true" name="L-2">
      <xsd:annotation>
         <xsd:documentation>MixedContentForOverviewParagraph in one particular language. The language is dentoted in the attribute l.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="L2"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0"/>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:L-2"/>
   </xsd:complexType>
   <!-- attribute group for class LanguageDataModel::L3 -->
   <xsd:attributeGroup name="L-3">
      <xsd:annotation>
         <xsd:documentation>MixedContentForUnitNames in one particular language. The language is dentoted in the attribute l.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="L3"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="L" type="AR:L-ENUM">
         <xsd:annotation>
            <xsd:appinfo source="tags">mmt.qualifiedName="L3.l";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class LanguageDataModel::L3 -->
   <xsd:complexType abstract="false" mixed="true" name="L-3">
      <xsd:annotation>
         <xsd:documentation>MixedContentForUnitNames in one particular language. The language is dentoted in the attribute l.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="L3"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0"/>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:L-3"/>
   </xsd:complexType>
   <!-- attribute group for class LanguageDataModel::L4 -->
   <xsd:attributeGroup name="L-4">
      <xsd:annotation>
         <xsd:documentation>MixedContentForLongNames  in one particular language. The language is dentoted in the attribute l.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="L4"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="L" type="AR:L-ENUM">
         <xsd:annotation>
            <xsd:appinfo source="tags">mmt.qualifiedName="L4.l";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class LanguageDataModel::L4 -->
   <xsd:complexType abstract="false" mixed="true" name="L-4">
      <xsd:annotation>
         <xsd:documentation>MixedContentForLongNames  in one particular language. The language is dentoted in the attribute l.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="L4"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0"/>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:L-4"/>
   </xsd:complexType>
   <!-- attribute group for class LanguageDataModel::L5 -->
   <xsd:attributeGroup name="L-5">
      <xsd:annotation>
         <xsd:documentation>MixedContentForVerbatim in one particular language. The language is dentoted in the attribute l.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="L5"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="L" type="AR:L-ENUM">
         <xsd:annotation>
            <xsd:appinfo source="tags">mmt.qualifiedName="L5.l";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class LanguageDataModel::L5 -->
   <xsd:complexType abstract="false" mixed="true" name="L-5">
      <xsd:annotation>
         <xsd:documentation>MixedContentForVerbatim in one particular language. The language is dentoted in the attribute l.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="L5"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0"/>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:L-5"/>
   </xsd:complexType>
   <!-- attribute group for class LocalConstraints::Limit -->
   <xsd:attributeGroup name="LIMIT">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Limit"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="INTERVAL-TYPE" type="AR:INTERVAL-TYPE-ENUM">
         <xsd:annotation>
            <xsd:documentation>This specifies the type of the interval. If the attribute is missing the interval shall be considered as "CLOSED".</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Limit.intervalType";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class LocalConstraints::Limit -->
   <xsd:complexType abstract="false" mixed="true" name="LIMIT">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Limit"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0"/>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:LIMIT"/>
   </xsd:complexType>
   <!-- element group for class LinTopology::LinCluster -->
   <xsd:group name="LIN-CLUSTER">
      <xsd:annotation>
         <xsd:documentation>LIN specific attributes</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinCluster"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpStructureElement</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SCHEDULE-TABLES">
            <xsd:annotation>
               <xsd:documentation>Schedule tables organize the Timings of the frames for LIN.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="scheduleTable.LinCluster";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="LIN-SCHEDULE-TABLE" type="AR:LIN-SCHEDULE-TABLE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class LinTopology::LinCluster -->
   <xsd:complexType abstract="false" mixed="false" name="LIN-CLUSTER">
      <xsd:annotation>
         <xsd:documentation>LIN specific attributes</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinCluster"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpStructureElement</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COMMUNICATION-CLUSTER"/>
         <xsd:group ref="AR:LIN-CLUSTER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="LIN-COMMUNICATION-CONTROLLER--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="LIN-MASTER"/>
         <xsd:enumeration value="LIN-SLAVE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class LinCommunication::LinErrorResponse -->
   <xsd:group name="LIN-ERROR-RESPONSE">
      <xsd:annotation>
         <xsd:documentation>Each slave node shall publish a one bit signal, named response_error, to the master node in one of its transmitted unconditional frames. The response_error signal shall be set whenever a frame (except for event triggered frame responses) that is transmitted or received by the slave node contains an error in the frame response. The response_error signal shall be cleared when the unconditional frame containing the response_error signal is successfully transmitted.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinErrorResponse"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="FRAME-TRIGGERING-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to an unconditional frame  that transmits the response error. The referenced LinFrameTriggering shall contain a reference to an unconditionalFrame.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinErrorResponse.frameTriggering";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:LIN-FRAME-TRIGGERING--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RESPONSE-ERROR-POSITION" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Specifies the position of the ResponseError bit in the frame. Each slave node shall publish one response error in one of its transmitted unconditional frames.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinErrorResponse.responseErrorPosition";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class LinCommunication::LinErrorResponse -->
   <xsd:complexType abstract="false" mixed="false" name="LIN-ERROR-RESPONSE">
      <xsd:annotation>
         <xsd:documentation>Each slave node shall publish a one bit signal, named response_error, to the master node in one of its transmitted unconditional frames. The response_error signal shall be set whenever a frame (except for event triggered frame responses) that is transmitted or received by the slave node contains an error in the frame response. The response_error signal shall be cleared when the unconditional frame containing the response_error signal is successfully transmitted.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinErrorResponse"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:LIN-ERROR-RESPONSE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class LinCommunication::LinFrameTriggering -->
   <xsd:group name="LIN-FRAME-TRIGGERING">
      <xsd:annotation>
         <xsd:documentation>Lin specific attributes to the FrameTriggering</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinFrameTriggering"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CHECKSUM-TYPE" type="AR:LIN-CHECKSUM-TYPE">
            <xsd:annotation>
               <xsd:documentation>Type of checksum that the frame is using.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinFrameTriggering.checksumType";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="IDENTIFIER" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>To describe a frames identifier on the communication system, usualy with a fixed identifierValue.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinFrameTriggering.identifier";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RELATIVELY-SCHEDULED-TIMINGS">
            <xsd:annotation>
               <xsd:documentation>Specification of a sending behaviour where the transmission order is predefined.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="relativelyScheduledTiming.LinFrameTriggering";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ASSIGN-FRAME-ID-TIMING" type="AR:ASSIGN-FRAME-ID-TIMING"/>
                  <xsd:element name="ASSIGN-NAD-TIMING" type="AR:ASSIGN-NAD-TIMING"/>
                  <xsd:element name="DATA-TIMING" type="AR:DATA-TIMING"/>
                  <xsd:element name="RELATIVELY-SCHEDULED-TIMING" type="AR:RELATIVELY-SCHEDULED-TIMING"/>
                  <xsd:element name="UNASSIGN-FRAME-ID-TIMING" type="AR:UNASSIGN-FRAME-ID-TIMING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class LinCommunication::LinFrameTriggering -->
   <xsd:complexType abstract="false" mixed="false" name="LIN-FRAME-TRIGGERING">
      <xsd:annotation>
         <xsd:documentation>Lin specific attributes to the FrameTriggering</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinFrameTriggering"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:FRAME-TRIGGERING"/>
         <xsd:group ref="AR:LIN-FRAME-TRIGGERING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="LIN-FRAME-TRIGGERING--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="LIN-FRAME-TRIGGERING"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class LinTopology::LinMaster -->
   <xsd:group name="LIN-MASTER">
      <xsd:annotation>
         <xsd:documentation>Describing the properties of the refering ecu as a LIN master.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinMaster"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIME-BASE" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Time base is mandatory for the master. It is not used for slaves. 
            LIN 2.0 Spec states: "The time_base value specifies the used time base in the master node to generate the maximum allowed frame transfer time." 
            The time base shall be specified AUTOSAR conform in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinMaster.timeBase";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIME-BASE-JITTER" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>timeBaseJitter is a mandatory attribute for the master and not used for slaves. 
            LIN 2.0 Spec states: "The jitter value specifies the differences between the maximum and minimum delay from time base start point to the frame header sending start point (falling edge of BREAK signal)." 
            The jitter shall be specified AUTOSAR conform in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinMaster.timeBaseJitter";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class LinTopology::LinMaster -->
   <xsd:complexType abstract="false" mixed="false" name="LIN-MASTER">
      <xsd:annotation>
         <xsd:documentation>Describing the properties of the refering ecu as a LIN master.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinMaster"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COMMUNICATION-CONTROLLER"/>
         <xsd:group ref="AR:LIN-MASTER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class LinCommunication::LinScheduleTable -->
   <xsd:group name="LIN-SCHEDULE-TABLE">
      <xsd:annotation>
         <xsd:documentation>The master task (in the master node) transmits frame headers based on a schedule table. The schedule table specifies the identifiers for each header and the interval between the start of a frame and the start of the following frame.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinScheduleTable"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="PRIORITY" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Priority of the schedule table. The priority is used in the schedule table manager. The RUN_ONCE run mode schedules shall not have equal priority. Priority 0 is reserved for the NULL_SCHEDULE. Priority 255 is reserved for the RUN_CONTINUOUS run mode.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinScheduleTable.priority";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RUN-MODE" type="AR:RUN-MODE">
            <xsd:annotation>
               <xsd:documentation>The schedule table can be executed in two different modes.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinScheduleTable.runMode";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class LinCommunication::LinScheduleTable -->
   <xsd:complexType abstract="false" mixed="false" name="LIN-SCHEDULE-TABLE">
      <xsd:annotation>
         <xsd:documentation>The master task (in the master node) transmits frame headers based on a schedule table. The schedule table specifies the identifiers for each header and the interval between the start of a frame and the start of the following frame.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinScheduleTable"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:LIN-SCHEDULE-TABLE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="LIN-SCHEDULE-TABLE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="LIN-SCHEDULE-TABLE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class LinTopology::LinSlave -->
   <xsd:group name="LIN-SLAVE">
      <xsd:annotation>
         <xsd:documentation>Describing the properties of the refering ecu as a LIN slave.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinSlave"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONFIGURED-NAD" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>To distinguish LIN slaves that are used twice or more within the same cluster.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinSlave.configuredNad";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="LIN-ERROR-RESPONSE" type="AR:LIN-ERROR-RESPONSE">
            <xsd:annotation>
               <xsd:documentation>Each slave node shall publish one response error in one of its transmitted unconditional frames.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="linErrorResponse.LinSlave";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PROTOCOL-VERSION" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Version specifier for a communication protocol.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinSlave.protocolVersion";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class LinTopology::LinSlave -->
   <xsd:complexType abstract="false" mixed="false" name="LIN-SLAVE">
      <xsd:annotation>
         <xsd:documentation>Describing the properties of the refering ecu as a LIN slave.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinSlave"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COMMUNICATION-CONTROLLER"/>
         <xsd:group ref="AR:LIN-SLAVE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class TransportProtocols::LinTpChannel -->
   <xsd:group name="LIN-TP-CHANNEL">
      <xsd:annotation>
         <xsd:documentation>A LinTP channel represents an internal path for the transmission or reception of a Pdu via LinTp and describes the the sender and the receiver of this particular communication.

      The LinTp module routes a Pdu through the connection channel</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinTpChannel"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-PDU-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to an NPdu (Single Frame, First Frame or Consecutive Frame).

            The Single Frame network protocol data unit (SF N_PDU) shall be sent out by the sending network entity and can be received by one or multiple receiving network entities.
            The Single Frame (SF N_PDU) shall be sent out to transfer a service data unit that can be transferred via a single service request to the data link layer. This network protocol data unit shall be sent to transfer unsegmented messages.

            The First Frame network protocol data unit (FF N_PDU) identifies the first network protocol data unit (N_PDU) of a segmented message transmitted by a network sending entity and received by a receiving network entity. 

            The Consecutive Frame network protocol data unit (CF N_PDU) transfers segments (N_Data) of the service data unit message data (&lt;MessageData&gt;). All network protocol data units (N_PDUs) transmitted by the sending entity after the First Frame network protocol data unit (FF N_PDU) shall be encoded as Consecutive Frames network protocol data units (CF N_PDUs).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinTpChannel.dataPdu";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:N-PDU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DROP-NOT-REQUESTED-NAD" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Configures if TP Frames of not requested LIN-Slaves are dropped or not.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinTpChannel.dropNotRequestedNad";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FLOW-CONTROL-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the  Flow Control NPdu.

            The Flow Control network protocol data unit (FC N_PDU) is identified by the Flow Control protocol control information (FC N_PCI). The Flow Control network protocol data unit (FC N_PDU) instructs a sending network entity to start, stop or resume transmission of CF N_PDUs. The Flow Control network protocol data unit shall be sent by the receiving network layer entity to the sending network layer entity, when ready to receive more data, after correct reception of:

            a) First Frame network protocol data unit (FF N_PDU) 
            b) the last Consecutive Frame network protocol data unit (CF N_PDU) of a block of Consecutive Frames (CF N_PDU) if further Consecutive Frame network protocol data unit (CF N_PDU) need(s) to be sent.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinTpChannel.flowControl";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:N-PDU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="LIN-TP-N-SDU-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the IPdu that is segmented by the Transport Protocol. 

            To support the low-level routing of NPdu's the NPdu is a specialization of an IPdu. More details can be found in the NPdu class description. Nevertheless the LinTpChannel must not reference a NPdu with this linTpNSdu reference.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinTpChannel.linTpNSdu";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:I-PDU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MULTICAST-REF">
            <xsd:annotation>
               <xsd:documentation>TP address for 1:n connections.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinTpChannel.multicast";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:TP-ADDRESS--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SOURCE-REF">
            <xsd:annotation>
               <xsd:documentation>The source of the TP connection.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinTpChannel.source";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:LIN-TP-NODE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TARGET-REFS">
            <xsd:annotation>
               <xsd:documentation>The target of the TP connection.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="LinTpChannel.target";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="TARGET-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:LIN-TP-NODE--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TransportProtocols::LinTpChannel -->
   <xsd:complexType abstract="false" mixed="false" name="LIN-TP-CHANNEL">
      <xsd:annotation>
         <xsd:documentation>A LinTP channel represents an internal path for the transmission or reception of a Pdu via LinTp and describes the the sender and the receiver of this particular communication.

      The LinTp module routes a Pdu through the connection channel</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinTpChannel"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:LIN-TP-CHANNEL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- complex type for class TransportProtocols::LinTpNode -->
   <xsd:complexType abstract="false" mixed="false" name="LIN-TP-NODE">
      <xsd:annotation>
         <xsd:documentation>TP Node (Sender or Receiver) provides the TP Address and the connection to the Topology description.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinTpNode"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:TP-NODE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="LIN-TP-NODE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="LIN-TP-NODE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Implementation::Linker -->
   <xsd:group name="LINKER">
      <xsd:annotation>
         <xsd:documentation>Specifies the linker attributes used to decribe how the linker shall be invoked.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Linker"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="NAME" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Linker name.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Linker.name";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="OPTIONS" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Specifies the linker options.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Linker.options";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VENDOR" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Vendor of linker.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Linker.vendor";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VERSION" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Exact version of linker executable.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Linker.version";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Implementation::Linker -->
   <xsd:complexType abstract="false" mixed="false" name="LINKER">
      <xsd:annotation>
         <xsd:documentation>Specifies the linker attributes used to decribe how the linker shall be invoked.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Linker"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:LINKER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- complex type for class ECUCParameterDefTemplate::LinkerSymbolDef -->
   <xsd:complexType abstract="false" mixed="false" name="LINKER-SYMBOL-DEF">
      <xsd:annotation>
         <xsd:documentation>Configuration parameter type for Linker Symbol Names like those used to specify memory locations of variables and constants.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinkerSymbolDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PARAM-CONF-MULTIPLICITY"/>
         <xsd:group ref="AR:COMMON-CONFIGURATION-ATTRIBUTES"/>
         <xsd:group ref="AR:CONFIG-PARAMETER"/>
         <xsd:group ref="AR:STRING-PARAM-DEF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- complex type for class ECUCDescriptionTemplate::LinkerSymbolValue -->
   <xsd:complexType abstract="false" mixed="false" name="LINKER-SYMBOL-VALUE">
      <xsd:annotation>
         <xsd:documentation>Representing a configuration value of definition type LinkerSymbolDef</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LinkerSymbolValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:PARAMETER-VALUE"/>
         <xsd:group ref="AR:STRING-VALUE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- complex type for class ComponentLocalCalprm::LocalParameterInitValueAssignment -->
   <xsd:complexType abstract="false" mixed="false" name="LOCAL-PARAMETER-INIT-VALUE-ASSIGNMENT">
      <xsd:annotation>
         <xsd:documentation>This is the specialization for local parameters.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="LocalParameterInitValueAssignment"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:INIT-VALUE-ASSIGNMENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ProcessingUnit::MPU -->
   <xsd:group name="MPU">
      <xsd:annotation>
         <xsd:documentation>A MPU provides means where the memory access within a defined program flow of a PU is controlled. In case of a failure an exception routine e.g. interrupt is activated.
      A MPU is implemented as an independent hardware block in a device separate to the processing unit. A MPU does not perform any data manipulation, only in case of an error a change in the processor control flow is forced.
      The number of individual checked memory ranges is limited to the registers available for specifying the memory ranges. One individual memory range is in the following referenced as MPU Channel.
      In most cases the MPU consists of a set of registers, which do range checking of the addresses asserted by the program on the address bus as well as the access type to the according address. The checking of the address ranges is also coupled to the address range of the program, which runs under the control of the MPU.
      The MPU also can be coupled with one of the different processing elements of a device like the PU itself, a DMA or a Coprocessor.
      In order to have a broad usage of a MPU a specification of filter values is often allowed, so very user specific selection methods are possible.
      Typical use case for a MPU: A 3rd party software routine is allowed only to access a defined memory-area. Any access outside the defined memory area will be denied and control will be transferred to the supervising operating system. A error handling routine will be started.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MPU"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CHANNEL-COUNT" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Defines the number of individual MPU channels are available.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MPU.channelCount";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PROTECTED-MEMORY-HW-PORT-REFS">
            <xsd:annotation>
               <xsd:documentation>Describes which Memory Mapped HW Ports are obserable by this MPU. The actual configuration will be done by SW.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MPU.protectedMemoryHWPort";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="PROTECTED-MEMORY-HW-PORT-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:MEMORY-MAPPED-HW-PORT--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RAISED-INTERRUPTS">
            <xsd:annotation>
               <xsd:documentation>Defines the interrupts this MPU can raise to indicate the violation of memory access.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="raisedInterrupt.MPU";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="INTERRUPT-PRODUCE-HW-PORT" type="AR:INTERRUPT-PRODUCE-HW-PORT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ProcessingUnit::MPU -->
   <xsd:complexType abstract="false" mixed="false" name="MPU">
      <xsd:annotation>
         <xsd:documentation>A MPU provides means where the memory access within a defined program flow of a PU is controlled. In case of a failure an exception routine e.g. interrupt is activated.
      A MPU is implemented as an independent hardware block in a device separate to the processing unit. A MPU does not perform any data manipulation, only in case of an error a change in the processor control flow is forced.
      The number of individual checked memory ranges is limited to the registers available for specifying the memory ranges. One individual memory range is in the following referenced as MPU Channel.
      In most cases the MPU consists of a set of registers, which do range checking of the addresses asserted by the program on the address bus as well as the access type to the according address. The checking of the address ranges is also coupled to the address range of the program, which runs under the control of the MPU.
      The MPU also can be coupled with one of the different processing elements of a device like the PU itself, a DMA or a Coprocessor.
      In order to have a broad usage of a MPU a specification of filter values is often allowed, so very user specific selection methods are possible.
      Typical use case for a MPU: A 3rd party software routine is allowed only to access a defined memory-area. Any access outside the defined memory area will be denied and control will be transferred to the supervising operating system. A error handling routine will be started.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MPU"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:MPU"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Filter::MaskedNewDiffersMaskedOld -->
   <xsd:group name="MASKED-NEW-DIFFERS-MASKED-OLD">
      <xsd:annotation>
         <xsd:documentation>Pass messages where the masked value has changed.

      (new_value&amp;mask) !=(old_value&amp;mask)
      new_value: current value of the message
      old_value: last value of the message (initialised with the initial value of the message, updated with new_value if the new message value is not filtered out)</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MaskedNewDiffersMaskedOld"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MASK" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>mask for old and new value</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MaskedNewDiffersMaskedOld.mask";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Filter::MaskedNewDiffersMaskedOld -->
   <xsd:complexType abstract="false" mixed="false" name="MASKED-NEW-DIFFERS-MASKED-OLD">
      <xsd:annotation>
         <xsd:documentation>Pass messages where the masked value has changed.

      (new_value&amp;mask) !=(old_value&amp;mask)
      new_value: current value of the message
      old_value: last value of the message (initialised with the initial value of the message, updated with new_value if the new message value is not filtered out)</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MaskedNewDiffersMaskedOld"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:MASKED-NEW-DIFFERS-MASKED-OLD"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Filter::MaskedNewDiffersX -->
   <xsd:group name="MASKED-NEW-DIFFERS-X">
      <xsd:annotation>
         <xsd:documentation>Pass messages whose masked value is not equal to a specific value x

      (new_value&amp;mask) != x
      new_value: current value of the message</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MaskedNewDiffersX"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MASK" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>mask for the new Value</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MaskedNewDiffersX.mask";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="X" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Value to compare with</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MaskedNewDiffersX.x";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Filter::MaskedNewDiffersX -->
   <xsd:complexType abstract="false" mixed="false" name="MASKED-NEW-DIFFERS-X">
      <xsd:annotation>
         <xsd:documentation>Pass messages whose masked value is not equal to a specific value x

      (new_value&amp;mask) != x
      new_value: current value of the message</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MaskedNewDiffersX"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:MASKED-NEW-DIFFERS-X"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Filter::MaskedNewEqualsX -->
   <xsd:group name="MASKED-NEW-EQUALS-X">
      <xsd:annotation>
         <xsd:documentation>Pass messages whose masked value is equal to a specific value x

      (new_value&amp;mask) == x
      new_value: current value of the message</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MaskedNewEqualsX"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MASK" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>mask for the new Value</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MaskedNewEqualsX.mask";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="X" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Value to compare with</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MaskedNewEqualsX.x";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Filter::MaskedNewEqualsX -->
   <xsd:complexType abstract="false" mixed="false" name="MASKED-NEW-EQUALS-X">
      <xsd:annotation>
         <xsd:documentation>Pass messages whose masked value is equal to a specific value x

      (new_value&amp;mask) == x
      new_value: current value of the message</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MaskedNewEqualsX"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:MASKED-NEW-EQUALS-X"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ExecutionTime::MeasuredExecutionTime -->
   <xsd:group name="MEASURED-EXECUTION-TIME">
      <xsd:annotation>
         <xsd:documentation>Specifies the ExecutionTime which has been gathered using measurement means.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MeasuredExecutionTime"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="AVERAGE-EXECUTION-TIME" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Average MeasuredExecutionTime.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MeasuredExecutionTime.averageExecutionTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAXIMAL-EXECUTION-TIME" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Maximum MeasuredExecutionTime.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MeasuredExecutionTime.maximalExecutionTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MINIMAL-EXECUTION-TIME" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Minumum MeasuredExecutionTime.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MeasuredExecutionTime.minimalExecutionTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ExecutionTime::MeasuredExecutionTime -->
   <xsd:complexType abstract="false" mixed="false" name="MEASURED-EXECUTION-TIME">
      <xsd:annotation>
         <xsd:documentation>Specifies the ExecutionTime which has been gathered using measurement means.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MeasuredExecutionTime"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:EXECUTION-TIME"/>
         <xsd:group ref="AR:MEASURED-EXECUTION-TIME"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class HeapUsage::MeasuredHeapUsage -->
   <xsd:group name="MEASURED-HEAP-USAGE">
      <xsd:annotation>
         <xsd:documentation>The heap usage has been measured.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MeasuredHeapUsage"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="AVERAGE-MEMORY-CONSUMPTION" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The average heap usage measured.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MeasuredHeapUsage.averageMemoryConsumption";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAXIMUM-MEMORY-CONSUMPTION" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The maximum heap usage measured.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MeasuredHeapUsage.maximumMemoryConsumption";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MINIMUM-MEMORY-CONSUMPTION" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The minimum heap usage measured.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MeasuredHeapUsage.minimumMemoryConsumption";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TEST-PATTERN" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Description of the test pattern used to aquire the measured values.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MeasuredHeapUsage.testPattern";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class HeapUsage::MeasuredHeapUsage -->
   <xsd:complexType abstract="false" mixed="false" name="MEASURED-HEAP-USAGE">
      <xsd:annotation>
         <xsd:documentation>The heap usage has been measured.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MeasuredHeapUsage"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HEAP-USAGE"/>
         <xsd:group ref="AR:MEASURED-HEAP-USAGE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class StackUsage::MeasuredStackUsage -->
   <xsd:group name="MEASURED-STACK-USAGE">
      <xsd:annotation>
         <xsd:documentation>The stack usage has been measured.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MeasuredStackUsage"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="AVERAGE-MEMORY-CONSUMPTION" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The average stack usage measured.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MeasuredStackUsage.averageMemoryConsumption";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAXIMUM-MEMORY-CONSUMPTION" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The maximum stack usage measured.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MeasuredStackUsage.maximumMemoryConsumption";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MINIMUM-MEMORY-CONSUMPTION" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The minimum stack usage measured.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MeasuredStackUsage.minimumMemoryConsumption";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TEST-PATTERN" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Description of the test pattern used to aquire the measured values.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MeasuredStackUsage.testPattern";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class StackUsage::MeasuredStackUsage -->
   <xsd:complexType abstract="false" mixed="false" name="MEASURED-STACK-USAGE">
      <xsd:annotation>
         <xsd:documentation>The stack usage has been measured.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MeasuredStackUsage"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:STACK-USAGE"/>
         <xsd:group ref="AR:MEASURED-STACK-USAGE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Memory::MemoryAccess -->
   <xsd:group name="MEMORY-ACCESS">
      <xsd:annotation>
         <xsd:documentation>Describes the different possible kinds of access to the memory and the time these access takes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MemoryAccess"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ACCESS-TYPE" type="AR:MEMORY-ACCESS-TYPE-ENUM">
            <xsd:annotation>
               <xsd:documentation>The element access type describes the different possible kinds of access to the memory.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MemoryAccess.accessType";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIME" type="AR:TIME-RANGE">
            <xsd:annotation>
               <xsd:documentation>Access time is the timing characteristic for each access type. Access time at the Memory Mapped HW Port is only theoretical. The actual Access time is given in the Memory Mapped HW Connection.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="time.MemoryAccess";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Memory::MemoryAccess -->
   <xsd:complexType abstract="false" mixed="false" name="MEMORY-ACCESS">
      <xsd:annotation>
         <xsd:documentation>Describes the different possible kinds of access to the memory and the time these access takes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MemoryAccess"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:MEMORY-ACCESS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Memory::MemoryMappedAssemblyHWConnection -->
   <xsd:group name="MEMORY-MAPPED-ASSEMBLY-HW-CONNECTION">
      <xsd:annotation>
         <xsd:documentation>This connection is used to connect Memory HWPort on the same hierarchical level (inside one HW Container).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MemoryMappedAssemblyHWConnection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BASE-ADDRESS" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Defines the base address of the memory within the ECU template.
            The same base address might be defined multiple times according to the access type and the architecture. A base address is uniquely bound to a defined memory segment.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MemoryMappedAssemblyHWConnection.baseAddress";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="BYTE-ORDER" type="AR:BYTE-ORDER-ENUM">
            <xsd:annotation>
               <xsd:documentation>When a PU stores data in a memory the ordering of the bytes can be done in two different ways. This storing scheme is normally fixed in the PU when more than one byte is stored in the memory. When the least significant byte is stored at the lowest address this architecture is called "mostSignificantByteLast" (aka little endian) and when the most significant byte is stored at the lowest address this is called "mostSignificantByteFirst" (aka big endian). Some CPU architectures like ARM and PowerPC can be configured to handle both little and big endian. This is called bi-endian. ByteOrder is very important when you communicate between different PUs or ECUs.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MemoryMappedAssemblyHWConnection.byteOrder";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CACHABLE" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>A memory segment may be cacheable. This has to be defined in the description of the segment connection.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MemoryMappedAssemblyHWConnection.cachable";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="HW-CONNECTION-ACCESSS">
            <xsd:annotation>
               <xsd:documentation>Access time is the timing characteristic for each access type. Access time at the Memory Mapped HW Port is only theoretical. The actual Access time is given in the Memory Mapped HW Connection.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="hwConnectionAccess.MemoryMappedAssemblyHWConnection";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="MEMORY-ACCESS" type="AR:MEMORY-ACCESS"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SEGMENT-USAGES">
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element maxOccurs="unbounded" minOccurs="0" name="SEGMENT-USAGE" type="AR:MEMORY-SEGMENT-USAGE-ENUM">
                     <xsd:annotation>
                        <xsd:documentation>The segment usage is defined in the linker memory map. Usually it is fixed within an operation mode but different operations modes have different memory usage.
                     The element segment usage contains the following attributes. 
                     - Data: The attribute data is used for all kind of data: constant, variable, calibration, system initialisation, system configuration, etc. 
                     - Code: The attribute code is used for the program code itself. 
                     - Stack: Memory usable for a system or software stack is in some cases only available on limited number of segments within a PU. 
                     - Boot: The boot memory is used to store program and data for the start up or test of an ECU. Within the boot program the basic ECU initialisation is performed. Furthermore some system maintenance programs, like the set-up for flash programming or loading of data via communication interface, can be part of the boot program. 
                     Boot memory is in general not a subject of AUTOSAR SW. 
                     -- Boot sector: Boot sector is the location in memory, preferable Flash or ROM, where the boot program is stored. The location of the boot sector might be dependant on the PU architecture as reset and interrupt vectors must be accessible during boot. The boot sector should be separated from other user accessible Flash or implemented as ROM. In Flash the boot sector should have the appropriate array size, some few kilobyte and provide protection mechanism against unintended erasure or system manipulation.
                     A system may have different boot sectors, one accessible only for testing the PU during the manufacturing and configuration of the PU, in factory test mode or some initial program mode, and a user boot mode. 
                     -- Mapping of boot sector: Mapping of the boot sector is useful to enhance the boot sequence and the release of the used resources during the boot phase at the later user mode, e.g. the use of reset vector and interrupt vector can be improved.</xsd:documentation>
                        <xsd:appinfo source="tags">mmt.qualifiedName="MemoryMappedAssemblyHWConnection.segmentUsage";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
                     </xsd:annotation>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Memory::MemoryMappedAssemblyHWConnection -->
   <xsd:complexType abstract="false" mixed="false" name="MEMORY-MAPPED-ASSEMBLY-HW-CONNECTION">
      <xsd:annotation>
         <xsd:documentation>This connection is used to connect Memory HWPort on the same hierarchical level (inside one HW Container).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MemoryMappedAssemblyHWConnection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HW-CONNECTION"/>
         <xsd:group ref="AR:ASSEMBLY-HW-CONNECTION"/>
         <xsd:group ref="AR:MEMORY-MAPPED-ASSEMBLY-HW-CONNECTION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- complex type for class Memory::MemoryMappedDelegationHWConnection -->
   <xsd:complexType abstract="false" mixed="false" name="MEMORY-MAPPED-DELEGATION-HW-CONNECTION">
      <xsd:annotation>
         <xsd:documentation>This connection is used to delegate a Memory HW Port to the outside of a HW Container. Typically this will used internally of a micro-controller.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MemoryMappedDelegationHWConnection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HW-CONNECTION"/>
         <xsd:group ref="AR:DELEGATION-HW-CONNECTION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Memory::MemoryMappedHWPort -->
   <xsd:group name="MEMORY-MAPPED-HW-PORT">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MemoryMappedHWPort"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-INTERFACE-WIDTH" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The element defines the number of bits that can be transferred from the PU to the memory device or vice versa. The width of data bus are important characteristics. All technical characteristics of the memory are covered by the access time.
            Unit: Bit</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MemoryMappedHWPort.dataInterfaceWidth";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="HW-PORT-TYPE" type="AR:MEMORY-MAPPED-HW-PORT-TYPE-ENUM">
            <xsd:annotation>
               <xsd:documentation>the type of port</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MemoryMappedHWPort.hwPortType";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Memory::MemoryMappedHWPort -->
   <xsd:complexType abstract="false" mixed="false" name="MEMORY-MAPPED-HW-PORT">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MemoryMappedHWPort"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HW-PORT"/>
         <xsd:group ref="AR:MEMORY-MAPPED-HW-PORT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="MEMORY-MAPPED-HW-PORT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="MEMORY-MAPPED-HW-PORT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class MemorySectionUsage::MemorySection -->
   <xsd:group name="MEMORY-SECTION">
      <xsd:annotation>
         <xsd:documentation>The MemorySection provides description of the Memory Sections used in the Implementation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MemorySection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ALIGNMENT" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The alignment (typically 1, 2, 4,...)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MemorySection.alignment";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="OPTIONS">
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element maxOccurs="unbounded" minOccurs="0" name="OPTION" type="AR:IDENTIFIER">
                     <xsd:annotation>
                        <xsd:documentation>This attribute introduces the ability to specify further intended properties of this MemorySection.
                     The following value is standardized (to be used for code sections only):

                     * INLINE - The code section is declared with the compiler abstraction macro INLINE.

                     The expansion of INLINE depends on the compiler specific implementation of the macro. Depending on this, the code section either corresponds to an actual section in memory or is put into the section of the caller. See AUTOSAR_SWS_CompilerAbstraction for more details.</xsd:documentation>
                        <xsd:appinfo source="tags">mmt.qualifiedName="MemorySection.option";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
                     </xsd:annotation>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SECTION-NAME" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>This is the name of the section in the Implementation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MemorySection.sectionName";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SECTION-TYPE" type="AR:MEMORY-SECTION-TYPE">
            <xsd:annotation>
               <xsd:documentation>Memory section type of the described MemorySection.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MemorySection.sectionType";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SIZE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The size in bytes of the section.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MemorySection.size";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-ADDR-METHOD-REFS">
            <xsd:annotation>
               <xsd:documentation>This assocation indicates all objects (e.g. calibration parameters, data element prototypes) being assigned to this SwAddrMethod shall be placed in this memory Section.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MemorySection.swAddrMethod";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SW-ADDR-METHOD-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:SW-ADDR-METHOD--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class MemorySectionUsage::MemorySection -->
   <xsd:complexType abstract="false" mixed="false" name="MEMORY-SECTION">
      <xsd:annotation>
         <xsd:documentation>The MemorySection provides description of the Memory Sections used in the Implementation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MemorySection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:MEMORY-SECTION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="MEMORY-SECTION--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="MEMORY-SECTION"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ExecutionTime::MemorySectionLocation -->
   <xsd:group name="MEMORY-SECTION-LOCATION">
      <xsd:annotation>
         <xsd:documentation>Specifes in which hardware ProvidedMemorySegment the softwareMemorySection is located.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MemorySectionLocation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="PROVIDED-MEMORY-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the hardware ProvidedMemorySegment.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MemorySectionLocation.providedMemory";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PROVIDED-MEMORY-SEGMENT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SOFTWARE-MEMORY-SECTION-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the MemorySection which is mapped on a certain hardware memory segment.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MemorySectionLocation.softwareMemorySection";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MEMORY-SECTION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ExecutionTime::MemorySectionLocation -->
   <xsd:complexType abstract="false" mixed="false" name="MEMORY-SECTION-LOCATION">
      <xsd:annotation>
         <xsd:documentation>Specifes in which hardware ProvidedMemorySegment the softwareMemorySection is located.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MemorySectionLocation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:MEMORY-SECTION-LOCATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class InlineTextModel::MixedContent1 -->
   <xsd:group name="MIXED-CONTENT-1">
      <xsd:annotation>
         <xsd:documentation>MixedContentForParagraph

      This mainly represents the text model of a full blown paragraph within a documentation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MixedContent1"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice>
         <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element maxOccurs="unbounded" minOccurs="0" name="XFILE" type="AR:XFILE">
               <xsd:annotation>
                  <xsd:documentation>Use &lt;xfile&gt; , to reference an external file.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="MixedContent1.xfile";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="140"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
         </xsd:choice>
      </xsd:choice>
   </xsd:group>
   <!-- attribute group for class MultilanguageData::MlData1 -->
   <xsd:attributeGroup name="ML-DATA-1">
      <xsd:annotation>
         <xsd:documentation>MultiLanguageParagraph

      This is the content model of a multilinugal paragraph in a documentation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MlData1"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="HELP-ENTRY" type="xsd:string">
         <xsd:annotation>
            <xsd:appinfo source="tags">mmt.qualifiedName="MlData1.helpEntry";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="KEEP-WITH-PREVIOUS" type="xsd:string">
         <xsd:annotation>
            <xsd:appinfo source="tags">mmt.qualifiedName="MlData1.keepWithPrevious";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class MultilanguageData::MlData1 -->
   <xsd:complexType abstract="false" mixed="false" name="ML-DATA-1">
      <xsd:annotation>
         <xsd:documentation>MultiLanguageParagraph

      This is the content model of a multilinugal paragraph in a documentation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MlData1"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:ML-DATA-MODEL-1"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:ML-DATA-1"/>
   </xsd:complexType>
   <!-- complex type for class MultilanguageData::MlData10 -->
   <xsd:complexType abstract="false" mixed="false" name="ML-DATA-10">
      <xsd:annotation>
         <xsd:documentation>MultiLanguagePlainText</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MlData10"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:ML-DATA-MODEL-10"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- complex type for class MultilanguageData::MlData2 -->
   <xsd:complexType abstract="false" mixed="false" name="ML-DATA-2">
      <xsd:annotation>
         <xsd:documentation>MultiLanguageOverviewParagraph

      This is the content of a multilingual paragraph in an overview item.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MlData2"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:ML-DATA-MODEL-2"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- complex type for class MultilanguageData::MlData3 -->
   <xsd:complexType abstract="false" mixed="false" name="ML-DATA-3">
      <xsd:annotation>
         <xsd:documentation>MultiLanguageUnitNames</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MlData3"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:ML-DATA-MODEL-3"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- attribute group for class MultilanguageData::MlData3p -->
   <xsd:attributeGroup name="ML-DATA-3-P">
      <xsd:annotation>
         <xsd:documentation>MultiLanguageUnitNameVerbatim</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MlData3p"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="XMLSPACE" type="xsd:string">
         <xsd:annotation>
            <xsd:appinfo source="tags">mmt.qualifiedName="MlData3p.xml:space";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class MultilanguageData::MlData3p -->
   <xsd:complexType abstract="false" mixed="false" name="ML-DATA-3-P">
      <xsd:annotation>
         <xsd:documentation>MultiLanguageUnitNameVerbatim</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MlData3p"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:ML-DATA-MODEL-3"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:ML-DATA-3-P"/>
   </xsd:complexType>
   <!-- complex type for class MultilanguageData::MlData4 -->
   <xsd:complexType abstract="false" mixed="false" name="ML-DATA-4">
      <xsd:annotation>
         <xsd:documentation>MultilanguageLongName</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MlData4"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:ML-DATA-MODEL-4"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- attribute group for class MultilanguageData::MlData5 -->
   <xsd:attributeGroup name="ML-DATA-5">
      <xsd:annotation>
         <xsd:documentation>MultiLanguageVerbatim</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MlData5"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="ALLOW-BREAK" type="xsd:string">
         <xsd:annotation>
            <xsd:appinfo source="tags">mmt.qualifiedName="MlData5.allowBreak";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="FLOAT" type="xsd:string">
         <xsd:annotation>
            <xsd:appinfo source="tags">mmt.qualifiedName="MlData5.float";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="HELP-ENTRY" type="xsd:string">
         <xsd:annotation>
            <xsd:appinfo source="tags">mmt.qualifiedName="MlData5.helpEntry";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="KEEP-WITH-PREVIOUS" type="xsd:string">
         <xsd:annotation>
            <xsd:appinfo source="tags">mmt.qualifiedName="MlData5.keepWithPrevious";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="PGWIDE" type="xsd:string">
         <xsd:annotation>
            <xsd:appinfo source="tags">mmt.qualifiedName="MlData5.pgwide";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="XMLSPACE" type="xsd:string">
         <xsd:annotation>
            <xsd:appinfo source="tags">mmt.qualifiedName="MlData5.xml:space";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class MultilanguageData::MlData5 -->
   <xsd:complexType abstract="false" mixed="false" name="ML-DATA-5">
      <xsd:annotation>
         <xsd:documentation>MultiLanguageVerbatim</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MlData5"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:ML-DATA-MODEL-5"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:ML-DATA-5"/>
   </xsd:complexType>
   <!-- element group for class LanguageDataModel::MlDataModel1 -->
   <xsd:group name="ML-DATA-MODEL-1">
      <xsd:annotation>
         <xsd:documentation>MultilanguageDataModelForParagraph</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MlDataModel1"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="L-1" type="AR:L-1">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MlDataModel1.l1";pureMM.maxOccurs="-1";pureMM.minOccurs="1";xml.roleElement="true";xml.roleWrapperElement="false";xml.sequenceOffset="20";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class LanguageDataModel::MlDataModel10 -->
   <xsd:group name="ML-DATA-MODEL-10">
      <xsd:annotation>
         <xsd:documentation>MultilanguageDataModelForPlainText</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MlDataModel10"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="L-10" type="AR:L-10">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MlDataModel10.l10";pureMM.maxOccurs="-1";pureMM.minOccurs="1";xml.roleElement="true";xml.roleWrapperElement="false";xml.sequenceOffset="20";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class LanguageDataModel::MlDataModel2 -->
   <xsd:group name="ML-DATA-MODEL-2">
      <xsd:annotation>
         <xsd:documentation>MultilanguageDataModelForOverviewParagraph</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MlDataModel2"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="L-2" type="AR:L-2">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MlDataModel2.l2";pureMM.maxOccurs="-1";pureMM.minOccurs="1";xml.roleElement="true";xml.roleWrapperElement="false";xml.sequenceOffset="20";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class LanguageDataModel::MlDataModel3 -->
   <xsd:group name="ML-DATA-MODEL-3">
      <xsd:annotation>
         <xsd:documentation>MultilanguageDataModelForUnitNames</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MlDataModel3"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="L-3" type="AR:L-3">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MlDataModel3.l3";pureMM.maxOccurs="-1";pureMM.minOccurs="1";xml.roleElement="true";xml.roleWrapperElement="false";xml.sequenceOffset="20";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class LanguageDataModel::MlDataModel4 -->
   <xsd:group name="ML-DATA-MODEL-4">
      <xsd:annotation>
         <xsd:documentation>MultilanguageDataModelForLongNames</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MlDataModel4"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="L-4" type="AR:L-4">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MlDataModel4.l4";pureMM.maxOccurs="-1";pureMM.minOccurs="1";xml.roleElement="true";xml.roleWrapperElement="false";xml.sequenceOffset="20";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class LanguageDataModel::MlDataModel5 -->
   <xsd:group name="ML-DATA-MODEL-5">
      <xsd:annotation>
         <xsd:documentation>MultilanguageDataModelForVerbatim</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MlDataModel5"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="L-5" type="AR:L-5">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MlDataModel5.l5";pureMM.maxOccurs="-1";pureMM.minOccurs="1";xml.roleElement="true";xml.roleWrapperElement="false";xml.sequenceOffset="20";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class LanguageDataModel::MlGraphic -->
   <xsd:group name="ML-GRAPHIC">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MlGraphic"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="L" type="AR:L-ENUM">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MlGraphic.L";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class LanguageDataModel::MlGraphic -->
   <xsd:complexType abstract="false" mixed="false" name="ML-GRAPHIC">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MlGraphic"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:ML-GRAPHIC"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- complex type for class ModeDeclaration::ModeDeclaration -->
   <xsd:complexType abstract="false" mixed="false" name="MODE-DECLARATION">
      <xsd:annotation>
         <xsd:documentation>Declaration of one Mode. The name and semantics of a special mode is not defined in the metamodel.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeDeclaration"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpStructureElement</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="MODE-DECLARATION--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="MODE-DECLARATION"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ModeDeclaration::ModeDeclarationGroup -->
   <xsd:group name="MODE-DECLARATION-GROUP">
      <xsd:annotation>
         <xsd:documentation>A collection of Mode Declarations.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeDeclarationGroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpType</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="INITIAL-MODE-REF">
            <xsd:annotation>
               <xsd:documentation>The initial mode of the ModeDeclarationGroup. This mode is active before any mode switches occured.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ModeDeclarationGroup.initialMode";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MODE-DECLARATION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODE-DECLARATIONS">
            <xsd:annotation>
               <xsd:documentation>The ModeDeclarations collected in this ModeDeclarationGroup.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="modeDeclaration.ModeDeclarationGroup";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="MODE-DECLARATION" type="AR:MODE-DECLARATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ModeDeclaration::ModeDeclarationGroup -->
   <xsd:complexType abstract="false" mixed="false" name="MODE-DECLARATION-GROUP">
      <xsd:annotation>
         <xsd:documentation>A collection of Mode Declarations.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeDeclarationGroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpType</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:MODE-DECLARATION-GROUP"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="MODE-DECLARATION-GROUP--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="MODE-DECLARATION-GROUP"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class PortInterface::ModeDeclarationGroupPrototype -->
   <xsd:group name="MODE-DECLARATION-GROUP-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>The ModeDeclarationGroupPrototype specifies the set of Modes (ModeDeclarationGroup) that is supported by a ComponentType.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeDeclarationGroupPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TYPE-TREF">
            <xsd:annotation>
               <xsd:documentation>The "collection of ModeDeclarations" ( = ModeDeclarationGroup) supported by a component</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ModeDeclarationGroupPrototype.type";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">isOfType</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MODE-DECLARATION-GROUP--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class PortInterface::ModeDeclarationGroupPrototype -->
   <xsd:complexType abstract="false" mixed="false" name="MODE-DECLARATION-GROUP-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>The ModeDeclarationGroupPrototype specifies the set of Modes (ModeDeclarationGroup) that is supported by a ComponentType.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeDeclarationGroupPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:MODE-DECLARATION-GROUP-PROTOTYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="MODE-DECLARATION-GROUP-PROTOTYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="MODE-DECLARATION-GROUP-PROTOTYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ModeDeclaration::ModeDisablingDependency -->
   <xsd:group name="MODE-DISABLING-DEPENDENCY">
      <xsd:annotation>
         <xsd:documentation>Collection of references to the Modes that disable the RTEEvent</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeDisablingDependency"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DEPENDENT-ON-MODE-IREFS">
            <xsd:annotation>
               <xsd:documentation>Reference to the Modes that disable the Runnable Entity.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="dependentOnMode.ModeDisablingDependency";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="DEPENDENT-ON-MODE-IREF" type="AR:MODE-DISABLING-DEPENDENCY--DEPENDENT-ON-MODE-IREF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ModeDeclaration::ModeDisablingDependency -->
   <xsd:complexType abstract="false" mixed="false" name="MODE-DISABLING-DEPENDENCY">
      <xsd:annotation>
         <xsd:documentation>Collection of references to the Modes that disable the RTEEvent</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeDisablingDependency"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:MODE-DISABLING-DEPENDENCY"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class _instanceRef::ModeDisablingDependency_dependentOnMode -->
   <xsd:group name="MODE-DISABLING-DEPENDENCY--DEPENDENT-ON-MODE-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeDisablingDependency_dependentOnMode"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="R-PORT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ModeDisablingDependency_dependentOnMode.rPortPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="10"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:R-PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODE-DECLARATION-GROUP-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ModeDisablingDependency_dependentOnMode.modeDeclarationGroupPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MODE-DECLARATION-GROUP-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="1" name="MODE-DECLARATION-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ModeDisablingDependency_dependentOnMode.modeDeclaration";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.target</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MODE-DECLARATION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class _instanceRef::ModeDisablingDependency_dependentOnMode -->
   <xsd:complexType abstract="false" mixed="false" name="MODE-DISABLING-DEPENDENCY--DEPENDENT-ON-MODE-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeDisablingDependency_dependentOnMode"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:MODE-DISABLING-DEPENDENCY--DEPENDENT-ON-MODE-IREF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Communication::ModeSwitchComSpec -->
   <xsd:group name="MODE-SWITCH-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>Communication attributes for both sender /server port (P-Port and sender-receiver interface).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeSwitchComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODE-GROUP-REF">
            <xsd:annotation>
               <xsd:documentation>Mode Declaration Group (of the same Port Interface) to which these communication attributes apply.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ModeSwitchComSpec.modeGroup";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MODE-DECLARATION-GROUP-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODE-SWITCHED-ACK" type="AR:MODE-SWITCHED-ACK-REQUEST">
            <xsd:annotation>
               <xsd:documentation>This represents the ModeSwitchedAckrequest owned by the ModeSwitchComSoec.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="modeSwitchedAck.ModeSwitchComSpec";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="QUEUE-LENGTH" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Length of call queue on the server side. The queue is implemented by the RTE. The value must be greater or equal to 0. Setting the value of queueLength to 0 implies non-queued communication.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ModeSwitchComSpec.queueLength";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Communication::ModeSwitchComSpec -->
   <xsd:complexType abstract="false" mixed="false" name="MODE-SWITCH-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>Communication attributes for both sender /server port (P-Port and sender-receiver interface).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeSwitchComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:MODE-SWITCH-COM-SPEC"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class RTEEvents::ModeSwitchEvent -->
   <xsd:group name="MODE-SWITCH-EVENT">
      <xsd:annotation>
         <xsd:documentation>This event is listening to mode changes coming from the StateManager.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeSwitchEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ACTIVATION" type="AR:MODE-ACTIVATION-KIND">
            <xsd:annotation>
               <xsd:documentation>Specifies if the event is activated on entering or exiting the referenced Mode.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ModeSwitchEvent.activation";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODE-IREF" type="AR:MODE-SWITCH-EVENT--MODE-IREF">
            <xsd:annotation>
               <xsd:documentation>Reference to the Mode that initiates the Mode Switch Event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="mode.ModeSwitchEvent";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class RTEEvents::ModeSwitchEvent -->
   <xsd:complexType abstract="false" mixed="false" name="MODE-SWITCH-EVENT">
      <xsd:annotation>
         <xsd:documentation>This event is listening to mode changes coming from the StateManager.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeSwitchEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:RTE-EVENT"/>
         <xsd:group ref="AR:MODE-SWITCH-EVENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class _instanceRef::ModeSwitchEvent_mode -->
   <xsd:group name="MODE-SWITCH-EVENT--MODE-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeSwitchEvent_mode"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="R-PORT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ModeSwitchEvent_mode.rPortPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="10"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:R-PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODE-DECLARATION-GROUP-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ModeSwitchEvent_mode.modeDeclarationGroupPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MODE-DECLARATION-GROUP-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="1" name="MODE-DECLARATION-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ModeSwitchEvent_mode.modeDeclaration";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.target</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MODE-DECLARATION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class _instanceRef::ModeSwitchEvent_mode -->
   <xsd:complexType abstract="false" mixed="false" name="MODE-SWITCH-EVENT--MODE-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeSwitchEvent_mode"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:MODE-SWITCH-EVENT--MODE-IREF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ModeDeclarationGroup::ModeSwitchPoint -->
   <xsd:group name="MODE-SWITCH-POINT">
      <xsd:annotation>
         <xsd:documentation>A ModeSwitchPoint is required by a RunnableEntity owned a Mode Manager. Its semantics implies the ability to initiate a mode switch.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeSwitchPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODE-GROUP-IREF" type="AR:MODE-SWITCH-POINT--MODE-GROUP-IREF">
            <xsd:annotation>
               <xsd:documentation>The mode group that is received by this runnable.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="modeGroup.ModeSwitchPoint";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ModeDeclarationGroup::ModeSwitchPoint -->
   <xsd:complexType abstract="false" mixed="false" name="MODE-SWITCH-POINT">
      <xsd:annotation>
         <xsd:documentation>A ModeSwitchPoint is required by a RunnableEntity owned a Mode Manager. Its semantics implies the ability to initiate a mode switch.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeSwitchPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:MODE-SWITCH-POINT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="MODE-SWITCH-POINT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="MODE-SWITCH-POINT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class _instanceRef::ModeSwitchPoint_modeGroup -->
   <xsd:group name="MODE-SWITCH-POINT--MODE-GROUP-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeSwitchPoint_modeGroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="P-PORT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ModeSwitchPoint_modeGroup.pPortPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="10"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:P-PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="1" name="MODE-DECLARATION-GROUP-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ModeSwitchPoint_modeGroup.modeDeclarationGroupPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.target</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MODE-DECLARATION-GROUP-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class _instanceRef::ModeSwitchPoint_modeGroup -->
   <xsd:complexType abstract="false" mixed="false" name="MODE-SWITCH-POINT--MODE-GROUP-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeSwitchPoint_modeGroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:MODE-SWITCH-POINT--MODE-GROUP-IREF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class RTEEvents::ModeSwitchedAckEvent -->
   <xsd:group name="MODE-SWITCHED-ACK-EVENT">
      <xsd:annotation>
         <xsd:documentation>The event is raised when the referenced mode have been received or an error occurs.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeSwitchedAckEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="EVENT-SOURCE-REF">
            <xsd:annotation>
               <xsd:documentation>Mode switch point that triggers the event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="event.eventSource";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MODE-SWITCH-POINT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class RTEEvents::ModeSwitchedAckEvent -->
   <xsd:complexType abstract="false" mixed="false" name="MODE-SWITCHED-ACK-EVENT">
      <xsd:annotation>
         <xsd:documentation>The event is raised when the referenced mode have been received or an error occurs.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeSwitchedAckEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:RTE-EVENT"/>
         <xsd:group ref="AR:MODE-SWITCHED-ACK-EVENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Communication::ModeSwitchedAckRequest -->
   <xsd:group name="MODE-SWITCHED-ACK-REQUEST">
      <xsd:annotation>
         <xsd:documentation>Requests acknowledgements that a mode switch has been proceeded successfully</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeSwitchedAckRequest"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMEOUT" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Number of seconds before an error is reported or in case of allowed redundancy, the value is sent again.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ModeSwitchedAckRequest.timeout";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Communication::ModeSwitchedAckRequest -->
   <xsd:complexType abstract="false" mixed="false" name="MODE-SWITCHED-ACK-REQUEST">
      <xsd:annotation>
         <xsd:documentation>Requests acknowledgements that a mode switch has been proceeded successfully</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModeSwitchedAckRequest"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:MODE-SWITCHED-ACK-REQUEST"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class AdminData::Modification -->
   <xsd:group name="MODIFICATION">
      <xsd:annotation>
         <xsd:documentation>Use &lt;modification&gt; to record what has changed in a document in comparison to its predecessor.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Modification"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CHANGE" type="AR:ML-DATA-2">
            <xsd:annotation>
               <xsd:documentation>&lt;change&gt; is used to enter a modification text for a &lt;modification&gt; element. The element has the same contents and features as a normal Pararagraf element &lt;p&gt;.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Modification.change";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REASON" type="AR:ML-DATA-2">
            <xsd:annotation>
               <xsd:documentation>Use &lt;reason&gt; to cite the reason for changes to the document version.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Modification.reason";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class AdminData::Modification -->
   <xsd:complexType abstract="false" mixed="false" name="MODIFICATION">
      <xsd:annotation>
         <xsd:documentation>Use &lt;modification&gt; to record what has changed in a document in comparison to its predecessor.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Modification"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:MODIFICATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ECUCDescriptionTemplate::ModuleConfiguration -->
   <xsd:group name="MODULE-CONFIGURATION">
      <xsd:annotation>
         <xsd:documentation>Head of the configuration of one Module. A Module can be a BSW module as well as the RTE and ECU Infrastructure.

      As part of tthe BSW module description, the ModuleConfiguration has two different roles:

      The recommendedConfiguration contains parameter values recommended by the BSW module vendor. 

      The preconfiguredConfiguration contains values for those parameters which are fixed by the implementation and cannot be changed.

      These two ModuleConfigurations are used when the base ModuleConfiguration (as part of the base ECU configuration) is created to fill parameters with initial values.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModuleConfiguration"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DEFINITION-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the definition of this ModuleConfiguration.
            Typically, this is a vendor specific module configuration.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ModuleConfiguration.definition";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="-10"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MODULE-DEF--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="IMPLEMENTATION-CONFIG-VARIANT" type="AR:CONFIGURATION-VARIANT">
            <xsd:annotation>
               <xsd:documentation>Specifies the ConfigurationVariant used for this ModuleConfiguration.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ModuleConfiguration.implementationConfigVariant";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODULE-DESCRIPTION-REF">
            <xsd:annotation>
               <xsd:documentation>Referencing the BSW module description, which this ModuleConfiguration is configuring. This is optional because the ModuleConfiguration is also used to configure the ECU infrastructure (memory map) or Application SW-Cs.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ModuleConfiguration.moduleDescription";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:BSW-IMPLEMENTATION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONTAINERS">
            <xsd:annotation>
               <xsd:documentation>Aggregates all containers that belong to this module configuration.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="container.ModuleConfiguration";pureMM.maxOccurs="-1";pureMM.minOccurs="1";xml.sequenceOffset="10"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CONTAINER" type="AR:CONTAINER"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCDescriptionTemplate::ModuleConfiguration -->
   <xsd:complexType abstract="false" mixed="false" name="MODULE-CONFIGURATION">
      <xsd:annotation>
         <xsd:documentation>Head of the configuration of one Module. A Module can be a BSW module as well as the RTE and ECU Infrastructure.

      As part of tthe BSW module description, the ModuleConfiguration has two different roles:

      The recommendedConfiguration contains parameter values recommended by the BSW module vendor. 

      The preconfiguredConfiguration contains values for those parameters which are fixed by the implementation and cannot be changed.

      These two ModuleConfigurations are used when the base ModuleConfiguration (as part of the base ECU configuration) is created to fill parameters with initial values.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModuleConfiguration"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:MODULE-CONFIGURATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="MODULE-CONFIGURATION--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="MODULE-CONFIGURATION"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ECUCParameterDefTemplate::ModuleDef -->
   <xsd:group name="MODULE-DEF">
      <xsd:annotation>
         <xsd:documentation>Used as the top-level element for configuration definition for Software Modules, including BSW and RTE as well as ECU Infrastructure.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModuleDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="REFINED-MODULE-DEF-REF">
            <xsd:annotation>
               <xsd:documentation>Optional reference from the Vendor Specific Module Definition to the Standardized Module Definition it refines.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ModuleDef.refinedModuleDef";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:MODULE-DEF--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SUPPORTED-CONFIG-VARIANTS">
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element maxOccurs="unbounded" minOccurs="0" name="SUPPORTED-CONFIG-VARIANT" type="AR:CONFIGURATION-VARIANT">
                     <xsd:annotation>
                        <xsd:documentation>Specifies which ConfigurationVariants are supported by this software module.</xsd:documentation>
                        <xsd:appinfo source="tags">mmt.qualifiedName="ModuleDef.supportedConfigVariant";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
                     </xsd:annotation>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONTAINERS">
            <xsd:annotation>
               <xsd:documentation>Aggregates the top-level container definitions of this specific module definition.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="container.ModuleDef";pureMM.maxOccurs="-1";pureMM.minOccurs="1";xml.sequenceOffset="11"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CHOICE-CONTAINER-DEF" type="AR:CHOICE-CONTAINER-DEF"/>
                  <xsd:element name="PARAM-CONF-CONTAINER-DEF" type="AR:PARAM-CONF-CONTAINER-DEF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::ModuleDef -->
   <xsd:complexType abstract="false" mixed="false" name="MODULE-DEF">
      <xsd:annotation>
         <xsd:documentation>Used as the top-level element for configuration definition for Software Modules, including BSW and RTE as well as ECU Infrastructure.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ModuleDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PARAM-CONF-MULTIPLICITY"/>
         <xsd:group ref="AR:MODULE-DEF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="MODULE-DEF--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="MODULE-DEF"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class CoreCommunication::MultiplexedIPdu -->
   <xsd:group name="MULTIPLEXED-I-PDU">
      <xsd:annotation>
         <xsd:documentation>A MultiplexedPdu (i.e. NOT a COM I-PDU) contains a DynamicPart, an optional StaticPart and a selectorField. In case of multiplexing this IPdu is routed between the Pdu Multiplexer and the Interface Layer.

      A multiplexer is used to define variable parts within an IPdu that may carry different signals. The receivers of such a IPdu can determine which signalPdus are transmitted by evaluating the selector field, which carries a unique selector code for each sub-part.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MultiplexedIPdu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DYNAMIC-PART" type="AR:DYNAMIC-PART">
            <xsd:annotation>
               <xsd:documentation>According to the value of the selector field some parts of the IPdu have a different layout.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="dynamicPart.MultiplexedIPdu";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SELECTOR-FIELD-BYTE-ORDER" type="AR:BYTE-ORDER-ENUM">
            <xsd:annotation>
               <xsd:documentation>This attribute defines the order of the bytes of the selectorField and the packing into the MultiplexedIPdu. The byte ordering "Little Endian" (MostSignificantByteLast) and "Big Endian" (MostSignificantByteFirst) can be selected.
            A mix between Little Endian and Big Endian within a MultiplexedIPdu (staticPart, dynamicPart, selectorField) is not allowed.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MultiplexedIPdu.selectorFieldByteOrder";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SELECTOR-FIELD-LENGTH" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The size in bits of the selector field shall be configurable in a range of one bit and eight bits.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MultiplexedIPdu.selectorFieldLength";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SELECTOR-FIELD-START-POSITION" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>This parameter is necessary to describe the position of the selector field within the IPdu.

            Note that the absolute position of the selectorField in the MultiplexedIPdu is determined by the definition of the selectorFieldByteOrder attribute of the Multiplexed Pdu. If Big Endian is specified, the start position indicates the bit position of the most significant bit in the IPdu. If Little Endian is specified, the start position indicates the bit position of the least significant bit in the IPdu.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MultiplexedIPdu.selectorFieldStartPosition";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="STATIC-PART" type="AR:STATIC-PART">
            <xsd:annotation>
               <xsd:documentation>The static part of the multiplexed IPdu is the same regardless of the selector field. The static part is optional.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="staticPart.MultiplexedIPdu";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TRIGGER-MODE" type="AR:TRIGGER-MODE">
            <xsd:annotation>
               <xsd:documentation>IPduM can be configured to send a transmission request for the new multiplexed I-PDU to the PDU-Router because of the trigger conditions/ modes that are described in the TriggerMode enumeration.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="MultiplexedIPdu.triggerMode";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::MultiplexedIPdu -->
   <xsd:complexType abstract="false" mixed="false" name="MULTIPLEXED-I-PDU">
      <xsd:annotation>
         <xsd:documentation>A MultiplexedPdu (i.e. NOT a COM I-PDU) contains a DynamicPart, an optional StaticPart and a selectorField. In case of multiplexing this IPdu is routed between the Pdu Multiplexer and the Interface Layer.

      A multiplexer is used to define variable parts within an IPdu that may carry different signals. The receivers of such a IPdu can determine which signalPdus are transmitted by evaluating the selector field, which carries a unique selector code for each sub-part.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MultiplexedIPdu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:I-PDU"/>
         <xsd:group ref="AR:MULTIPLEXED-I-PDU"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class CoreCommunication::MultiplexedPart -->
   <xsd:group name="MULTIPLEXED-PART">
      <xsd:annotation>
         <xsd:documentation>The StaticPart and the DynamicPart have common properties. Both can be separated in multiple segments within the multiplexed PDU.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="MultiplexedPart"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SEGMENT-POSITIONS">
            <xsd:annotation>
               <xsd:documentation>The StaticPart and the DynamicPart can be separated in multiple segments within the multiplexed PDU. Therefore the StaticPart and the DynamicPart can contain multiple SegmentPositions.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="segmentPosition.MultiplexedPart";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SEGMENT-POSITION" type="AR:SEGMENT-POSITION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::NPdu -->
   <xsd:complexType abstract="false" mixed="false" name="N-PDU">
      <xsd:annotation>
         <xsd:documentation>This is a PDU of the Transport Layer.
      The main purpose of the TP Layer is to segment and reassemble I-PDUs.

      In case of a Pdu Gateway when the source and the target network are of the same kind (e.g. Can-to-Can routing) it is possible to optimize the routing. The incoming NPdu can be directly forwarded to the PduR and then be sent on the outbound bus without any (resource consuming) TP module involvement. To support this use case the NPdu is located under the IPdu. But in the AUTOSAR Layered Architecture the NPdu is not a specialization of an IPdu.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NPdu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:I-PDU"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="N-PDU--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="N-PDU"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- complex type for class Filter::Never -->
   <xsd:complexType abstract="false" mixed="false" name="NEVER">
      <xsd:annotation>
         <xsd:documentation>The filter removes all messages.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Never"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Filter::NewIsOutside -->
   <xsd:group name="NEW-IS-OUTSIDE">
      <xsd:annotation>
         <xsd:documentation>Pass a message if its value is outside a predefined boundary.

      (min &gt; new_value) OR (new_value &gt; max)</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NewIsOutside"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Value to specify the upper boundary</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NewIsOutside.max";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MIN" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Value to specify the lower boundary</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NewIsOutside.min";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Filter::NewIsOutside -->
   <xsd:complexType abstract="false" mixed="false" name="NEW-IS-OUTSIDE">
      <xsd:annotation>
         <xsd:documentation>Pass a message if its value is outside a predefined boundary.

      (min &gt; new_value) OR (new_value &gt; max)</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NewIsOutside"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:NEW-IS-OUTSIDE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Filter::NewIsWithin -->
   <xsd:group name="NEW-IS-WITHIN">
      <xsd:annotation>
         <xsd:documentation>Pass a message if its value is within a predefined boundary.

      min &lt;= new_value &lt;= max</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NewIsWithin"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Value to specify the upper boundary</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NewIsWithin.max";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MIN" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Value to specify the lower boundary</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NewIsWithin.min";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Filter::NewIsWithin -->
   <xsd:complexType abstract="false" mixed="false" name="NEW-IS-WITHIN">
      <xsd:annotation>
         <xsd:documentation>Pass a message if its value is within a predefined boundary.

      min &lt;= new_value &lt;= max</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NewIsWithin"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:NEW-IS-WITHIN"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CoreCommunication::NmPdu -->
   <xsd:group name="NM-PDU">
      <xsd:annotation>
         <xsd:documentation>Network Management I-Pdu</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NmPdu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="I-SIGNAL-TO-I-PDU-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>This optional aggregation is used to describe NmUserData that is transmitted in the NmPdu.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="iSignalToIPduMapping.NmPdu";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="I-SIGNAL-TO-I-PDU-MAPPING" type="AR:I-SIGNAL-TO-I-PDU-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="LENGTH" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The size of the NmPDU in bits.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NmPdu.length";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-CBV-POSITION" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Defines the position of the control bit vector within the NM PDU (Bitpositon).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NmPdu.nmCbvPosition";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-NID-POSITION" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Defines the bitposition of the source node identifier within the NM PDU.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NmPdu.nmNidPosition";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NM-USER-DATA-LENGTH" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Defines the length in Bytes of the user data contained in the NM PDU.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NmPdu.nmUserDataLength";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::NmPdu -->
   <xsd:complexType abstract="false" mixed="false" name="NM-PDU">
      <xsd:annotation>
         <xsd:documentation>Network Management I-Pdu</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NmPdu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:NM-PDU"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ServiceNeeds::NvBlockNeeds -->
   <xsd:group name="NV-BLOCK-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs on the configuration of a single Nv block.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NvBlockNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="N-DATA-SETS" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>number of data sets to be provided by the NVRAM manager for this block</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NvBlockNeeds.nDataSets";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="READONLY" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>true: data of this block are write protected for normal operation (but protection can be disabled)
            false: no restriction</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NvBlockNeeds.readonly";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RELIABILITY" type="AR:NV-BLOCK-NEEDS-RELIABILITY-ENUM">
            <xsd:annotation>
               <xsd:documentation>Reliability against data loss on the non-volatile medium.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NvBlockNeeds.reliability";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RESISTANT-TO-CHANGED-SW" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Defines whether an Nv block shall be treated resistant to configuration changes (true) or not (false). For details how to handle initialization in the latter case, refer to the NVRAM specification.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NvBlockNeeds.resistantToChangedSw";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RESTORE-AT-START" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Defines whether the associated RAM mirror block shall be implictly restored during startup by the basic SW or not. Only relevant if a RAM mirror block (PerInstanceMemory) is associated with this port.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NvBlockNeeds.restoreAtStart";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="WRITE-ONLY-ONCE" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Defines write protection after first write:
            true: This block is prevented from being changed/erased or being replaced with the default ROM data after first initialization by the SWC.
            false: No such restriction.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NvBlockNeeds.writeOnlyOnce";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="WRITING-FREQUENCY" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Provides the amount of updates to this block from the application point of view. It has to be provided in "number of write access per year".</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NvBlockNeeds.writingFrequency";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="WRITING-PRIORITY" type="AR:NV-BLOCK-NEEDS-WRITING-PRIORITY-ENUM">
            <xsd:annotation>
               <xsd:documentation>Requires the priority of writing this block in case of concurrent requests to write other blocks.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="NvBlockNeeds.writingPriority";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceNeeds::NvBlockNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="NV-BLOCK-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs on the configuration of a single Nv block.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="NvBlockNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:NV-BLOCK-NEEDS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ServiceNeeds::ObdControlServiceNeeds -->
   <xsd:group name="OBD-CONTROL-SERVICE-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs of a compoment or module on the configuration of OBD Service 08 (request control of on-board system) in relation to a particular test-Identifier (TID) supported by this component or module.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ObdControlServiceNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TEST-ID" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Test Identifier (TID) according to ISO 15031-5.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ObdControlServiceNeeds.testId";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceNeeds::ObdControlServiceNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="OBD-CONTROL-SERVICE-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs of a compoment or module on the configuration of OBD Service 08 (request control of on-board system) in relation to a particular test-Identifier (TID) supported by this component or module.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ObdControlServiceNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:OBD-CONTROL-SERVICE-NEEDS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ServiceNeeds::ObdInfoServiceNeeds -->
   <xsd:group name="OBD-INFO-SERVICE-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs of a compoment or module on the configuration of OBD Services in relation to a given InfoType (OBD Service 09), which is supported by this component or module.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ObdInfoServiceNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-LENGTH" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Length of date (in bytes) provided for this InfoType.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ObdInfoServiceNeeds.dataLength";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INFO-TYPE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The InfoType according to ISO 15031-5</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ObdInfoServiceNeeds.infoType";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceNeeds::ObdInfoServiceNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="OBD-INFO-SERVICE-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs of a compoment or module on the configuration of OBD Services in relation to a given InfoType (OBD Service 09), which is supported by this component or module.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ObdInfoServiceNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:OBD-INFO-SERVICE-NEEDS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ServiceNeeds::ObdMonitorServiceNeeds -->
   <xsd:group name="OBD-MONITOR-SERVICE-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs of a compoment or module on the configuration of OBD Services in relation to a particular on-board monitoring test supported by this component or module. (OBD Service 06).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ObdMonitorServiceNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ON-BOARD-MONITOR-ID" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>On-board monitor ID according to ISO 15031-5.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ObdMonitorServiceNeeds.onBoardMonitorId";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TEST-ID" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Test Identifier (TID) according to ISO 15031-5.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ObdMonitorServiceNeeds.testId";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="UNIT-AND-SCALING-ID" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Unit and scaling ID according to ISO 15031-5.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ObdMonitorServiceNeeds.unitAndScalingId";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceNeeds::ObdMonitorServiceNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="OBD-MONITOR-SERVICE-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs of a compoment or module on the configuration of OBD Services in relation to a particular on-board monitoring test supported by this component or module. (OBD Service 06).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ObdMonitorServiceNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:OBD-MONITOR-SERVICE-NEEDS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ServiceNeeds::ObdPidServiceNeeds -->
   <xsd:group name="OBD-PID-SERVICE-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs of a compoment or module on the configuration of OBD Services in relation to a particular PID (parameter identifier), which is supported by this component or module.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ObdPidServiceNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-LENGTH" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Length of data (in bytes) provided for this particular PID.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ObdPidServiceNeeds.dataLength";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PARAMETER-ID" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Standardized parameter identifier (PID) according to the OBD standard specified in attribute "standard".</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ObdPidServiceNeeds.parameterId";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="STANDARD" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Annotates the standard according to which the PID is given, e.g. "ISO15031-5" or "SAE J1979 Rev May 2007".</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ObdPidServiceNeeds.standard";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceNeeds::ObdPidServiceNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="OBD-PID-SERVICE-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs of a compoment or module on the configuration of OBD Services in relation to a particular PID (parameter identifier), which is supported by this component or module.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ObdPidServiceNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:OBD-PID-SERVICE-NEEDS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ServiceNeeds::ObdRatioServiceNeeds -->
   <xsd:group name="OBD-RATIO-SERVICE-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs of a compoment or module on the configuration of OBD Services in relation to a particular "ratio monitoring", which is supported by this component or module.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ObdRatioServiceNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONNECTION-TYPE" type="AR:OBD-RATIO-CONNECTION-KIND">
            <xsd:annotation>
               <xsd:documentation>Defines how the DEM is connected to the component or module to perform the IUMPR service.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ObdRatioServiceNeeds.connectionType";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="IUMPR-GROUP" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Defines the IUMPR Group of the SAE standard. Note that possible values are not predefined by an enumeration meta-type in oder to make the meta-model independent of the details of the SAE standard. Possible values are currently (AUTOSAR R3.1):
            CAT1 CAT2 OXS1 OXS2 EGR SAIR EVAP SECOXS1 SECOXS2 NMHCCAT NOXCAT NOXADSORB PMFILTER EGSENSOR BOOSTPRS NOGROUP NONE.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ObdRatioServiceNeeds.iumprGroup";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RATE-BASED-MONITORED-EVENT-REF">
            <xsd:annotation>
               <xsd:documentation>The rate based monitored Diagnosic Event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ObdRatioServiceNeeds.rateBasedMonitoredEvent";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:DIAGNOSTIC-EVENT-NEEDS--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="USED-FID-REF">
            <xsd:annotation>
               <xsd:documentation>Function Inhibition Identifier used for the rate based monitor. This is an optional attribute.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ObdRatioServiceNeeds.usedFid";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:FUNCTION-INHIBITION-NEEDS--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceNeeds::ObdRatioServiceNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="OBD-RATIO-SERVICE-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs of a compoment or module on the configuration of OBD Services in relation to a particular "ratio monitoring", which is supported by this component or module.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ObdRatioServiceNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:OBD-RATIO-SERVICE-NEEDS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Filter::OneEveryN -->
   <xsd:group name="ONE-EVERY-N">
      <xsd:annotation>
         <xsd:documentation>Pass a message once every N message occurrences.
      Algorithm: occurrence % period == offset
      Start: occurrence = 0.
      Each time the message is received or transmitted, occurrence is incremented by 1 after filtering.
      Length of occurrence is 8 bit (minimum).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="OneEveryN"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="OFFSET" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>specifies the initial number of messages to occur before the first message is passed</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="OneEveryN.offset";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PERIOD" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>specifies number of messages to occur before the message is passed again</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="OneEveryN.period";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Filter::OneEveryN -->
   <xsd:complexType abstract="false" mixed="false" name="ONE-EVERY-N">
      <xsd:annotation>
         <xsd:documentation>Pass a message once every N message occurrences.
      Algorithm: occurrence % period == offset
      Start: occurrence = 0.
      Each time the message is received or transmitted, occurrence is incremented by 1 after filtering.
      Length of occurrence is 8 bit (minimum).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="OneEveryN"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:ONE-EVERY-N"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Constants::OpaqueLiteral -->
   <xsd:group name="OPAQUE-LITERAL">
      <xsd:annotation>
         <xsd:documentation>An opaque literal.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="OpaqueLiteral"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VALUE" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>The string encodes an array of bytes in the following syntax "ae:05:fe"</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="OpaqueLiteral.value";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Constants::OpaqueLiteral -->
   <xsd:complexType abstract="false" mixed="false" name="OPAQUE-LITERAL">
      <xsd:annotation>
         <xsd:documentation>An opaque literal.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="OpaqueLiteral"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:DATA-PROTOTYPE"/>
         <xsd:group ref="AR:OPAQUE-LITERAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Datatypes::OpaqueType -->
   <xsd:group name="OPAQUE-TYPE">
      <xsd:annotation>
         <xsd:documentation>This Datatype represents an array of exactly numberOfBits bits.  It is called "opaque" because this array of bits should be transported "as is" by the AUTOSAR RTE.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="OpaqueType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpType</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="NUMBER-OF-BITS" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The number of bits that are used to make up the opaque type.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="OpaqueType.numberOfBits";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Datatypes::OpaqueType -->
   <xsd:complexType abstract="false" mixed="false" name="OPAQUE-TYPE">
      <xsd:annotation>
         <xsd:documentation>This Datatype represents an array of exactly numberOfBits bits.  It is called "opaque" because this array of bits should be transported "as is" by the AUTOSAR RTE.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="OpaqueType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpType</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PRIMITIVE-TYPE"/>
         <xsd:group ref="AR:OPAQUE-TYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class RTEEvents::OperationInvokedEvent -->
   <xsd:group name="OPERATION-INVOKED-EVENT">
      <xsd:annotation>
         <xsd:documentation>The OperationInvokedEvent references the OperationPrototype invoked by the client.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="OperationInvokedEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="OPERATION-IREF" type="AR:OPERATION-INVOKED-EVENT--OPERATION-IREF">
            <xsd:annotation>
               <xsd:documentation>The operation to be executed as the consequence of the event.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="operation.event";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class RTEEvents::OperationInvokedEvent -->
   <xsd:complexType abstract="false" mixed="false" name="OPERATION-INVOKED-EVENT">
      <xsd:annotation>
         <xsd:documentation>The OperationInvokedEvent references the OperationPrototype invoked by the client.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="OperationInvokedEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:RTE-EVENT"/>
         <xsd:group ref="AR:OPERATION-INVOKED-EVENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class _instanceRef::OperationInvokedEvent_operation -->
   <xsd:group name="OPERATION-INVOKED-EVENT--OPERATION-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="OperationInvokedEvent_operation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="P-PORT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="OperationInvokedEvent_operation.pPortPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="10"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:P-PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="1" name="OPERATION-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="OperationInvokedEvent_operation.operationPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.target</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:OPERATION-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class _instanceRef::OperationInvokedEvent_operation -->
   <xsd:complexType abstract="false" mixed="false" name="OPERATION-INVOKED-EVENT--OPERATION-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="OperationInvokedEvent_operation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:OPERATION-INVOKED-EVENT--OPERATION-IREF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class PortInterface::OperationPrototype -->
   <xsd:group name="OPERATION-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>An operation declared within the scope of a client/server interface.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="OperationPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpStructureElement</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ARGUMENTS">
            <xsd:annotation>
               <xsd:documentation>ArgumentPrototypes owned by this OperationPrototype.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="argument.OperationPrototype";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ARGUMENT-PROTOTYPE" type="AR:ARGUMENT-PROTOTYPE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="POSSIBLE-ERROR-REFS">
            <xsd:annotation>
               <xsd:documentation>Possible errors that may by raised by referring operation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="OperationPrototype.possibleError";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="POSSIBLE-ERROR-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:APPLICATION-ERROR--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class PortInterface::OperationPrototype -->
   <xsd:complexType abstract="false" mixed="false" name="OPERATION-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>An operation declared within the scope of a client/server interface.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="OperationPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpStructureElement</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:OPERATION-PROTOTYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="OPERATION-PROTOTYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="OPERATION-PROTOTYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ECUElectronics::Oscillator -->
   <xsd:group name="OSCILLATOR">
      <xsd:annotation>
         <xsd:documentation>The basic source for time in the ECU. Based on the oscillator the PU clock is generated, but also the communication and other peripherals need timing information (ADC, PWM, timer).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Oscillator"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ADJUSTIBLE" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Defines if the oscillator is adjustable from software.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Oscillator.adjustible";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="BACKUP-OSCILLATOR" type="AR:OSCILLATOR">
            <xsd:annotation>
               <xsd:documentation>An internal, very inaccurate RC-oscillator, which provide the PU with a clock source when the external oscillator is not available.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="backupOscillator.Oscillator";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="OSCILLATOR-FREQUENCY-RANGE" type="AR:FREQUENCY-RANGE">
            <xsd:annotation>
               <xsd:documentation>The frequency range the oscillator is able to provide.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="oscillatorFrequencyRange.Oscillator";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="OSCILLATOR-JITTER" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>The short-term deviation of the nominal frequency to the real frequency. Jitter is influenced by the circuitry itself, voltage spikes etc. Jitter is critical for communication elements.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Oscillator.oscillatorJitter";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="OSCILLATOR-MODE" type="AR:OSCILLATOR-MODE-ENUM">
            <xsd:annotation>
               <xsd:documentation>Crystals and other oscillating elements have more than one resonant frequencies, which are usually odd harmonics to the basic, fundamental frequencies. For Automotive a basic requirement should be to use only fundamental mode only. Using overtone modes there is a risk, that the oscillator circuitry starts at the fundamental mode after a error in the start up routine. In order to reach an overtone mode the frequency of the fundamental mode, or lower overtones has to be passed during start up. There is a risk that the oscillator locks to this, lower frequency. Therefore Fundamental modes oscillatorts are not so critical for this issue. Fundamental quartz/crystals can reach up to 40 MHz today, above this frequency all quartz/crystals are running in the 3rd, 5th or higher overtone mode.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Oscillator.oscillatorMode";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="OSCILLATOR-STARTUP-TIME" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>The time the oscillator needs to deliver a stable and valid signal.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Oscillator.oscillatorStartupTime";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="OSCILLATOR-TOLERANCE" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>The long-term deviation of the nominal frequency to the real frequency. Influenced by manufacturing, layout, temperature, external components and voltage. Tolerances are critical for timer application and time synchronisation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Oscillator.oscillatorTolerance";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUElectronics::Oscillator -->
   <xsd:complexType abstract="false" mixed="false" name="OSCILLATOR">
      <xsd:annotation>
         <xsd:documentation>The basic source for time in the ECU. Based on the oscillator the PU clock is generated, but also the communication and other peripherals need timing information (ADC, PWM, timer).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Oscillator"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HW-ELEMENT"/>
         <xsd:group ref="AR:ECU-ELECTRONICS"/>
         <xsd:group ref="AR:OSCILLATOR"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="OSCILLATOR--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="OSCILLATOR"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Components::PPortPrototype -->
   <xsd:group name="P-PORT-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>Component port providing a certain port interface.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PPortPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="PROVIDED-COM-SPECS">
            <xsd:annotation>
               <xsd:documentation>Provided communication attributes per interface element (data element or operation).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="providedComSpec.PPortPrototype";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="MODE-SWITCH-COM-SPEC" type="AR:MODE-SWITCH-COM-SPEC"/>
                  <xsd:element name="PARAMETER-PROVIDE-COM-SPEC" type="AR:PARAMETER-PROVIDE-COM-SPEC"/>
                  <xsd:element name="QUEUED-SENDER-COM-SPEC" type="AR:QUEUED-SENDER-COM-SPEC"/>
                  <xsd:element name="SERVER-COM-SPEC" type="AR:SERVER-COM-SPEC"/>
                  <xsd:element name="UNQUEUED-SENDER-COM-SPEC" type="AR:UNQUEUED-SENDER-COM-SPEC"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PROVIDED-INTERFACE-TREF">
            <xsd:annotation>
               <xsd:documentation>The interface that this port provides.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="pPort.providedInterface";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">isOfType</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-INTERFACE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Components::PPortPrototype -->
   <xsd:complexType abstract="false" mixed="false" name="P-PORT-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>Component port providing a certain port interface.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PPortPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PORT-PROTOTYPE"/>
         <xsd:group ref="AR:P-PORT-PROTOTYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="P-PORT-PROTOTYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="P-PORT-PROTOTYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Peripherals::PWD -->
   <xsd:group name="PWD">
      <xsd:annotation>
         <xsd:documentation>Pulse Width Demodulation is the inverse method of PWM. Here the processing unit is trying to gather information about a signal. A PWD can detect rising and falling edges and call the software in order to calculate the pulse width. When a PWD have more than one input signal the frequency and phase between the signals can be obtained.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PWD"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODE" type="AR:PWD-MODE-ENUM">
            <xsd:annotation>
               <xsd:documentation>A Pulse Width Demodulation peripheral can be configured to decode a two phase or a three phase input signals.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PWD.mode";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PHASE-DETECTION" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Some timers have the possibility to detect signals from a quadrature rotating switch. There are two outputs signal from such a switch; the signals are 90 degrees phase shifted from each other. The rotation of the switch can then automatically be detected by a special function in a timer.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PWD.phaseDetection";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Peripherals::PWD -->
   <xsd:complexType abstract="false" mixed="false" name="PWD">
      <xsd:annotation>
         <xsd:documentation>Pulse Width Demodulation is the inverse method of PWM. Here the processing unit is trying to gather information about a signal. A PWD can detect rising and falling edges and call the software in order to calculate the pulse width. When a PWD have more than one input signal the frequency and phase between the signals can be obtained.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PWD"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HW-ELEMENT"/>
         <xsd:group ref="AR:PERIPHERAL"/>
         <xsd:group ref="AR:PULSE-WIDTH-PERIPHERAL"/>
         <xsd:group ref="AR:PWD"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- complex type for class Peripherals::PWM -->
   <xsd:complexType abstract="false" mixed="false" name="PWM">
      <xsd:annotation>
         <xsd:documentation>Pulse Width Modulation refers to a method of carrying information on a train of pulses, the information being encoded in the width of the pulses. The frequency is normally not changed. It's only relationship between the high and low level of the signal which are changed. A PWM interface is usually a part of a processing unit. It provides the capability to communicate with another system with an easy protocol.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PWM"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HW-ELEMENT"/>
         <xsd:group ref="AR:PERIPHERAL"/>
         <xsd:group ref="AR:PULSE-WIDTH-PERIPHERAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUCParameterDefTemplate::ParamConfContainerDef -->
   <xsd:group name="PARAM-CONF-CONTAINER-DEF">
      <xsd:annotation>
         <xsd:documentation>The period between successive calls to Com_MainFunctionRx in seconds. This parameter may be used by the COM generator to transform the values of the reception related timing configuration parameters of the COM module to internal implementation specific counter or tick values. The COM module's internal timing handling is implementation specific. The COM module (generator) may rely on the fact that Com_MainFunctionRx is scheduled according to the value configured here.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ParamConfContainerDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MULTIPLE-CONFIGURATION-CONTAINER" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Specifies whether this container is used to define multiple configuration sets. Only one container in the whole ModuleDef shall have this enabled.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ParamConfContainerDef.multipleConfigurationContainer";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PARAMETERS">
            <xsd:annotation>
               <xsd:documentation>The parameters defined within the ParamConfContainerDef.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="parameter.ParamConfContainerDef";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="BOOLEAN-PARAM-DEF" type="AR:BOOLEAN-PARAM-DEF"/>
                  <xsd:element name="DERIVED-BOOLEAN-PARAM-DEF" type="AR:DERIVED-BOOLEAN-PARAM-DEF"/>
                  <xsd:element name="DERIVED-ENUMERATION-PARAM-DEF" type="AR:DERIVED-ENUMERATION-PARAM-DEF"/>
                  <xsd:element name="DERIVED-FLOAT-PARAM-DEF" type="AR:DERIVED-FLOAT-PARAM-DEF"/>
                  <xsd:element name="DERIVED-INTEGER-PARAM-DEF" type="AR:DERIVED-INTEGER-PARAM-DEF"/>
                  <xsd:element name="DERIVED-STRING-PARAM-DEF" type="AR:DERIVED-STRING-PARAM-DEF"/>
                  <xsd:element name="ENUMERATION-PARAM-DEF" type="AR:ENUMERATION-PARAM-DEF"/>
                  <xsd:element name="FLOAT-PARAM-DEF" type="AR:FLOAT-PARAM-DEF"/>
                  <xsd:element name="FUNCTION-NAME-DEF" type="AR:FUNCTION-NAME-DEF"/>
                  <xsd:element name="INTEGER-PARAM-DEF" type="AR:INTEGER-PARAM-DEF"/>
                  <xsd:element name="LINKER-SYMBOL-DEF" type="AR:LINKER-SYMBOL-DEF"/>
                  <xsd:element name="STRING-PARAM-DEF" type="AR:STRING-PARAM-DEF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REFERENCES">
            <xsd:annotation>
               <xsd:documentation>The references defined within the ParamConfContainerDef.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="reference.ParamConfContainerDef";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CHOICE-REFERENCE-PARAM-DEF" type="AR:CHOICE-REFERENCE-PARAM-DEF"/>
                  <xsd:element name="FOREIGN-REFERENCE-PARAM-DEF" type="AR:FOREIGN-REFERENCE-PARAM-DEF"/>
                  <xsd:element name="INSTANCE-REFERENCE-PARAM-DEF" type="AR:INSTANCE-REFERENCE-PARAM-DEF"/>
                  <xsd:element name="REFERENCE-PARAM-DEF" type="AR:REFERENCE-PARAM-DEF"/>
                  <xsd:element name="SYMBOLIC-NAME-REFERENCE-PARAM-DEF" type="AR:SYMBOLIC-NAME-REFERENCE-PARAM-DEF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SUB-CONTAINERS">
            <xsd:annotation>
               <xsd:documentation>The containers defined within the ParamConfContainerDef.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="subContainer.ParamConfContainerDef";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CHOICE-CONTAINER-DEF" type="AR:CHOICE-CONTAINER-DEF"/>
                  <xsd:element name="PARAM-CONF-CONTAINER-DEF" type="AR:PARAM-CONF-CONTAINER-DEF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::ParamConfContainerDef -->
   <xsd:complexType abstract="false" mixed="false" name="PARAM-CONF-CONTAINER-DEF">
      <xsd:annotation>
         <xsd:documentation>The period between successive calls to Com_MainFunctionRx in seconds. This parameter may be used by the COM generator to transform the values of the reception related timing configuration parameters of the COM module to internal implementation specific counter or tick values. The COM module's internal timing handling is implementation specific. The COM module (generator) may rely on the fact that Com_MainFunctionRx is scheduled according to the value configured here.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ParamConfContainerDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PARAM-CONF-MULTIPLICITY"/>
         <xsd:group ref="AR:CONTAINER-DEF"/>
         <xsd:group ref="AR:PARAM-CONF-CONTAINER-DEF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="PARAM-CONF-CONTAINER-DEF--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="PARAM-CONF-CONTAINER-DEF"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ECUCParameterDefTemplate::ParamConfMultiplicity -->
   <xsd:group name="PARAM-CONF-MULTIPLICITY">
      <xsd:annotation>
         <xsd:documentation>Common class used to express multiplicities in the definition of configuration parameters, references and containers.
      If not stated otherwise the default multiplicity is exactly one mandatory occurrence of the specified element.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ParamConfMultiplicity"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="LOWER-MULTIPLICITY" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>The lower multiplicity of the specified element.
            0: optional
            1: at least one occurence
            n: at least n occurrences</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ParamConfMultiplicity.lowerMultiplicity";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="UPPER-MULTIPLICITY" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>The upper multiplicity of the specified element.
            1: at most one occurrence
            m: at most m occurrences
            *: arbitrary number of occurrences</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ParamConfMultiplicity.upperMultiplicity";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Communication::ParameterProvideComSpec -->
   <xsd:complexType abstract="false" mixed="false" name="PARAMETER-PROVIDE-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to provide an initial value for a calibration parameter.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ParameterProvideComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:INIT-VALUE-ASSIGNMENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- complex type for class Communication::ParameterRequireComSpec -->
   <xsd:complexType abstract="false" mixed="false" name="PARAMETER-REQUIRE-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>This meta-class represents the ability to define an initial value for a calibration parameter.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ParameterRequireComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:INIT-VALUE-ASSIGNMENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ECUCDescriptionTemplate::ParameterValue -->
   <xsd:group name="PARAMETER-VALUE">
      <xsd:annotation>
         <xsd:documentation>Common class to all types of configuration values</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ParameterValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DEFINITION-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the definition of this ParameterValue subclasses in the ECU Configuration Parameter Definition.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ParameterValue.definition";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="-10"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:CONFIG-PARAMETER--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <xsd:simpleType name="PDU--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="DCM-I-PDU"/>
         <xsd:enumeration value="MULTIPLEXED-I-PDU"/>
         <xsd:enumeration value="N-PDU"/>
         <xsd:enumeration value="NM-PDU"/>
         <xsd:enumeration value="SIGNAL-I-PDU"/>
         <xsd:enumeration value="USER-DEFINED-I-PDU"/>
         <xsd:enumeration value="USER-DEFINED-PDU"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Fibex4Multiplatform::PduMappingDefaultValue -->
   <xsd:group name="PDU-MAPPING-DEFAULT-VALUE">
      <xsd:annotation>
         <xsd:documentation>Default Value which will be distributed if no I-Pdu has been received since last sending.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PduMappingDefaultValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DEFAULT-VALUE-ELEMENTS">
            <xsd:annotation>
               <xsd:documentation>The default value consists of a number of elements. Each default value element is represented by the element and the position in
            an array.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="defaultValueElement.PduMappingDefaultValue";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="DEFAULT-VALUE-ELEMENT" type="AR:DEFAULT-VALUE-ELEMENT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Fibex4Multiplatform::PduMappingDefaultValue -->
   <xsd:complexType abstract="false" mixed="false" name="PDU-MAPPING-DEFAULT-VALUE">
      <xsd:annotation>
         <xsd:documentation>Default Value which will be distributed if no I-Pdu has been received since last sending.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PduMappingDefaultValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:PDU-MAPPING-DEFAULT-VALUE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CoreCommunication::PduToFrameMapping -->
   <xsd:group name="PDU-TO-FRAME-MAPPING">
      <xsd:annotation>
         <xsd:documentation>A PduToFrameMapping defines the composition of Pdus in each frame. 

      Depending on its relation to entities such channels and clusters it can be unambiguously deduced whether a fan-out is handled by the Pdu router or the Bus Interface.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PduToFrameMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="PACKING-BYTE-ORDER" type="AR:BYTE-ORDER-ENUM">
            <xsd:annotation>
               <xsd:documentation>This attribute defines the order of the bytes of the Pdu and the packing into the Frame. The byte ordering "Little Endian" (MostSignificantByteLast) and "Big Endian" (MostSignificantByteFirst) can be selected.

            A mix between Little Endian and Big Endian within a Frame is not allowed (all PduToFrameMappings within a Frame must have the same packingByteOrder).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PduToFrameMapping.packingByteOrder";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PDU-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to a I-Pdu, N-Pdu or NmPdu that is transmitted in the Frame.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PduToFrameMapping.pdu";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PDU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="START-POSITION" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>This parameter is necessary to describe the byteposition of a Pdu within a Frame.

            Note that the absolute position of the Pdu in the Frame is determined by the definition of the packingByteOrder attribute. If Big Endian is specified, the start position indicates the bit position of the most significant bit in the Frame. If Little Endian is specified, the start position indicates the bit position of the least significant bit in the Frame.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PduToFrameMapping.startPosition";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="UPDATE-INDICATION-BIT-POSITION" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Indication to the receivers that the corresponding I-Pdu was updated by the sender. 
            This attribute describes the position of the update bit in the frame that aggregates this PDUToFrameMapping. Length is always one bit.

            The updateIndicationBitPosition is determined by the definition of the packingByteOrder attribute. If Big Endian is specified, the updateIndicationBitPosition indicates the bit position of the most significant bit in the Frame. If Little Endian is specified, the updateIndicationBitPosition indicates the bit position of the least significant bit in the Frame.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PduToFrameMapping.updateIndicationBitPosition";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::PduToFrameMapping -->
   <xsd:complexType abstract="false" mixed="false" name="PDU-TO-FRAME-MAPPING">
      <xsd:annotation>
         <xsd:documentation>A PduToFrameMapping defines the composition of Pdus in each frame. 

      Depending on its relation to entities such channels and clusters it can be unambiguously deduced whether a fan-out is handled by the Pdu router or the Bus Interface.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PduToFrameMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PDU-TO-FRAME-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class CoreCommunication::PdurIPduGroup -->
   <xsd:group name="PDUR-I-PDU-GROUP">
      <xsd:annotation>
         <xsd:documentation>The AUTOSAR PduR will enable and disable the sending of configurable groups of IPdus during runtime according to the AUTOSAR PduR specification.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PdurIPduGroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMMUNICATION-MODE" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>This attribute defines the use-case for this PduRIPduGroup. For example, in a diagnostic mode all IPdus - which are not involved in diagnostic - are disabled. The use cases are not limited to a fixed enumeration and can be specified as a string.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PdurIPduGroup.communicationMode";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="I-PDU-REFS">
            <xsd:annotation>
               <xsd:documentation>Reference to a set of IPdus, which are contained in the PduR I-Pdu Group.  If an IPdu is routed by the PduR to different destinations (PduR fan-out) than an PduTriggering for each destination is created in the System Template. To enable/disable a specific destination the PdurIPduGroup refers to the PduTriggering.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PdurIPduGroup.iPdu";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="I-PDU-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:I-PDU-TRIGGERING--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::PdurIPduGroup -->
   <xsd:complexType abstract="false" mixed="false" name="PDUR-I-PDU-GROUP">
      <xsd:annotation>
         <xsd:documentation>The AUTOSAR PduR will enable and disable the sending of configurable groups of IPdus during runtime according to the AUTOSAR PduR specification.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PdurIPduGroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PDUR-I-PDU-GROUP"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="PDUR-I-PDU-GROUP--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="PDUR-I-PDU-GROUP"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class PerInstanceMemory::PerInstanceMemory -->
   <xsd:group name="PER-INSTANCE-MEMORY">
      <xsd:annotation>
         <xsd:documentation>Defines a memory-block that needs to be available for each instance of the SW-component.  This is typically only useful if supportsMultipleInstantiation is TRUE of if the component defines NVRAM access via permanent blocks.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PerInstanceMemory"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TYPE" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>The "C"-type</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PerInstanceMemory.type";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TYPE-DEFINITION" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>A definition of the type</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PerInstanceMemory.typeDefinition";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class PerInstanceMemory::PerInstanceMemory -->
   <xsd:complexType abstract="false" mixed="false" name="PER-INSTANCE-MEMORY">
      <xsd:annotation>
         <xsd:documentation>Defines a memory-block that needs to be available for each instance of the SW-component.  This is typically only useful if supportsMultipleInstantiation is TRUE of if the component defines NVRAM access via permanent blocks.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PerInstanceMemory"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PER-INSTANCE-MEMORY"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="PER-INSTANCE-MEMORY--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="PER-INSTANCE-MEMORY"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class SwcImplementation::PerInstanceMemorySize -->
   <xsd:group name="PER-INSTANCE-MEMORY-SIZE">
      <xsd:annotation>
         <xsd:documentation>Resources needed by the allocation of PerInstanceMemory for each SWC instance. Note that these resources are not covered by an ObjectFileSection, because they are supposed to be allocated by the RTE.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PerInstanceMemorySize"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ALIGNMENT" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Required alignment (1,2,4,...) of the referenced PerInstanceMemory</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PerInstanceMemorySize.alignment";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PER-INSTANCE-MEMORY-REF">
            <xsd:annotation>
               <xsd:documentation>This represents that PerInstanceMemory to which the PerInstanceMemorySize refers to.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PerInstanceMemorySize.perInstanceMemory";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PER-INSTANCE-MEMORY--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SIZE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Size (in bytes) of the reference perInstanceMemory</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PerInstanceMemorySize.size";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SwcImplementation::PerInstanceMemorySize -->
   <xsd:complexType abstract="false" mixed="false" name="PER-INSTANCE-MEMORY-SIZE">
      <xsd:annotation>
         <xsd:documentation>Resources needed by the allocation of PerInstanceMemory for each SWC instance. Note that these resources are not covered by an ObjectFileSection, because they are supposed to be allocated by the RTE.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PerInstanceMemorySize"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:PER-INSTANCE-MEMORY-SIZE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Peripherals::Peripheral -->
   <xsd:group name="PERIPHERAL">
      <xsd:annotation>
         <xsd:documentation>General Element for all peripherals.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Peripheral"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CAN-BE-DISABLED" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Defines if the peripheral can be logically enabled or disabled.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Peripheral.canBeDisabled";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Peripherals::Peripheral -->
   <xsd:complexType abstract="false" mixed="false" name="PERIPHERAL">
      <xsd:annotation>
         <xsd:documentation>General Element for all peripherals.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Peripheral"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HW-ELEMENT"/>
         <xsd:group ref="AR:PERIPHERAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Peripherals::PeripheralHWPort -->
   <xsd:group name="PERIPHERAL-HW-PORT">
      <xsd:annotation>
         <xsd:documentation>This port is directed from the peripheral to the ecu electronics and communication.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PeripheralHWPort"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BUFFERS">
            <xsd:annotation>
               <xsd:documentation>Defines the number of elements that can be stored in an input or output buffer. A capture timer can for example have several registers to store the timer value when an external event has occurred.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="buffer.PeripheralHWPort";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="BUFFER" type="AR:BUFFER"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INVERSION" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>An input or output can sometimes be programmed to invert the level of a signal.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PeripheralHWPort.inversion";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="POWER-ON-CAPABILITY" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>The peripheral device has the feature to issue a Power On event to the ECU.
            Example: Some CAN bus transceivers have a dedicated low power voltage regulator and a feature, which allows to turn on the main voltage regulator of the ECU by detecting a bus activity.
            Example: A wired-or connection of a termination KL30 and KL15 can fulfil this requirement.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PeripheralHWPort.powerOnCapability";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="WAKE-UP-CAPABILITY" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>The peripheral device has the feature to issue a wake-up event to the processing unit.
            Example: HW Port with Key-Wake-Up on a PU is still active while the PU is in stop mode and only partially supplied with power. The Key-Wake-Up reacts on any changes at the input of the HW Port with the activation of the power supply, the activation of the clock system and later the resuming of the software, which has to process the input of the HW Port.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PeripheralHWPort.wakeUpCapability";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Peripherals::PeripheralHWPort -->
   <xsd:complexType abstract="false" mixed="false" name="PERIPHERAL-HW-PORT">
      <xsd:annotation>
         <xsd:documentation>This port is directed from the peripheral to the ecu electronics and communication.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PeripheralHWPort"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HW-PORT"/>
         <xsd:group ref="AR:PERIPHERAL-HW-PORT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class SignalPaths::PermissibleSignalPath -->
   <xsd:group name="PERMISSIBLE-SIGNAL-PATH">
      <xsd:annotation>
         <xsd:documentation>The PermissibleSignalPath describes the way a data element shall take in the topology. The path is described by ordered references to PhysicalChannels. 

      If more than one PermissibleSignalPath is defined for the same
      signal/operation attributes, any of them can be chosen. Such a signal path can be a constraint for the communication matrix . This path describes that one data element should take path A (e.g. 1. Can channel, 2. Lin channel) 
      and not path B (1. Can channel, FlexRay channel A). 

      This has an effect on the frame generation and the frame path.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PermissibleSignalPath"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="OPERATIONS">
            <xsd:annotation>
               <xsd:documentation>The arguments of an operation that can take the predefined way in the topology.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="operation.PermissibleSignalPath";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SWC-TO-SWC-OPERATION-ARGUMENTS" type="AR:SWC-TO-SWC-OPERATION-ARGUMENTS"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PHYSICAL-CHANNEL-REFS">
            <xsd:annotation>
               <xsd:documentation>The SwcToSwcSignal can be transmitted on one of these physical channels.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PermissibleSignalPath.physicalChannel";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="PHYSICAL-CHANNEL-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:PHYSICAL-CHANNEL--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SIGNALS">
            <xsd:annotation>
               <xsd:documentation>The data element which can take the predefined way in the topology.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="signal.PermissibleSignalPath";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SWC-TO-SWC-SIGNAL" type="AR:SWC-TO-SWC-SIGNAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SignalPaths::PermissibleSignalPath -->
   <xsd:complexType abstract="false" mixed="false" name="PERMISSIBLE-SIGNAL-PATH">
      <xsd:annotation>
         <xsd:documentation>The PermissibleSignalPath describes the way a data element shall take in the topology. The path is described by ordered references to PhysicalChannels. 

      If more than one PermissibleSignalPath is defined for the same
      signal/operation attributes, any of them can be chosen. Such a signal path can be a constraint for the communication matrix . This path describes that one data element should take path A (e.g. 1. Can channel, 2. Lin channel) 
      and not path B (1. Can channel, FlexRay channel A). 

      This has an effect on the frame generation and the frame path.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PermissibleSignalPath"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:PERMISSIBLE-SIGNAL-PATH"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class GlobalConstraints::PhysConstrs -->
   <xsd:group name="PHYS-CONSTRS">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PhysConstrs"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="LOWER-LIMIT" type="AR:LIMIT">
            <xsd:annotation>
               <xsd:documentation>This element specifies the lower limit of a closed, half-open or open interval. It can also be set to infinity by setting the attribute INTERVAL-TYPE to INFINITE. No value has to be set in the case of an infinite interval.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PhysConstrs.lowerLimit";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="UPPER-LIMIT" type="AR:LIMIT">
            <xsd:annotation>
               <xsd:documentation>This element specifies the upper limit of a closed, half-open or open interval. It can also be set to infinity by setting the attribute INTERVAL-TYPE to INFINITE. No value has to be set in the case of an infinite interval.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PhysConstrs.upperLimit";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SCALE-CONSTRS">
            <xsd:annotation>
               <xsd:documentation>This is one particular scale in which contributes to the data constraints.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PhysConstrs.scaleConstr";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="true";xml.roleWrapperElement="true";xml.sequenceOffset="40";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SCALE-CONSTR" type="AR:SCALE-CONSTR"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-GRADIENT" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>This element specifies the maximum slope that may be used in maps and curves.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PhysConstrs.maxGradient";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-DIFF" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Maximum difference that is permitted between two consecutive values if the constraint is applied to an axis.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PhysConstrs.maxDiff";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="60"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MONOTONY" type="AR:MONOTONY-ENUM">
            <xsd:annotation>
               <xsd:documentation>This specifies the monotony constraints on the data object. Note that this applies only to curves and maps.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PhysConstrs.monotony";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="70"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="UNIT-REF">
            <xsd:annotation>
               <xsd:documentation>Use &lt;unit&gt; to enter the unit of a parameter.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PhysConstrs.unit";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="80"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:UNIT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class GlobalConstraints::PhysConstrs -->
   <xsd:complexType abstract="false" mixed="false" name="PHYS-CONSTRS">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PhysConstrs"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:PHYS-CONSTRS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CoreTopology::PhysicalChannel -->
   <xsd:group name="PHYSICAL-CHANNEL">
      <xsd:annotation>
         <xsd:documentation>A physical channel is the transmission medium that is used to send and receive information between two communicating ECUs. Each CommunicationCluster has at least one physical channel. Bus systems like CAN and LIN only have exactly one PhysicalChannel. A FlexRay cluster may have more than one PhysicalChannels that may be used in parallel for redundant communication.

      An ECU is part of a cluster if it contains at least one controller that is connected to at least one channel of the cluster.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PhysicalChannel"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="FRAME-TRIGGERINGSS">
            <xsd:annotation>
               <xsd:documentation>One frame triggering is defined for exactly one channel. Channels may have assigned an arbitrary number of frame triggerings.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="frameTriggerings.PhysicalChannel";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CAN-FRAME-TRIGGERING" type="AR:CAN-FRAME-TRIGGERING"/>
                  <xsd:element name="FLEXRAY-FRAME-TRIGGERING" type="AR:FLEXRAY-FRAME-TRIGGERING"/>
                  <xsd:element name="LIN-FRAME-TRIGGERING" type="AR:LIN-FRAME-TRIGGERING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="I-PDU-TRIGGERINGS">
            <xsd:annotation>
               <xsd:documentation>One I-Pdu triggering is defined for exactly one channel. Channels may have assigned an arbitrary number of I-Pdu triggerings.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="iPduTriggering.PhysicalChannel";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="I-PDU-TRIGGERING" type="AR:I-PDU-TRIGGERING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="I-SIGNAL-TRIGGERINGS">
            <xsd:annotation>
               <xsd:documentation>One ISignalTriggering is defined for exactly one channel. Channels may have assigned an arbitrary number of ISignaltriggerings.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="iSignalTriggering.PhysicalChannel";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">atpSplitable</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="I-SIGNAL-TRIGGERING" type="AR:I-SIGNAL-TRIGGERING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TP-ADDRESSS">
            <xsd:annotation>
               <xsd:documentation>Collection of TpAddresses.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="tpAddress.PhysicalChannel";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="TP-ADDRESS" type="AR:TP-ADDRESS"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TP-CHANNELS">
            <xsd:annotation>
               <xsd:documentation>Optional configuration of  Tranport Protocol channels.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="tpChannel.PhysicalChannel";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CAN-TP-CONNECTION-CHANNEL" type="AR:CAN-TP-CONNECTION-CHANNEL"/>
                  <xsd:element name="FLEXRAY-ISO-TP-CONNECTION" type="AR:FLEXRAY-ISO-TP-CONNECTION"/>
                  <xsd:element name="FLEXRAY-TP-CHANNEL" type="AR:FLEXRAY-TP-CHANNEL"/>
                  <xsd:element name="LIN-TP-CHANNEL" type="AR:LIN-TP-CHANNEL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TP-NODES">
            <xsd:annotation>
               <xsd:documentation>Senders and receivers of  TP messages.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="tpNode.PhysicalChannel";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CAN-TP-NODE" type="AR:CAN-TP-NODE"/>
                  <xsd:element name="FLEXRAY-ISO-TP-NODE" type="AR:FLEXRAY-ISO-TP-NODE"/>
                  <xsd:element name="FLEXRAY-TP-NODE" type="AR:FLEXRAY-TP-NODE"/>
                  <xsd:element name="LIN-TP-NODE" type="AR:LIN-TP-NODE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreTopology::PhysicalChannel -->
   <xsd:complexType abstract="false" mixed="false" name="PHYSICAL-CHANNEL">
      <xsd:annotation>
         <xsd:documentation>A physical channel is the transmission medium that is used to send and receive information between two communicating ECUs. Each CommunicationCluster has at least one physical channel. Bus systems like CAN and LIN only have exactly one PhysicalChannel. A FlexRay cluster may have more than one PhysicalChannels that may be used in parallel for redundant communication.

      An ECU is part of a cluster if it contains at least one controller that is connected to at least one channel of the cluster.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PhysicalChannel"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PHYSICAL-CHANNEL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="PHYSICAL-CHANNEL--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="FLEXRAY-PHYSICAL-CHANNEL"/>
         <xsd:enumeration value="PHYSICAL-CHANNEL"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Units::PhysicalDimension -->
   <xsd:group name="PHYSICAL-DIMENSION">
      <xsd:annotation>
         <xsd:documentation>This class represents a physical dimension.
      If the physical dimension of two units is identical a conversion between them is possible. The conversion between units is related to the definition of the physical dimension.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PhysicalDimension"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="LENGTH-EXP" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The exponent of the physical dimension "length"</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PhysicalDimension.lengthExp";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MASS-EXP" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The exponent of the physical dimension "mass"</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PhysicalDimension.massExp";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIME-EXP" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The exponent of the physical dimension "time"</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PhysicalDimension.timeExp";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CURRENT-EXP" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>the exponent of the physical dimension "electric current"</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PhysicalDimension.currentExp";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TEMPERATURE-EXP" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The exponent of the physical dimension "temperature"</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PhysicalDimension.temperatureExp";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="60"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MOLAR-AMOUNT-EXP" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The exponent of the physical dimension "quantity of substance"</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PhysicalDimension.molarAmountExp";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="70"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="LUMINOUS-INTENSITY-EXP" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The exponent of the physical dimension "luminous intensity"</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PhysicalDimension.luminousIntensityExp";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="80"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Units::PhysicalDimension -->
   <xsd:complexType abstract="false" mixed="false" name="PHYSICAL-DIMENSION">
      <xsd:annotation>
         <xsd:documentation>This class represents a physical dimension.
      If the physical dimension of two units is identical a conversion between them is possible. The conversion between units is related to the definition of the physical dimension.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PhysicalDimension"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PHYSICAL-DIMENSION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="PHYSICAL-DIMENSION--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="PHYSICAL-DIMENSION"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ECUResourceTemplate::PinHWConnection -->
   <xsd:group name="PIN-HW-CONNECTION">
      <xsd:annotation>
         <xsd:documentation>Is used to connect the HWPins of the HWPorts that are referenced by the HWConnection.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PinHWConnection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONNECTED-PIN-REFS">
            <xsd:annotation>
               <xsd:documentation>Reference to the connected pin.
            When the PinHWConnection is used in the context of a DelegationHWConnection there might be only ONE pin known (typically this is a pin of the OUTER-PORT), so only one pin has to be specified.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PinHWConnection.connectedPin";pureMM.maxOccurs="2";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="2" minOccurs="0">
                  <xsd:element name="CONNECTED-PIN-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:HW-PIN--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUResourceTemplate::PinHWConnection -->
   <xsd:complexType abstract="false" mixed="false" name="PIN-HW-CONNECTION">
      <xsd:annotation>
         <xsd:documentation>Is used to connect the HWPins of the HWPorts that are referenced by the HWConnection.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PinHWConnection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:PIN-HW-CONNECTION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class SWmapping::PncMapping -->
   <xsd:group name="PNC-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Describes a mapping between one or several Virtual Function Clusters onto Partial Network Clusters. A Virtual Function Cluster is realized by a PortGroup. A Partial Network Cluster is realized by one or more IPduGroups.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PncMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="PNC-GROUP-REFS">
            <xsd:annotation>
               <xsd:documentation>IPduGroup participating in a Partial Network Cluster. This reference is optional in case an ecu extract has only indirect pnc access, i.e. ecu is not directly conntected to a network which supports partial network.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PncMapping.pncGroup";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="PNC-GROUP-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:I-PDU-GROUP--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PNC-IDENTIFIER" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Identifer of the Partial Network Cluster.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PncMapping.pncIdentifier";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VFC-IREFS">
            <xsd:annotation>
               <xsd:documentation>Virtual Function Cluster to be mapped onto a Partial Network Cluster. This reference is optional in case that the System Description doesn't use a complete Software Component Description (VFB View). This supports the inclusion of legacy systems.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="vfc.PncMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="VFC-IREF" type="AR:PNC-MAPPING--VFC-IREF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="WAKEUP-FRAME-REFS">
            <xsd:annotation>
               <xsd:documentation>Reference to collection of FrameTriggerings that are used for the wakeup of this PNC (Application Frames or Nm Frames can be used). This reference is optional in case an ecu extract has only indirect pnc access, i.e. ecu is not directly conntected to a network which supports partial network.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PncMapping.wakeupFrame";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="WAKEUP-FRAME-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:FRAME-TRIGGERING--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SWmapping::PncMapping -->
   <xsd:complexType abstract="false" mixed="false" name="PNC-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Describes a mapping between one or several Virtual Function Clusters onto Partial Network Clusters. A Virtual Function Cluster is realized by a PortGroup. A Partial Network Cluster is realized by one or more IPduGroups.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PncMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PNC-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class _instanceRef::PncMapping_vfc -->
   <xsd:group name="PNC-MAPPING--VFC-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PncMapping_vfc"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SOFTWARE-COMPOSITION-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PncMapping_vfc.softwareComposition";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="10"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SOFTWARE-COMPOSITION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="COMPONENT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PncMapping_vfc.componentPrototype";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMPONENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="1" name="VFC-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PncMapping_vfc.vfc";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.target</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-GROUP--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class _instanceRef::PncMapping_vfc -->
   <xsd:complexType abstract="false" mixed="false" name="PNC-MAPPING--VFC-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PncMapping_vfc"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:PNC-MAPPING--VFC-IREF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class PortAPIOptions::PortAPIOption -->
   <xsd:group name="PORT-API-OPTION">
      <xsd:annotation>
         <xsd:documentation>Options how to generate the signatures of calls for an AtomicSoftwareComponentType in order to communicate over a PortPrototype (for calls into a RunnableEntity as well as for calls from a RunnableEntity to the PortPrototype).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PortAPIOption"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ENABLE-TAKE-ADDRESS" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>If set to true, the software-component is able to use the API reference for deriving a pointer to an object.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PortAPIOption.enableTakeAddress";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INDIRECT-API" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>true: Specifies an "indirect API" to be generated for the associated port, which means that the SWC is able to access the actions on a port via a pointer to an object representing a port. This allows e.g. iterating over ports in a loop. This option has no effect for PPorts of client/server interfaces.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PortAPIOption.indirectAPI";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PORT-ARG-VALUES">
            <xsd:annotation>
               <xsd:documentation>A "port defined argument values" is passed to a runnable dealing with the operations provided by a given port. Restricted to PPorts of a client/server interface.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="portArgValue.PortAPIOption";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="BOOLEAN-LITERAL" type="AR:BOOLEAN-LITERAL"/>
                  <xsd:element name="CHAR-LITERAL" type="AR:CHAR-LITERAL"/>
                  <xsd:element name="INTEGER-LITERAL" type="AR:INTEGER-LITERAL"/>
                  <xsd:element name="OPAQUE-LITERAL" type="AR:OPAQUE-LITERAL"/>
                  <xsd:element name="REAL-LITERAL" type="AR:REAL-LITERAL"/>
                  <xsd:element name="STRING-LITERAL" type="AR:STRING-LITERAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PORT-REF">
            <xsd:annotation>
               <xsd:documentation>the option is valid for generated functions related to communication over this port</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PortAPIOption.port";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class PortAPIOptions::PortAPIOption -->
   <xsd:complexType abstract="false" mixed="false" name="PORT-API-OPTION">
      <xsd:annotation>
         <xsd:documentation>Options how to generate the signatures of calls for an AtomicSoftwareComponentType in order to communicate over a PortPrototype (for calls into a RunnableEntity as well as for calls from a RunnableEntity to the PortPrototype).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PortAPIOption"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:PORT-API-OPTION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Components::PortGroup -->
   <xsd:group name="PORT-GROUP">
      <xsd:annotation>
         <xsd:documentation>Group of ports which share a common functionality, e.g. need specific network resources. This information shall be available on the VFB level in order to delegate it properly via compositions. When propagated into the ECU extract, this information is used as input for the configuration of Services like the Communication Manager. A PortGroup is defined locally in a component (which can be a composition) and refers to the "outer" ports belonging to the group as well as to the "inner" groups which propagate this group into the components which are part of a composition. A PortGroup within an atomic SWC cannot be linked to inner groups.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PortGroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpStructureElement</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="INNER-GROUP-IREFS">
            <xsd:annotation>
               <xsd:documentation>Links a PortGroup in a composition to another PortGroup, that is defined in a component which is part of this CompositionType.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="innerGroup.PortGroup";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="INNER-GROUP-IREF" type="AR:PORT-GROUP--INNER-GROUP-IREF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="OUTER-PORT-REFS">
            <xsd:annotation>
               <xsd:documentation>Outer port of this component which belongs to the group. A port can belong to several groups or to no group at all.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PortGroup.outerPort";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="OUTER-PORT-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Components::PortGroup -->
   <xsd:complexType abstract="false" mixed="false" name="PORT-GROUP">
      <xsd:annotation>
         <xsd:documentation>Group of ports which share a common functionality, e.g. need specific network resources. This information shall be available on the VFB level in order to delegate it properly via compositions. When propagated into the ECU extract, this information is used as input for the configuration of Services like the Communication Manager. A PortGroup is defined locally in a component (which can be a composition) and refers to the "outer" ports belonging to the group as well as to the "inner" groups which propagate this group into the components which are part of a composition. A PortGroup within an atomic SWC cannot be linked to inner groups.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PortGroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpStructureElement</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PORT-GROUP"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="PORT-GROUP--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="PORT-GROUP"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class _instanceRef::PortGroup_innerGroup -->
   <xsd:group name="PORT-GROUP--INNER-GROUP-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PortGroup_innerGroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="COMPONENT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PortGroup_innerGroup.componentPrototype";pureMM.maxOccurs="-1";pureMM.minOccurs="1";xml.sequenceOffset="10"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMPONENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="1" name="PORT-GROUP-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PortGroup_innerGroup.portGroup";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.target</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-GROUP--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class _instanceRef::PortGroup_innerGroup -->
   <xsd:complexType abstract="false" mixed="false" name="PORT-GROUP--INNER-GROUP-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PortGroup_innerGroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:PORT-GROUP--INNER-GROUP-IREF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class PortInterface::PortInterface -->
   <xsd:group name="PORT-INTERFACE">
      <xsd:annotation>
         <xsd:documentation>Abstract base class for an interface that is either provided or required by a port of a  software component.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PortInterface"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpType</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="IS-SERVICE" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>This flag is set, if the PortInterface is to be used for communication between an ApplicationSoftwareComponentType and a ServiceComponentType (namely an AUTOSAR Service, ECU abstraction or Complex Driver) located on the same ECU. Otherwise the flag is not set.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PortInterface.isService";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <xsd:simpleType name="PORT-INTERFACE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CALPRM-INTERFACE"/>
         <xsd:enumeration value="CLIENT-SERVER-INTERFACE"/>
         <xsd:enumeration value="SENDER-RECEIVER-INTERFACE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Components::PortPrototype -->
   <xsd:group name="PORT-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>Base class for the ports of an AUTOSAR software component.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PortPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CALIBRATION-PORT-ANNOTATIONS">
            <xsd:annotation>
               <xsd:documentation>Annotations on this CalibrationPort.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="calibrationPortAnnotation.PortPrototype";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CALIBRATION-PORT-ANNOTATION" type="AR:CALIBRATION-PORT-ANNOTATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DELEGATED-PORT-ANNOTATION" type="AR:DELEGATED-PORT-ANNOTATION">
            <xsd:annotation>
               <xsd:documentation>Annotations on this delegated port.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="delegatedPortAnnotation.PortPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="IO-HW-ABSTRACTION-SERVER-ANNOTATIONS">
            <xsd:annotation>
               <xsd:documentation>Annotations on this IoHwAbstraction port.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ioHwAbstractionServerAnnotation.PortPrototype";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="IO-HW-ABSTRACTION-SERVER-ANNOTATION" type="AR:IO-HW-ABSTRACTION-SERVER-ANNOTATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SENDER-RECEIVER-ANNOTATIONS">
            <xsd:annotation>
               <xsd:documentation>Collection of annotations of this ports sender/receiver communication.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="senderReceiverAnnotation.PortPrototype";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="RECEIVER-ANNOTATION" type="AR:RECEIVER-ANNOTATION"/>
                  <xsd:element name="SENDER-ANNOTATION" type="AR:SENDER-ANNOTATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <xsd:simpleType name="PORT-PROTOTYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="P-PORT-PROTOTYPE"/>
         <xsd:enumeration value="R-PORT-PROTOTYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ECUElectronics::PowerDriverHWElement -->
   <xsd:group name="POWER-DRIVER-HW-ELEMENT">
      <xsd:annotation>
         <xsd:documentation>Power Driver HW Element describes a group of electronic devices, which perform signal transformations with hardware devices. The main focus of the ECU Resource Template is the logical description of these elements, necessary for the system generation and relevant for the SW development.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PowerDriverHWElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CURRENT-LIMITATION" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>The device limits the maximum current conduction. The limit has to be specified. If this element does not occur the HW Element does not provide current limitation.
            Unit: Ampere</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PowerDriverHWElement.currentLimitation";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DEFAULT-RESET-BEHAVIUOR" type="AR:HW-ELEMENT-DEFAULT-RESET-BEHAVIOR-ENUM">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PowerDriverHWElement.defaultResetBehaviuor";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NOTIFICATION" type="AR:POWER-DRIVER-NOTIFICATION">
            <xsd:annotation>
               <xsd:documentation>Which kind of notification to the PU is available.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="notification.PowerDriverHWElement";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ON-STATE-RESISTANCE" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>The resistance in ON state can be used together with the current through this element to determine the static thermal power dissipation of the element itself and the ECU completely by summing up each element with power dissipation.
            As the heating up of an power element follows with an exponential delay, the ratio of on and off times is later needed in the system generation process.
            This information can give the first hint on critical issues of thermal design, but does not replace a complete static and dynamic verification of the thermal layout.
            Unit: Ohm</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PowerDriverHWElement.onStateResistance";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="POWER-DRIVER-TYPE" type="AR:HW-ELEMENT-POWER-DRIVER-TYPE-ENUM">
            <xsd:annotation>
               <xsd:documentation>Defines the general type of the element. Type is a most common naming for an element. Several sets of types exist. Type is mandatory for the usage of the ECU Resource Template.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PowerDriverHWElement.powerDriverType";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PROTECTION" type="AR:POWER-DRIVER-PROTECTION">
            <xsd:annotation>
               <xsd:documentation>Which kind of protection is available.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="protection.PowerDriverHWElement";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RESET-ON-FAULT-BEHAVIOUR" type="AR:HW-ELEMENT-RESET-ON-FAULT-BEHAVIOUR-ENUM">
            <xsd:annotation>
               <xsd:documentation>Describe the way the element is reactivated after a self protection sequence was entered</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PowerDriverHWElement.resetOnFaultBehaviour";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUElectronics::PowerDriverHWElement -->
   <xsd:complexType abstract="false" mixed="false" name="POWER-DRIVER-HW-ELEMENT">
      <xsd:annotation>
         <xsd:documentation>Power Driver HW Element describes a group of electronic devices, which perform signal transformations with hardware devices. The main focus of the ECU Resource Template is the logical description of these elements, necessary for the system generation and relevant for the SW development.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PowerDriverHWElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HW-ELEMENT"/>
         <xsd:group ref="AR:ECU-ELECTRONICS"/>
         <xsd:group ref="AR:POWER-DRIVER-HW-ELEMENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUElectronics::PowerDriverHWPort -->
   <xsd:group name="POWER-DRIVER-HW-PORT">
      <xsd:annotation>
         <xsd:documentation>Define the option of a Power Driver that the output of a Power Driver can be superposed by a PWM signal asserted by a HW Element e.g. a microprocessor. 
      In most cases, the PWM signal is connected by a separate wire, even when the general control information are transmitted by a bus.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PowerDriverHWPort"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="PWM-MAX-FREQUENCY" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>It defines the upper limit at which the device can fulfil the PWM capability.
            EMC and power dissipation are increasing almost exponential with the PWM frequency. Choosing PWM frequencies be aware that some effects can cause secondary effects, which can create a audible noise for the user, e.g. a PWM dimmed lamp can be noticed by the driver.
            Unit: Hz</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PowerDriverHWPort.pwmMaxFrequency";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PWM-MIN-OFF-TIME" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Defines the characteristic, that a Power Driver has to be off at least a minimum time in order to assure the function.
            Unit: s</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PowerDriverHWPort.pwmMinOffTime";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PWM-MIN-ON-TIME" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Defines the characteristic, that a Power Driver has to be on at least a minimum time in order to assure the function.
            Unit: s</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PowerDriverHWPort.pwmMinOnTime";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUElectronics::PowerDriverHWPort -->
   <xsd:complexType abstract="false" mixed="false" name="POWER-DRIVER-HW-PORT">
      <xsd:annotation>
         <xsd:documentation>Define the option of a Power Driver that the output of a Power Driver can be superposed by a PWM signal asserted by a HW Element e.g. a microprocessor. 
      In most cases, the PWM signal is connected by a separate wire, even when the general control information are transmitted by a bus.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PowerDriverHWPort"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HW-PORT"/>
         <xsd:group ref="AR:POWER-DRIVER-HW-PORT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUElectronics::PowerDriverNotification -->
   <xsd:group name="POWER-DRIVER-NOTIFICATION">
      <xsd:annotation>
         <xsd:documentation>Describe the status which cause a notification to the controlling devices of an ECU, e.g. to the PU.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PowerDriverNotification"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ISSUED-INTERRUPT-SOURCE-REF">
            <xsd:annotation>
               <xsd:documentation>If a notification is issued, in which Interrupt will it result.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PowerDriverNotification.issuedInterruptSource";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:INTERRUPT-PRODUCE-HW-PORT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="LOSS-OF-GROUND" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>The device detected a loss of ground situation. The device was forced off, in order to avoid damages by excessive currents.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PowerDriverNotification.lossOfGround";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-CURRENT" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>The device detected a too high current.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PowerDriverNotification.maxCurrent";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-VOLTAGE" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>The device detected a too high supply voltage.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PowerDriverNotification.maxVoltage";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MIN-CURRENT" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>The device detected a too low curent.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PowerDriverNotification.minCurrent";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MIN-VOLTAGE" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>The device detected a too low supply voltage.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PowerDriverNotification.minVoltage";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="OPEN-LOAD" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>The device detected open loads. This situation is reported to the controlling portion of an ECU, e.g. to the PU.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PowerDriverNotification.openLoad";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="OVER-TEMPERATURE" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>The maximum allowed temperature was detected in the device. A protecting hardware has forced the device off.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PowerDriverNotification.overTemperature";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SHORT-LOAD" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>The device was forced off, in order to avoid damages by excessive currents.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PowerDriverNotification.shortLoad";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SHORT-TO-BATT" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>The device detected a short to battery situation. The device was forced off, in order to avoid damages by excessive currents.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PowerDriverNotification.shortToBatt";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SHORT-TO-GROUND" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>The device detected a short to ground situation. The device was forced off, in order to avoid damages by excessive currents.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PowerDriverNotification.shortToGround";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUElectronics::PowerDriverNotification -->
   <xsd:complexType abstract="false" mixed="false" name="POWER-DRIVER-NOTIFICATION">
      <xsd:annotation>
         <xsd:documentation>Describe the status which cause a notification to the controlling devices of an ECU, e.g. to the PU.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PowerDriverNotification"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:POWER-DRIVER-NOTIFICATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ECUElectronics::PowerDriverProtection -->
   <xsd:group name="POWER-DRIVER-PROTECTION">
      <xsd:annotation>
         <xsd:documentation>The Power Driver HW Element / ASIC turns off by internal means in order to protect the device against severe damages.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PowerDriverProtection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="LOSS-OF-GROUND-PROTECTION" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Is protected against loss of ground.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PowerDriverProtection.lossOfGroundProtection";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-CURRENT-PROTECTION" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Maximal current limits are exceeded.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PowerDriverProtection.maxCurrentProtection";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-VOLTAGE-PROTECTION" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Maximal voltage limits are exceeded.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PowerDriverProtection.maxVoltageProtection";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MIN-CURRENT-PROTECTION" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Minimal current limits are exceeded.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PowerDriverProtection.minCurrentProtection";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MIN-VOLTAGE-PROTECTION" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Minimal voltage limits are exceeded.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PowerDriverProtection.minVoltageProtection";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="OVER-TEMPERATURE-PROTECTION" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Is protected against over-temperature.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PowerDriverProtection.overTemperatureProtection";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REVERSE-BATTERY-PROTECTION" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Is protected against reverse battery voltage.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PowerDriverProtection.reverseBatteryProtection";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUElectronics::PowerDriverProtection -->
   <xsd:complexType abstract="false" mixed="false" name="POWER-DRIVER-PROTECTION">
      <xsd:annotation>
         <xsd:documentation>The Power Driver HW Element / ASIC turns off by internal means in order to protect the device against severe damages.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PowerDriverProtection"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:POWER-DRIVER-PROTECTION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ECUElectronics::PowerSupplyCurrentNotification -->
   <xsd:group name="POWER-SUPPLY-CURRENT-NOTIFICATION">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PowerSupplyCurrentNotification"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="HYSTERESIS" type="xsd:double">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PowerSupplyCurrentNotification.hysteresis";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INTERRUPT-REFS">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PowerSupplyCurrentNotification.interrupt";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="INTERRUPT-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:INTERRUPT-PRODUCE-HW-PORT--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="LEVEL" type="xsd:double">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PowerSupplyCurrentNotification.level";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUElectronics::PowerSupplyCurrentNotification -->
   <xsd:complexType abstract="false" mixed="false" name="POWER-SUPPLY-CURRENT-NOTIFICATION">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PowerSupplyCurrentNotification"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:POWER-SUPPLY-CURRENT-NOTIFICATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ECUElectronics::PowerSupplyHWElement -->
   <xsd:group name="POWER-SUPPLY-HW-ELEMENT">
      <xsd:annotation>
         <xsd:documentation>The Power Supply HW Element provides information about the power source of the ECU. There can be multiple power supplies within one ECU.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PowerSupplyHWElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BACKUP-CAPACITY" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Define the capability assigned to the output of the Power Supply HW Element to maintain the output voltage stable for a certain time after the undervoltage status information is asserted.
            In the ECU Resource Template the Backup Capacity is described as time. The time is dependent from the current consumed by the HW Elements connected to the according output, the SW-functions controlling the ECU hardware and the implementation of the Power Supply HW Element itself. The time has to be calculated from the available capacitors or measured in the application.
            Example: For the energy storage for airbag applications capacitors stores energy for the airbag ignition for several seconds even the battery is completely disconnected.
            Example: A combined step up/step down DC/DC converter can deliver a stable 5V volt output even when the input has already dropped to 3V. The undervoltage status is already set at a Vbatt level of 6V.
            Unit: Ah</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PowerSupplyHWElement.backupCapacity";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DEFAULT-VOLTAGE-ON-RESET" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>This value defines the nominal output voltage, which is supplied as default after a reset occured. This attribute is only applicable at power supplies with a programmable output voltage.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PowerSupplyHWElement.defaultVoltageOnReset";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-VOLTAGE" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>The maximum voltage that can be supplied.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PowerSupplyHWElement.maxVoltage";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MIN-VOLTAGE" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>The minimum voltage that can be supplied.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PowerSupplyHWElement.minVoltage";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NOTIFICATION-OVER-TEMPERATURE" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Status information that the on-chip temperature on the Power Supply Hardware Element exceed the maximal, defined limit.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PowerSupplyHWElement.notificationOverTemperature";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NOTIFICATION-RESET" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>The power on reset is generated depending on the output voltage. Valid operation of the ECU and the connected HW Elements are only possible if the output voltage is stable and within the specified output voltage range. Therefore most of the Power Supply HW Elements contain a circuitry, which generate a output signal which indicates an instable or unspecified voltage at the output. Some Power Supply HW Elements offer the possibility to adjust the reset thresholds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PowerSupplyHWElement.notificationReset";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="OVER-CURRENT-NOTIFICATION" type="AR:POWER-SUPPLY-CURRENT-NOTIFICATION">
            <xsd:annotation>
               <xsd:documentation>Status information that the output current exceeds the maximal, defined limit at the output of the Power Supply HW Element. A short circuit indication is a special form of the overcurrent status information.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="overCurrentNotification.PowerSupplyHWElement";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="OVER-VOLTAGE-NOTIFICATION" type="AR:POWER-SUPPLY-VOLTAGE-NOTIFICATION">
            <xsd:annotation>
               <xsd:documentation>Notification that the source voltage is too high for the power Supply HW Element to handle.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="overVoltageNotification.PowerSupplyHWElement";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RESET-DELAY" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>The reset signal at the power-on reset is delayed by the Power Supply HW Element in order to enable the different ECU HW Elements to enter a stable and defined operation state when the reset signal is released.
            Unit: s</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PowerSupplyHWElement.resetDelay";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RESET-ON-FAULT-BEHAVIOUR" type="AR:HW-ELEMENT-RESET-ON-FAULT-BEHAVIOUR-ENUM">
            <xsd:annotation>
               <xsd:documentation>Describe the way the element is reactivated after a self protection sequence was entered</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PowerSupplyHWElement.resetOnFaultBehaviour";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="UNDER-VOLTAGE-NOTIFICATION" type="AR:POWER-SUPPLY-VOLTAGE-NOTIFICATION">
            <xsd:annotation>
               <xsd:documentation>Status information that at the input of the Power Supply HW Element has dropped to a critical value.
            This can be used to switch off functions, which caused that voltage drop or start a power down function like storing important data to NV memory.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="underVoltageNotification.PowerSupplyHWElement";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="WAKEUP-CAPABILITY" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Describes the feature of the power supply to turn on the output voltage by an external event. In some cases this feature is coupled with other ECU internal HW elements e.g. transceivers and is the main feature used by the car specific power management. Different to other HW elements with this feature the power supply is the receiver of the signal, as more ECU function is only possible if the power supply is activated. Example: Philips CAN Transceivers have an output called INH, which allow together with some Voltage regulators with wake up capability to wake up the ECU at the presence of a CAN bus telegram. 
            Example: The Wake up Capability is connected to the terminal KL15 (ignition), the ECU is waked up at the presence of KL15.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PowerSupplyHWElement.wakeupCapability";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUElectronics::PowerSupplyHWElement -->
   <xsd:complexType abstract="false" mixed="false" name="POWER-SUPPLY-HW-ELEMENT">
      <xsd:annotation>
         <xsd:documentation>The Power Supply HW Element provides information about the power source of the ECU. There can be multiple power supplies within one ECU.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PowerSupplyHWElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HW-ELEMENT"/>
         <xsd:group ref="AR:ECU-ELECTRONICS"/>
         <xsd:group ref="AR:POWER-SUPPLY-HW-ELEMENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUElectronics::PowerSupplyHWPort -->
   <xsd:group name="POWER-SUPPLY-HW-PORT">
      <xsd:annotation>
         <xsd:documentation>The Power Supply HW Port is used to model the power distribution within the ECU. If the direction is "in" the port is used to describe the power consumption of an HW Element. If the direction is "out" the port is used to describe a power source. The HW Connection between these two HW Ports can only be established between the Power Supply HW Port of the HW Element with direction "out" and a Power Supply HW Port of the Power Supply HW Element with direction "in".</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PowerSupplyHWPort"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CAN-BE-SWITCHED-OFF" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Defines if the Power Supply HW Port can be switched off and therefore the supplied HW Element is switched off as well. This feature allows to describe which parts of an ECU are able be disconnected from their power supply based on software interaction. 
            If the Power Supply HW Port has the direction 'in' the supplied HW Element can be switched off. 
            If the Power Supply HW Port has the direction 'out' the power supply can be switched off and therefore all supplied HW Elements are switched off as well (This is used to describe groups of HW Elements that can only be switched off together). 
            When however the whole ECU is disconnected from power the switchable power supply is of course not valid anymore.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PowerSupplyHWPort.canBeSwitchedOff";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SUPPLIED" type="AR:ELECTRICAL-RANGE">
            <xsd:annotation>
               <xsd:documentation>For power source: provided electrical specification.
            For power consumer: required electrical specification.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="supplied.PowerSupplyHWPort";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUElectronics::PowerSupplyHWPort -->
   <xsd:complexType abstract="false" mixed="false" name="POWER-SUPPLY-HW-PORT">
      <xsd:annotation>
         <xsd:documentation>The Power Supply HW Port is used to model the power distribution within the ECU. If the direction is "in" the port is used to describe the power consumption of an HW Element. If the direction is "out" the port is used to describe a power source. The HW Connection between these two HW Ports can only be established between the Power Supply HW Port of the HW Element with direction "out" and a Power Supply HW Port of the Power Supply HW Element with direction "in".</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PowerSupplyHWPort"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HW-PORT"/>
         <xsd:group ref="AR:POWER-SUPPLY-HW-PORT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUElectronics::PowerSupplyVoltageNotification -->
   <xsd:group name="POWER-SUPPLY-VOLTAGE-NOTIFICATION">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PowerSupplyVoltageNotification"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="HYSTERESES" type="xsd:double">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PowerSupplyVoltageNotification.hystereses";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INTERRUPT-REFS">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PowerSupplyVoltageNotification.interrupt";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="INTERRUPT-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:INTERRUPT-PRODUCE-HW-PORT--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="LEVEL" type="xsd:double">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PowerSupplyVoltageNotification.level";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUElectronics::PowerSupplyVoltageNotification -->
   <xsd:complexType abstract="false" mixed="false" name="POWER-SUPPLY-VOLTAGE-NOTIFICATION">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PowerSupplyVoltageNotification"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:POWER-SUPPLY-VOLTAGE-NOTIFICATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Datatypes::PrimitiveType -->
   <xsd:group name="PRIMITIVE-TYPE">
      <xsd:annotation>
         <xsd:documentation>A primitive datatype consists of a set of allowed values.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PrimitiveType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpType</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-DATA-DEF-PROPS" type="AR:SW-DATA-DEF-PROPS">
            <xsd:annotation>
               <xsd:documentation>This represents the swDataDefProps of the PrimitiveType.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PrimitiveType.swDataDefProps";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <xsd:simpleType name="PRIMITIVE-TYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="BOOLEAN-TYPE"/>
         <xsd:enumeration value="CHAR-TYPE"/>
         <xsd:enumeration value="INTEGER-TYPE"/>
         <xsd:enumeration value="OPAQUE-TYPE"/>
         <xsd:enumeration value="REAL-TYPE"/>
         <xsd:enumeration value="STRING-TYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ProcessingUnit::ProcessingUnit -->
   <xsd:group name="PROCESSING-UNIT">
      <xsd:annotation>
         <xsd:documentation>A ProcessingUnit describes the plain processor core. The identifier provides the actual type name of the processing unit.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ProcessingUnit"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ADDRESSING-MODESS">
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element maxOccurs="unbounded" minOccurs="0" name="ADDRESSING-MODES" type="AR:PROCESSING-UNIT-ADRESSING-MODE-ENUM">
                     <xsd:annotation>
                        <xsd:documentation>The addressing modes describe the options to access the data from the memory.</xsd:documentation>
                        <xsd:appinfo source="tags">mmt.qualifiedName="ProcessingUnit.addressingModes";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
                     </xsd:annotation>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ARCHITECTURE-KIND" type="AR:PROCESSING-UNIT-ARCHITECTURE-KIND-ENUM">
            <xsd:annotation>
               <xsd:documentation>The kind of architecture</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ProcessingUnit.architectureKind";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ARCHITECTURE-NAME" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>The name of the architecture (e.g. ARM, MIPS, PowerPC).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ProcessingUnit.architectureName";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ARCHITECTURE-TYPE" type="AR:PROCESSING-UNIT-ARCHITECTURE-TYPE-ENUM">
            <xsd:annotation>
               <xsd:documentation>The architecture type take influence to the performance index of a PU, but are not necessarily a main topic of software development, as some of the aspects are transparent  to the user as the are handled with in the compiler. The last two types are slightly different as they require a detailed planning during system design, how the data must be prepared in order to use the features of an SIMD or MIMD very efficiently. Application like video processing use in general this features by their data format, as every pixel information is formed by the three basic colours and intensity, thus each pixel is represented by four different values, which have to be processed simultaneously.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ProcessingUnit.architectureType";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="BOOT-TIME" type="AR:BOOT-TIME">
            <xsd:annotation>
               <xsd:documentation>Provide information about the boot time of the PU.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="bootTime.ProcessingUnit";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DMA-CHANNEL-COUNT" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Direct Memory Access is a mechanism for off-loading a PU and having transfer directly between memory and peripherals without involving the PU. 
            In most common PU the DMA mechanism is implemented with a specialised cell (DMA unit) that transfers data between a peripheral device and memory, independent of the processor. The DMA controller becomes the bus master and directs the reads or writes between itself and memory. A typical DMA transfer can be described in three steps:
            1. The PU sets up the DMA transfer by supplying the identity of the periphery module, the operation to perform on that device, the memory address that is the source or the destination of the data to be transferred, and the number of bytes to transfer. 
            2. The DMA starts the operation on the periphery device and arbitrates for the bus. When the data is available, from the periphery device or memory, it transfers the data. The DMA unit supplies the memory address and initiates the next transfer. With this technique, a DMA unit can complete an entire transfer, which may be Kbytes of data, without bothering the PU. Many DMA units contain some memory to allow them to deal flexibly with delays either in transfer or those incurred while waiting to become bus master. 
            3. Once the DMA transfer is complete, the DMA unit interrupts the processor, which can then determine by interrogating the DMA unit or examining memory whether the entire operation completed successfully. 
            During an active DMA transfer the PU cannot access the involved resources concurrently.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ProcessingUnit.dmaChannelCount";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="IMPLEMENTATION-TECHNOLOGY" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Name of the technology used to implement this PU.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ProcessingUnit.implementationTechnology";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-INTERRUPT-NESTING-LEVELS" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Defines how many interrupts are allowed to be activated at one time. This entry is mainly defined by the size of the according stack as the data saving mechanism during interrupts and the data passing mechanism during function calls use the stack.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ProcessingUnit.maxInterruptNestingLevels";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MPU" type="AR:MPU">
            <xsd:annotation>
               <xsd:documentation>Describes the Memory Protection Unit, if available.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="mpu.ProcessingUnit";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NATURAL-DATA-SIZE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The natural data size prvides information which data manipulations are optimized on this PU. The natural data size is typically the Data Register size. The PU is optimised for this data size.
            Typical natural data size is one of following (in bits): 8, 16, 32, 64, other (12, 20, 80)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ProcessingUnit.naturalDataSize";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="OPCODE-SIZE" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>The attribute describes the typical length of the opcodes. In CISC machines the opcode size is variable due to the opcode itself. In RISC machines the opcode is by definition limited to a defined size.
            Type definition is used if the PU has more than one opcode set is incorporated. E.g. at the ARM architecture there is the ARM opcode set (size of 32 bit) and the Thumb opcode set (size of 16 bit).
            Code compression is a technology where the opcodes are stored in a compressed form and are automatically decompressed before execution.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ProcessingUnit.opcodeSize";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PU-CLOCK" type="AR:CLOCK">
            <xsd:annotation>
               <xsd:documentation>The clock source for the PU.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="puClock.ProcessingUnit";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REGISTER-MODELS">
            <xsd:annotation>
               <xsd:documentation>Describes the register model of the PU. For each register type availabe one 'Regsiter' element is used to give the number available.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="registerModel.ProcessingUnit";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="REGISTER" type="AR:REGISTER"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SPECIAL-OPCODESS">
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element maxOccurs="unbounded" minOccurs="0" name="SPECIAL-OPCODES" type="AR:PROCESSING-UNIT-SPECIAL-OPCODES-ENUM">
                     <xsd:annotation>
                        <xsd:documentation>The following attributes are opcodes, which are not supported by all PUs. The support of this opcodes has an influence on the performance of the PU.
                     - Bit-manipulation
                     - Multiplication
                     - Division
                     - Multiply Accumulate
                     - Floating-point Support
                     In the future further opcodes may be possible.

                     The special opcodes  take important influence to the performance index of a PU, but are not main topic of the software development, as far as high level programming languages are used, due to the fact that these are covered by compiler settings, compiler strategies and software libraries where the direct usage or a SW emulation is available for almost any general use case. For some of these opcodes the main advantage is available only at the level of assembler programming or compiler optimization.</xsd:documentation>
                        <xsd:appinfo source="tags">mmt.qualifiedName="ProcessingUnit.specialOpcodes";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
                     </xsd:annotation>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SUPPORTED-DATA-TYPES">
            <xsd:annotation>
               <xsd:documentation>This element provides a list of all supported data types and its according data sizes of the described PU.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="supportedDataType.ProcessingUnit";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SUPPORTED-DATA-TYPE" type="AR:SUPPORTED-DATA-TYPE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ProcessingUnit::ProcessingUnit -->
   <xsd:complexType abstract="false" mixed="false" name="PROCESSING-UNIT">
      <xsd:annotation>
         <xsd:documentation>A ProcessingUnit describes the plain processor core. The identifier provides the actual type name of the processing unit.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ProcessingUnit"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HW-ELEMENT"/>
         <xsd:group ref="AR:PROCESSING-UNIT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="PROCESSING-UNIT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="PROCESSING-UNIT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- complex type for class ComputationMethod::ProgCode -->
   <xsd:complexType abstract="false" mixed="false" name="PROG-CODE">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ProgCode"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Memory::ProvidedMemorySegment -->
   <xsd:group name="PROVIDED-MEMORY-SEGMENT">
      <xsd:annotation>
         <xsd:documentation>Describes one volatile memory segment.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ProvidedMemorySegment"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ALIGNMENT" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Some memory architectures are organised for bigger natural data size than accessed by the PU. In this case memory might not be used completely and some memory locations are left blank due to misalignment. The overall memory size is not used by code or data.
            Misalignment may be recovered by special mechanisms provided by hardware or software. In this case the access time will be increased. Certain PU architectures do not allow misalignment in code or data generally.
            Unit: Byte</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ProvidedMemorySegment.alignment";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ARCHITECTURAL-QUALITY" type="AR:ERROR-DETECTION-CORRECTION">
            <xsd:annotation>
               <xsd:documentation>The error detection and error correction facilities provided by the memory segment itself.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="architecturalQuality.ProvidedMemorySegment";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MANUFACTURING-QUALITY" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>As memory holds the executable program as well as the according data, memory needs a level of quality and reliability according to the purpose of the ECU. In most applications today memory is the biggest homogeneous hardware block; therefore quality and reliability of memory have the biggest impact on ECU performance and availability.
            With the introduction of non-volatile memory and the use of huge DRAM memories the aspect of quality and reliability gains more importance.
            Despite all Zero-defect programs of the semiconductor suppliers a defect rate in the range of 1 to 5 ppm must be considered as given even for critical applications.
            Separate quality data for Endurance and Data retention can be available also. The biggest value for ppm rates is used as a quality factor.
            Unit: ppm</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ProvidedMemorySegment.manufacturingQuality";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SEGMENT-SIZE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>A value that determines the amount of bytes within the memory segment.
            An ECU for AUTOSAR always contains at least one memory segment.
            Within a single ECU different memory types and access types can be used simultaneously.
            An ECU may consist of different parts that carry one or more memories.
            Segment size is defined in the terms of Bytes. 
            The overall amount of memory is the sum of all available memory segments. For different types of memory only the sum of the same type gives a useful overall sum.
            Unit: Byte</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ProvidedMemorySegment.segmentSize";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SEPARATE" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Separate memories are required for safety-relevant functions and redundancy requirements.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ProvidedMemorySegment.separate";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Memory::ProvidedMemorySegment -->
   <xsd:complexType abstract="false" mixed="false" name="PROVIDED-MEMORY-SEGMENT">
      <xsd:annotation>
         <xsd:documentation>Describes one volatile memory segment.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ProvidedMemorySegment"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HW-ELEMENT"/>
         <xsd:group ref="AR:PROVIDED-MEMORY-SEGMENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="PROVIDED-MEMORY-SEGMENT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="PROVIDED-MEMORY-SEGMENT"/>
         <xsd:enumeration value="PROVIDED-NV-MEMORY-SEGMENT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Memory::ProvidedNVMemorySegment -->
   <xsd:group name="PROVIDED-NV-MEMORY-SEGMENT">
      <xsd:annotation>
         <xsd:documentation>Describes one non-volatile memory segment.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ProvidedNVMemorySegment"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-ENDURANCE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Program and erase cycles are a stress to the memory cell, therefore endurance is characterised by the number of erase/program cycles the memory can survive exceeding the prescribed failure rate.
            Unit: No of cycles.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ProvidedNVMemorySegment.dataEndurance";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-RETENTION" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Data retention time is the time between programming a sample of non-volatile memory and the observation of a prescribed failure rate when verifying the programmed pattern. The time is dependent on the chosen technology for the integrated memory cell.
            Unit: Years</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ProvidedNVMemorySegment.dataRetention";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MARGIN-READ-AVAILABLE" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Additional to verify, all data are read back with a different set-up of the threshold of the sense amplifier of the programmed cell. With this method besides the logical correctness, the sufficient amount of electrical charges, which represents the stored data is checked. Furthermore the content of the memory and the correctness and the quality of the programming tools can be verified. Performing the margin read allow the prediction of the data retention. The feature of margin read is a characteristic of a memory, which is not available at all devices. Margin read is available for flash technology only.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ProvidedNVMemorySegment.marginReadAvailable";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SEGMENT-SIZE-ERASE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>For an erasable memory it's usually the same size of the segment as for the segment size which can be erased at a time. If the size of an erasable segment is different shall the size of the erasable segment be entered in the table.
            Unit: Byte</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ProvidedNVMemorySegment.segmentSizeErase";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SEGMENT-SIZE-WRITE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Some memory types have not the same segment size as in the case when data is written to the memory. For example, a specific flash memory you must write 128 bytes once even if the segment size is 16 kBytes.
            Unit: Byte</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ProvidedNVMemorySegment.segmentSizeWrite";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Memory::ProvidedNVMemorySegment -->
   <xsd:complexType abstract="false" mixed="false" name="PROVIDED-NV-MEMORY-SEGMENT">
      <xsd:annotation>
         <xsd:documentation>Describes one non-volatile memory segment.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ProvidedNVMemorySegment"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HW-ELEMENT"/>
         <xsd:group ref="AR:PROVIDED-MEMORY-SEGMENT"/>
         <xsd:group ref="AR:PROVIDED-NV-MEMORY-SEGMENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Peripherals::PulseWidthPeripheral -->
   <xsd:group name="PULSE-WIDTH-PERIPHERAL">
      <xsd:annotation>
         <xsd:documentation>Common elements for PWM, PWD and CCU.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="PulseWidthPeripheral"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="RESOLUTION" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Defines the data width of the counter.
            Unit: Bits</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="PulseWidthPeripheral.resolution";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class Communication::QueuedReceiverComSpec -->
   <xsd:group name="QUEUED-RECEIVER-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>Communication attributes specific to queued receiving.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="QueuedReceiverComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="QUEUE-LENGTH" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Length of queue for received events.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="QueuedReceiverComSpec.queueLength";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Communication::QueuedReceiverComSpec -->
   <xsd:complexType abstract="false" mixed="false" name="QUEUED-RECEIVER-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>Communication attributes specific to queued receiving.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="QueuedReceiverComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:RECEIVER-COM-SPEC"/>
         <xsd:group ref="AR:QUEUED-RECEIVER-COM-SPEC"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- complex type for class Communication::QueuedSenderComSpec -->
   <xsd:complexType abstract="false" mixed="false" name="QUEUED-SENDER-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>Communication attributes specific to distribution of  events (P-Port, sender-receiver interface and data element carries an "event").</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="QueuedSenderComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SENDER-COM-SPEC"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Components::RPortPrototype -->
   <xsd:group name="R-PORT-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>Component port requiring a certain port interface.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RPortPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="REQUIRED-COM-SPECS">
            <xsd:annotation>
               <xsd:documentation>Required communication attributes, one for each interface element.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="requiredComSpec.RPortPrototype";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CLIENT-COM-SPEC" type="AR:CLIENT-COM-SPEC"/>
                  <xsd:element name="PARAMETER-REQUIRE-COM-SPEC" type="AR:PARAMETER-REQUIRE-COM-SPEC"/>
                  <xsd:element name="QUEUED-RECEIVER-COM-SPEC" type="AR:QUEUED-RECEIVER-COM-SPEC"/>
                  <xsd:element name="UNQUEUED-RECEIVER-COM-SPEC" type="AR:UNQUEUED-RECEIVER-COM-SPEC"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REQUIRED-INTERFACE-TREF">
            <xsd:annotation>
               <xsd:documentation>The interface that this port requires, i.e. the port depends on another port providing the specified interface.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="rPort.requiredInterface";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">isOfType</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-INTERFACE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Components::RPortPrototype -->
   <xsd:complexType abstract="false" mixed="false" name="R-PORT-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>Component port requiring a certain port interface.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RPortPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PORT-PROTOTYPE"/>
         <xsd:group ref="AR:R-PORT-PROTOTYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="R-PORT-PROTOTYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="R-PORT-PROTOTYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class RTEEvents::RTEEvent -->
   <xsd:group name="RTE-EVENT">
      <xsd:annotation>
         <xsd:documentation>Abstract base class for all RTE-related events</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RTEEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODE-DEPENDENCY" type="AR:MODE-DISABLING-DEPENDENCY">
            <xsd:annotation>
               <xsd:documentation>Provides the means to describe the Modes this RTEEvent can be disabled by.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="modeDependency.RTEEvent";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="START-ON-EVENT-REF">
            <xsd:annotation>
               <xsd:documentation>Runnable starts when event occurs</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RTEEvent.startOnEvent";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:RUNNABLE-ENTITY--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <xsd:simpleType name="RTE-EVENT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ASYNCHRONOUS-SERVER-CALL-RETURNS-EVENT"/>
         <xsd:enumeration value="DATA-RECEIVE-ERROR-EVENT"/>
         <xsd:enumeration value="DATA-RECEIVED-EVENT"/>
         <xsd:enumeration value="DATA-SEND-COMPLETED-EVENT"/>
         <xsd:enumeration value="MODE-SWITCH-EVENT"/>
         <xsd:enumeration value="MODE-SWITCHED-ACK-EVENT"/>
         <xsd:enumeration value="OPERATION-INVOKED-EVENT"/>
         <xsd:enumeration value="TIMING-EVENT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Datatypes::Range -->
   <xsd:group name="RANGE">
      <xsd:annotation>
         <xsd:documentation>Abstract class for specifying a range from lower limit to upper limit.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Range"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="LOWER-LIMIT" type="AR:AR-LIMIT">
            <xsd:annotation>
               <xsd:documentation>This element specifies the lower limit of a closed, half-open or open interval. It can also be set to infinity by setting the attribute INTERVAL-TYPE to INFINITE. No value has to be set in the case of an infinite interval.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Range.lowerLimit";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="UPPER-LIMIT" type="AR:AR-LIMIT">
            <xsd:annotation>
               <xsd:documentation>This element specifies the upper limit of a closed, half-open or open interval. It can also be set to infinity by setting the attribute INTERVAL-TYPE to INFINITE. No value has to be set in the case of an infinite interval.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Range.upperLimit";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class Constants::RealLiteral -->
   <xsd:group name="REAL-LITERAL">
      <xsd:annotation>
         <xsd:documentation>Constant description for real values.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RealLiteral"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VALUE" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>The numeric value itself.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RealLiteral.value";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Constants::RealLiteral -->
   <xsd:complexType abstract="false" mixed="false" name="REAL-LITERAL">
      <xsd:annotation>
         <xsd:documentation>Constant description for real values.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RealLiteral"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:DATA-PROTOTYPE"/>
         <xsd:group ref="AR:REAL-LITERAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Datatypes::RealType -->
   <xsd:group name="REAL-TYPE">
      <xsd:annotation>
         <xsd:documentation>This represents a range of reals that can be represented by either the IEEE 754 "Single Precision" (encoding is "Single") or IEEE 754 "Double Precision" (encoding is "Double") arithmetic.
      Note that these standards include representations for +infinity, -infinity, QNaN and SNaN.  When defining a RealType, one must indicate whether these special values are allowed or not.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RealType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpType</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ALLOW-NAN" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Denotes whether this data type permits for "not a number" being represented by the type</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RealType.allowNaN";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.name="ALLOW-NAN"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ENCODING" type="AR:REAL-TYPE-ENCODING-ENUM">
            <xsd:annotation>
               <xsd:documentation>Denotes the precision of the RealType</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RealType.encoding";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Datatypes::RealType -->
   <xsd:complexType abstract="false" mixed="false" name="REAL-TYPE">
      <xsd:annotation>
         <xsd:documentation>This represents a range of reals that can be represented by either the IEEE 754 "Single Precision" (encoding is "Single") or IEEE 754 "Double Precision" (encoding is "Double") arithmetic.
      Note that these standards include representations for +infinity, -infinity, QNaN and SNaN.  When defining a RealType, one must indicate whether these special values are allowed or not.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RealType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpType</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PRIMITIVE-TYPE"/>
         <xsd:group ref="AR:RANGE"/>
         <xsd:group ref="AR:REAL-TYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ApplicationAttributes::ReceiverAnnotation -->
   <xsd:group name="RECEIVER-ANNOTATION">
      <xsd:annotation>
         <xsd:documentation>Annotation of a receiver port, specifying properties of data elements that don't affect communication or generation of the RTE. The given attributes are requirements on the required data.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ReceiverAnnotation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SIGNAL-AGE" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>The maximum allowed age of the signal since it was originally read by a sensor. This is a requirement specified on the receiver side.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ReceiverAnnotation.signalAge";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ApplicationAttributes::ReceiverAnnotation -->
   <xsd:complexType abstract="false" mixed="false" name="RECEIVER-ANNOTATION">
      <xsd:annotation>
         <xsd:documentation>Annotation of a receiver port, specifying properties of data elements that don't affect communication or generation of the RTE. The given attributes are requirements on the required data.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ReceiverAnnotation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:GENERAL-ANNOTATION"/>
         <xsd:group ref="AR:SENDER-RECEIVER-ANNOTATION"/>
         <xsd:group ref="AR:RECEIVER-ANNOTATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Communication::ReceiverComSpec -->
   <xsd:group name="RECEIVER-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>Receiver specific communication attributes (R-Port and sender-receiver interface).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ReceiverComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-ELEMENT-REF">
            <xsd:annotation>
               <xsd:documentation>Data element these attributes belong to.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ReceiverComSpec.dataElement";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:DATA-ELEMENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FILTER">
            <xsd:annotation>
               <xsd:documentation>The DataFilter associated with this ReceiverComSpec.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="filter.ReceiverComSpec";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="ALWAYS" type="AR:ALWAYS"/>
                  <xsd:element name="MASKED-NEW-DIFFERS-MASKED-OLD" type="AR:MASKED-NEW-DIFFERS-MASKED-OLD"/>
                  <xsd:element name="MASKED-NEW-DIFFERS-X" type="AR:MASKED-NEW-DIFFERS-X"/>
                  <xsd:element name="MASKED-NEW-EQUALS-X" type="AR:MASKED-NEW-EQUALS-X"/>
                  <xsd:element name="NEVER" type="AR:NEVER"/>
                  <xsd:element name="NEW-IS-OUTSIDE" type="AR:NEW-IS-OUTSIDE"/>
                  <xsd:element name="NEW-IS-WITHIN" type="AR:NEW-IS-WITHIN"/>
                  <xsd:element name="ONE-EVERY-N" type="AR:ONE-EVERY-N"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="USES-END-TO-END-PROTECTION" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>This indicates whether the corresponding dataElement shall be transmitted using end-to-end protection.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ReceiverComSpec.usesEndToEndProtection";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Datatypes::RecordElement -->
   <xsd:complexType abstract="false" mixed="false" name="RECORD-ELEMENT">
      <xsd:annotation>
         <xsd:documentation>An element in a record.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RecordElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:DATA-PROTOTYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="RECORD-ELEMENT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="RECORD-ELEMENT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class MeasurementProperty::RecordElementRef -->
   <xsd:group name="RECORD-ELEMENT-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RecordElementRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="RECORD-ELEMENT-IREF" type="AR:RECORD-ELEMENT-REF--RECORD-ELEMENT-IREF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RecordElementRef.recordElement";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class MeasurementProperty::RecordElementRef -->
   <xsd:complexType abstract="false" mixed="false" name="RECORD-ELEMENT-REF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RecordElementRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:RECORD-ELEMENT-REF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class _instanceRef::RecordElementRef_RecordElement -->
   <xsd:group name="RECORD-ELEMENT-REF--RECORD-ELEMENT-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RecordElementRef_RecordElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="COMPOSITION-COMPONENT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RecordElementRef_RecordElement.compositionComponentPrototype";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="10"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMPONENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPONENT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RecordElementRef_RecordElement.componentPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMPONENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PORT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RecordElementRef_RecordElement.portPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="DATA-ELEMENT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RecordElementRef_RecordElement.dataElementPrototype";pureMM.maxOccurs="-1";pureMM.minOccurs="1";xml.sequenceOffset="40"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:DATA-ELEMENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="1" name="RECORD-ELEMENT-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RecordElementRef_RecordElement.recordElement";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="50"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.target</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:RECORD-ELEMENT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class _instanceRef::RecordElementRef_RecordElement -->
   <xsd:complexType abstract="false" mixed="false" name="RECORD-ELEMENT-REF--RECORD-ELEMENT-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RecordElementRef_RecordElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:RECORD-ELEMENT-REF--RECORD-ELEMENT-IREF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Constants::RecordSpecification -->
   <xsd:group name="RECORD-SPECIFICATION">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RecordSpecification"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ELEMENTS">
            <xsd:annotation>
               <xsd:documentation>Elements of the record.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="element.RecordSpecification";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ARRAY-SPECIFICATION" type="AR:ARRAY-SPECIFICATION"/>
                  <xsd:element name="BOOLEAN-LITERAL" type="AR:BOOLEAN-LITERAL"/>
                  <xsd:element name="CHAR-LITERAL" type="AR:CHAR-LITERAL"/>
                  <xsd:element name="CONSTANT-REFERENCE" type="AR:CONSTANT-REFERENCE"/>
                  <xsd:element name="INTEGER-LITERAL" type="AR:INTEGER-LITERAL"/>
                  <xsd:element name="OPAQUE-LITERAL" type="AR:OPAQUE-LITERAL"/>
                  <xsd:element name="REAL-LITERAL" type="AR:REAL-LITERAL"/>
                  <xsd:element name="RECORD-SPECIFICATION" type="AR:RECORD-SPECIFICATION"/>
                  <xsd:element name="STRING-LITERAL" type="AR:STRING-LITERAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Constants::RecordSpecification -->
   <xsd:complexType abstract="false" mixed="false" name="RECORD-SPECIFICATION">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RecordSpecification"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:DATA-PROTOTYPE"/>
         <xsd:group ref="AR:RECORD-SPECIFICATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Datatypes::RecordType -->
   <xsd:group name="RECORD-TYPE">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RecordType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpType</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ELEMENTS">
            <xsd:annotation>
               <xsd:documentation>This represents the collection of RecordElements that make up the RecordType.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="element.RecordType";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="RECORD-ELEMENT" type="AR:RECORD-ELEMENT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Datatypes::RecordType -->
   <xsd:complexType abstract="false" mixed="false" name="RECORD-TYPE">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RecordType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpType</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:RECORD-TYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUCParameterDefTemplate::ReferenceParamDef -->
   <xsd:group name="REFERENCE-PARAM-DEF">
      <xsd:annotation>
         <xsd:documentation>Specify references within the ECU Configuration Description between parameter containers.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ReferenceParamDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DESTINATION-REF">
            <xsd:annotation>
               <xsd:documentation>Exactly one reference  to an parameter container is allowed as destination.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ReferenceParamDef.destination";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PARAM-CONF-CONTAINER-DEF--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::ReferenceParamDef -->
   <xsd:complexType abstract="false" mixed="false" name="REFERENCE-PARAM-DEF">
      <xsd:annotation>
         <xsd:documentation>Specify references within the ECU Configuration Description between parameter containers.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ReferenceParamDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PARAM-CONF-MULTIPLICITY"/>
         <xsd:group ref="AR:COMMON-CONFIGURATION-ATTRIBUTES"/>
         <xsd:group ref="AR:REFERENCE-PARAM-DEF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUCDescriptionTemplate::ReferenceValue -->
   <xsd:group name="REFERENCE-VALUE">
      <xsd:annotation>
         <xsd:documentation>Used to represent a configuration value that has a parameter definition of type ConfigReference (used for all of its specializations excluding InstanceReferenceParamDef).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ReferenceValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VALUE-REF">
            <xsd:annotation>
               <xsd:documentation>Specifes the destination of the reference.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ReferenceValue.value";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:IDENTIFIABLE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCDescriptionTemplate::ReferenceValue -->
   <xsd:complexType abstract="false" mixed="false" name="REFERENCE-VALUE">
      <xsd:annotation>
         <xsd:documentation>Used to represent a configuration value that has a parameter definition of type ConfigReference (used for all of its specializations excluding InstanceReferenceParamDef).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ReferenceValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:CONFIG-REFERENCE-VALUE"/>
         <xsd:group ref="AR:REFERENCE-VALUE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ProcessingUnit::Register -->
   <xsd:group name="REGISTER">
      <xsd:annotation>
         <xsd:documentation>The user available registers are a part of the programming model that consists of: Memory organisation and segmentation, Data types, Registers, Instruction format, Operand selection, Interrupts and exceptions.
      Basically the register model contains the registers that are interest to the applications programmer; these registers can be grouped into three basic categories:
      - General registers: These general-purpose registers are used primarily to contain operands for arithmetic and logical operations.
      - Segment registers: These special-purpose registers permit software designers to choose either a flat or segmented model of memory organisation. These registers determine, at any given time, which segments of memory are currently addressable.
      - Status and instruction registers: These special-purpose registers are used to record and alter certain aspects of the processor state.

      The register model is only valuable data for low level programming, e.g assembler programming. The register model, along with the available OP codes takes influence on the performance of the PU. The most general impact of the register model to software is number of registers which have to be handled during interrupts or function calls.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Register"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COUNT" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Describes how many registers are available of the specified type.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Register.count";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TYPE" type="AR:REGISTER-TYPE-ENUM">
            <xsd:annotation>
               <xsd:documentation>Describes the kind of register.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Register.type";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ProcessingUnit::Register -->
   <xsd:complexType abstract="false" mixed="false" name="REGISTER">
      <xsd:annotation>
         <xsd:documentation>The user available registers are a part of the programming model that consists of: Memory organisation and segmentation, Data types, Registers, Instruction format, Operand selection, Interrupts and exceptions.
      Basically the register model contains the registers that are interest to the applications programmer; these registers can be grouped into three basic categories:
      - General registers: These general-purpose registers are used primarily to contain operands for arithmetic and logical operations.
      - Segment registers: These special-purpose registers permit software designers to choose either a flat or segmented model of memory organisation. These registers determine, at any given time, which segments of memory are currently addressable.
      - Status and instruction registers: These special-purpose registers are used to record and alter certain aspects of the processor state.

      The register model is only valuable data for low level programming, e.g assembler programming. The register model, along with the available OP codes takes influence on the performance of the PU. The most general impact of the register model to software is number of registers which have to be handled during interrupts or function calls.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Register"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:REGISTER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Timing::RelativeTolerance -->
   <xsd:group name="RELATIVE-TOLERANCE">
      <xsd:annotation>
         <xsd:documentation>Maximum allowable deviation</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RelativeTolerance"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="RELATIVE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Maximum allowable deviation in percent</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RelativeTolerance.relative";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Timing::RelativeTolerance -->
   <xsd:complexType abstract="false" mixed="false" name="RELATIVE-TOLERANCE">
      <xsd:annotation>
         <xsd:documentation>Maximum allowable deviation</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RelativeTolerance"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:RELATIVE-TOLERANCE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class LinCommunication::RelativelyScheduledTiming -->
   <xsd:group name="RELATIVELY-SCHEDULED-TIMING">
      <xsd:annotation>
         <xsd:documentation>Specification of a sending behavior where the transmission order is predefined, e.g. used on LIN buses</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RelativelyScheduledTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DELAY" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Relative delay between this frame and the start 
            of the successor frame in the schedule table in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RelativelyScheduledTiming.delay";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="POSITION-IN-TABLE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Relative position of the frame described by this timing in the schedule table</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RelativelyScheduledTiming.positionInTable";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SCHEDULE-TABLE-REF">
            <xsd:annotation>
               <xsd:documentation>The master task transmits frame headers based on a schedule table. The master application may use different schedule tables and select among them.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RelativelyScheduledTiming.scheduleTable";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:LIN-SCHEDULE-TABLE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class LinCommunication::RelativelyScheduledTiming -->
   <xsd:complexType abstract="false" mixed="false" name="RELATIVELY-SCHEDULED-TIMING">
      <xsd:annotation>
         <xsd:documentation>Specification of a sending behavior where the transmission order is predefined, e.g. used on LIN buses</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RelativelyScheduledTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:RELATIVELY-SCHEDULED-TIMING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Annotation::Remark -->
   <xsd:group name="REMARK">
      <xsd:annotation>
         <xsd:documentation>&lt;remark&gt; is used for comments e.g. on the specific calibration state. The remark can be a regular paragraph or a preformatted text.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Remark"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixed,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice>
         <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element maxOccurs="unbounded" minOccurs="0" name="P" type="AR:ML-DATA-1">
               <xsd:annotation>
                  <xsd:documentation>Use &lt;p&gt; to create a paragraph for continuous texts.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="Remark.p";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element maxOccurs="unbounded" minOccurs="0" name="VERBATIM" type="AR:ML-DATA-5">
               <xsd:annotation>
                  <xsd:documentation>&lt;verbatim&gt; is a paragraph in which white-space (in particular blanks and line feeds) is obeyed. This enables basic preformatting to be carried out, which can even be displayed on simple devices. Behavior is the same as PRE in HTML .</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="Remark.verbatim";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
         </xsd:choice>
      </xsd:choice>
   </xsd:group>
   <!-- complex type for class Annotation::Remark -->
   <xsd:complexType abstract="false" mixed="false" name="REMARK">
      <xsd:annotation>
         <xsd:documentation>&lt;remark&gt; is used for comments e.g. on the specific calibration state. The remark can be a regular paragraph or a preformatted text.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Remark"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixed,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:REMARK"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- complex type for class ApplicationAttributes::ReportFeature -->
   <xsd:complexType abstract="false" mixed="false" name="REPORT-FEATURE">
      <xsd:annotation>
         <xsd:documentation>This feature is used for input signals only. Each time the level of the associated data-element changes a dedicated  GET operation has to be invoked by the sensor software component, i.e. an appropriate runnable has to be started.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ReportFeature"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Timing::RequestControlledTiming -->
   <xsd:group name="REQUEST-CONTROLLED-TIMING">
      <xsd:annotation>
         <xsd:documentation>Specification of a request driven sending behavior. Semantics of this communication mechanism is that basic software stores values but does not send it out until a frame requesting the information is received.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RequestControlledTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="FINAL-REPETITIONS" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Number of repetitions the frame is sent for a single request</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RequestControlledTiming.finalRepetitions";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RESPONSE-TIME" type="AR:TIME-RANGE-TYPE">
            <xsd:annotation>
               <xsd:documentation>Specification of the time that is needed before the frame can be sent after the requests arrival</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="responseTime.RequestControlledTiming";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Timing::RequestControlledTiming -->
   <xsd:complexType abstract="false" mixed="false" name="REQUEST-CONTROLLED-TIMING">
      <xsd:annotation>
         <xsd:documentation>Specification of a request driven sending behavior. Semantics of this communication mechanism is that basic software stores values but does not send it out until a frame requesting the information is received.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RequestControlledTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:REQUEST-CONTROLLED-TIMING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ResourceConsumption::ResourceConsumption -->
   <xsd:group name="RESOURCE-CONSUMPTION">
      <xsd:annotation>
         <xsd:documentation>Description of consumed resources by one implementation of a software.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ResourceConsumption"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="EXECUTION-TIMES">
            <xsd:annotation>
               <xsd:documentation>Collection of the execution time descriptions for the runnable entities of this implementation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="executionTime.ResourceConsumption";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="EXECUTION-TIME" type="AR:EXECUTION-TIME"/>
                  <xsd:element name="MEASURED-EXECUTION-TIME" type="AR:MEASURED-EXECUTION-TIME"/>
                  <xsd:element name="ROUGH-ESTIMATE-OF-EXECUTION-TIME" type="AR:ROUGH-ESTIMATE-OF-EXECUTION-TIME"/>
                  <xsd:element name="SIMULATED-EXECUTION-TIME" type="AR:SIMULATED-EXECUTION-TIME"/>
                  <xsd:element name="WORST-CASE-EXECUTION-TIME" type="AR:WORST-CASE-EXECUTION-TIME"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="HEAP-USAGES">
            <xsd:annotation>
               <xsd:documentation>Collection of the heap memory allocated by this implementation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="heapUsage.ResourceConsumption";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="MEASURED-HEAP-USAGE" type="AR:MEASURED-HEAP-USAGE"/>
                  <xsd:element name="ROUGH-ESTIMATE-HEAP-USAGE" type="AR:ROUGH-ESTIMATE-HEAP-USAGE"/>
                  <xsd:element name="WORST-CASE-HEAP-USAGE" type="AR:WORST-CASE-HEAP-USAGE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="OBJECT-FILE-SECTIONS">
            <xsd:annotation>
               <xsd:documentation>Provides additional information to the sections of the object-file containing the implementation of the SW-Component</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="objectFileSection.ResourceConsumption";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="MEMORY-SECTION" type="AR:MEMORY-SECTION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="STACK-USAGES">
            <xsd:annotation>
               <xsd:documentation>Collection of the stack memory usage for each runnable entity of this implementation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="stackUsage.ResourceConsumption";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="MEASURED-STACK-USAGE" type="AR:MEASURED-STACK-USAGE"/>
                  <xsd:element name="ROUGH-ESTIMATE-STACK-USAGE" type="AR:ROUGH-ESTIMATE-STACK-USAGE"/>
                  <xsd:element name="WORST-CASE-STACK-USAGE" type="AR:WORST-CASE-STACK-USAGE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ResourceConsumption::ResourceConsumption -->
   <xsd:complexType abstract="false" mixed="false" name="RESOURCE-CONSUMPTION">
      <xsd:annotation>
         <xsd:documentation>Description of consumed resources by one implementation of a software.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ResourceConsumption"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:RESOURCE-CONSUMPTION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ServiceMapping::RoleBasedPPortAssignment -->
   <xsd:group name="ROLE-BASED-P-PORT-ASSIGNMENT">
      <xsd:annotation>
         <xsd:documentation>This class specifies an assignment of a role to a particular P-Port. This port must contain a service which is inside of the component and called by outside entity in order to handle a particular issue (e.g. a communication event). This is often named as callback.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RoleBasedPPortAssignment"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="P-PORT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:documentation>Port which provides the software component to be connected to an AUTOSAR Service.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RoleBasedPPortAssignment.pPortPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:P-PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ROLE" type="AR:IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>This is the role of the assigned Port in the given context.

            The value must be a name of a PortInterface as standardized in the Software Specification of the related AUTOSAR Service.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RoleBasedPPortAssignment.role";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceMapping::RoleBasedPPortAssignment -->
   <xsd:complexType abstract="false" mixed="false" name="ROLE-BASED-P-PORT-ASSIGNMENT">
      <xsd:annotation>
         <xsd:documentation>This class specifies an assignment of a role to a particular P-Port. This port must contain a service which is inside of the component and called by outside entity in order to handle a particular issue (e.g. a communication event). This is often named as callback.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RoleBasedPPortAssignment"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:ROLE-BASED-P-PORT-ASSIGNMENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ServiceMapping::RoleBasedRPortAssignment -->
   <xsd:group name="ROLE-BASED-R-PORT-ASSIGNMENT">
      <xsd:annotation>
         <xsd:documentation>This class specifies an assignment of a role to a particular R-Port. This port must contain a service which is outside of the component and called by the component in order to handle a particular issue (e.g. a communication event).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RoleBasedRPortAssignment"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="R-PORT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:documentation>Port which requires the software component to be connected to an AUTOSAR Service.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RoleBasedRPortAssignment.rPortPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:R-PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ROLE" type="AR:IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>This is the role the assigned Port in given context.

            The value must be a name of a  PortInterface as standardized in  Software Specification of the related AUTOSAR Service.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RoleBasedRPortAssignment.role";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceMapping::RoleBasedRPortAssignment -->
   <xsd:complexType abstract="false" mixed="false" name="ROLE-BASED-R-PORT-ASSIGNMENT">
      <xsd:annotation>
         <xsd:documentation>This class specifies an assignment of a role to a particular R-Port. This port must contain a service which is outside of the component and called by the component in order to handle a particular issue (e.g. a communication event).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RoleBasedRPortAssignment"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:ROLE-BASED-R-PORT-ASSIGNMENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class HeapUsage::RoughEstimateHeapUsage -->
   <xsd:group name="ROUGH-ESTIMATE-HEAP-USAGE">
      <xsd:annotation>
         <xsd:documentation>Rough estimation of the heap usage.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RoughEstimateHeapUsage"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MEMORY-CONSUMPTION" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Rough estimate of the heap usage.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RoughEstimateHeapUsage.memoryConsumption";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class HeapUsage::RoughEstimateHeapUsage -->
   <xsd:complexType abstract="false" mixed="false" name="ROUGH-ESTIMATE-HEAP-USAGE">
      <xsd:annotation>
         <xsd:documentation>Rough estimation of the heap usage.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RoughEstimateHeapUsage"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HEAP-USAGE"/>
         <xsd:group ref="AR:ROUGH-ESTIMATE-HEAP-USAGE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ExecutionTime::RoughEstimateOfExecutionTime -->
   <xsd:group name="ROUGH-ESTIMATE-OF-EXECUTION-TIME">
      <xsd:annotation>
         <xsd:documentation>Provides a description of a rough estimate on the ExecutionTime.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RoughEstimateOfExecutionTime"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DESCRIPTION" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Provides description on the rough estimate of the ExecutionTime.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RoughEstimateOfExecutionTime.description";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ExecutionTime::RoughEstimateOfExecutionTime -->
   <xsd:complexType abstract="false" mixed="false" name="ROUGH-ESTIMATE-OF-EXECUTION-TIME">
      <xsd:annotation>
         <xsd:documentation>Provides a description of a rough estimate on the ExecutionTime.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RoughEstimateOfExecutionTime"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:EXECUTION-TIME"/>
         <xsd:group ref="AR:ROUGH-ESTIMATE-OF-EXECUTION-TIME"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class StackUsage::RoughEstimateStackUsage -->
   <xsd:group name="ROUGH-ESTIMATE-STACK-USAGE">
      <xsd:annotation>
         <xsd:documentation>Rough estimation of the stack usage.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RoughEstimateStackUsage"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MEMORY-CONSUMPTION" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Rough estimate of the stack usage.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RoughEstimateStackUsage.memoryConsumption";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class StackUsage::RoughEstimateStackUsage -->
   <xsd:complexType abstract="false" mixed="false" name="ROUGH-ESTIMATE-STACK-USAGE">
      <xsd:annotation>
         <xsd:documentation>Rough estimation of the stack usage.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RoughEstimateStackUsage"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:STACK-USAGE"/>
         <xsd:group ref="AR:ROUGH-ESTIMATE-STACK-USAGE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class SwcInternalBehavior::RunnableEntity -->
   <xsd:group name="RUNNABLE-ENTITY">
      <xsd:annotation>
         <xsd:documentation>The runnable entities are the smallest code-fragments that are provided by the component and are executed in the RTE. Runnables are for instance set up to respond to data reception or operation invocation on a server.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RunnableEntity"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BSW-ENTITY-REF">
            <xsd:annotation>
               <xsd:documentation>Optional reference to the corresponding BswModuleEntity in case the RunnableEntity is implemented as part of a BSW module (in the case of an AUTOSAR Service, a Complex Device Driver or an ECU Abstraction). It can be used by a tool to find relevant information on the behavior, e.g. whether the bswEntity shall be running in interrupt context.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RunnableEntity.bswEntity";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:BSW-MODULE-ENTITY--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CALPRM-ACCESSS">
            <xsd:annotation>
               <xsd:documentation>The presence of a calprmAccess implies that a RunnableEntity needs read only access to a CalprmElementPrototype which may either be local or within a PortPrototype.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RunnableEntity.calprmAccess";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CALPRM-ACCESS" type="AR:CALPRM-ACCESS"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CAN-BE-INVOKED-CONCURRENTLY" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Normally, this is FALSE.
            When this is TRUE, it is allowed that this runnable entity is invoked concurrently (even for one instance of the SW-C), which implies that it is the responsibility of the implementation of the runnable to take care of this form of concurrency.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RunnableEntity.canBeInvokedConcurrently";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CAN-ENTER-EXCLUSIVE-AREA-REFS">
            <xsd:annotation>
               <xsd:documentation>This means that the runnable can enter/leave the referenced exclusive area through explicit API calls.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RunnableEntity.canEnterExclusiveArea";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CAN-ENTER-EXCLUSIVE-AREA-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:EXCLUSIVE-AREA--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-READ-ACCESSS">
            <xsd:annotation>
               <xsd:documentation>Runnable has read access to data element</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="dataReadAccess.runnable";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="DATA-READ-ACCESS" type="AR:DATA-READ-ACCESS"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-RECEIVE-POINTS">
            <xsd:annotation>
               <xsd:documentation>Data receive points of this runnable.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="dataReceivePoint.runnable";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="DATA-RECEIVE-POINT" type="AR:DATA-RECEIVE-POINT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-SEND-POINTS">
            <xsd:annotation>
               <xsd:documentation>The runnable has data send point.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="dataSendPoint.runnable";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="DATA-SEND-POINT" type="AR:DATA-SEND-POINT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-WRITE-ACCESSS">
            <xsd:annotation>
               <xsd:documentation>Runnable has write access to data element</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="dataWriteAccess.runnable";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="DATA-WRITE-ACCESS" type="AR:DATA-WRITE-ACCESS"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MINIMUM-START-INTERVAL" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Specifies the time in seconds which two starts of a RunnableEntity are guaranteed to be separated.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RunnableEntity.minimumStartInterval";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODE-SWITCH-POINTS">
            <xsd:annotation>
               <xsd:documentation>The runnable has a mode switch point.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="modeSwitchPoint.runnable";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="MODE-SWITCH-POINT" type="AR:MODE-SWITCH-POINT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PER-INSTANCE-CALPRM-ACCESS-REFS">
            <xsd:annotation>
               <xsd:documentation>This implements the ability to access a per-instance calibration parameter.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RunnableEntity.perInstanceCalprmAccess";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="PER-INSTANCE-CALPRM-ACCESS-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:CALPRM-ELEMENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="READ-VARIABLE-REFS">
            <xsd:annotation>
               <xsd:documentation>Inter-runnable variables that are read by this Runnable.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RunnableEntity.readVariable";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="READ-VARIABLE-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:INTER-RUNNABLE-VARIABLE--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RUNS-INSIDE-EXCLUSIVE-AREA-REFS">
            <xsd:annotation>
               <xsd:documentation>The runnable entity runs inside the referenced exclusive area</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RunnableEntity.runsInsideExclusiveArea";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="RUNS-INSIDE-EXCLUSIVE-AREA-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:EXCLUSIVE-AREA--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SERVER-CALL-POINTS">
            <xsd:annotation>
               <xsd:documentation>The runnable has server call point.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="serverCallPoint.runnable";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ASYNCHRONOUS-SERVER-CALL-POINT" type="AR:ASYNCHRONOUS-SERVER-CALL-POINT"/>
                  <xsd:element name="SYNCHRONOUS-SERVER-CALL-POINT" type="AR:SYNCHRONOUS-SERVER-CALL-POINT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SHARED-CALPRM-ACCESS-REFS">
            <xsd:annotation>
               <xsd:documentation>This represents the ability to access a shared calibration parameter.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RunnableEntity.sharedCalprmAccess";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SHARED-CALPRM-ACCESS-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:CALPRM-ELEMENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYMBOL" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>The symbol describing this runnable's entry point. This is considered the API of the runnable and is required during the RTE contract phase.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RunnableEntity.symbol";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="WAIT-POINTS">
            <xsd:annotation>
               <xsd:documentation>The runnable has wait point.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="waitPoint.runnable";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="WAIT-POINT" type="AR:WAIT-POINT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="WRITTEN-VARIABLE-REFS">
            <xsd:annotation>
               <xsd:documentation>Inter-runnable variables that are written by Runnable.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RunnableEntity.writtenVariable";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="WRITTEN-VARIABLE-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:INTER-RUNNABLE-VARIABLE--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SwcInternalBehavior::RunnableEntity -->
   <xsd:complexType abstract="false" mixed="false" name="RUNNABLE-ENTITY">
      <xsd:annotation>
         <xsd:documentation>The runnable entities are the smallest code-fragments that are provided by the component and are executed in the RTE. Runnables are for instance set up to respond to data reception or operation invocation on a server.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RunnableEntity"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:RUNNABLE-ENTITY"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="RUNNABLE-ENTITY--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="RUNNABLE-ENTITY"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class CanCommunication::RxIdentifierRange -->
   <xsd:group name="RX-IDENTIFIER-RANGE">
      <xsd:annotation>
         <xsd:documentation>Optional definition of a CanId range to reduce the effort of specifying every possible FrameTriggering within the defined Id range during reception. All frames received within a range are mapped to the same Pdu that is passed to a upper layer module (e.g. Nm, CDD, PduR). 

      This range is redundant to the attributes "nmLowerCanId" and "nmUpperCanId" of "CanCluster". For backward compatibility reasons this redundancy shall be preserved and both shall be defined.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RxIdentifierRange"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="LOWER-CAN-ID" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>This attribute can be used together with the upperCanId attribute to define a range of CanIds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RxIdentifierRange.lowerCanId";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="UPPER-CAN-ID" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>This attribute can be used together with the lowerCanId attribute to define a range of CanIds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="RxIdentifierRange.upperCanId";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CanCommunication::RxIdentifierRange -->
   <xsd:complexType abstract="false" mixed="false" name="RX-IDENTIFIER-RANGE">
      <xsd:annotation>
         <xsd:documentation>Optional definition of a CanId range to reduce the effort of specifying every possible FrameTriggering within the defined Id range during reception. All frames received within a range are mapped to the same Pdu that is passed to a upper layer module (e.g. Nm, CDD, PduR). 

      This range is redundant to the attributes "nmLowerCanId" and "nmUpperCanId" of "CanCluster". For backward compatibility reasons this redundancy shall be preserved and both shall be defined.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="RxIdentifierRange"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:RX-IDENTIFIER-RANGE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class GlobalConstraints::ScaleConstr -->
   <xsd:group name="SCALE-CONSTR">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ScaleConstr"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SHORT-LABEL" type="AR:IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>This element specifies a short name for the scaleConstr. This can for example be used to create more specific messages of a constraint checker. The constraints cannot be associated in the metamodel, therefore shortLabel is somehow a substitute for shortName.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ScaleConstr.shortLabel";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DESC" type="AR:ML-DATA-2">
            <xsd:annotation>
               <xsd:documentation>&lt;desc&gt; represents a general but brief description of the object in question.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ScaleConstr.desc";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="LOWER-LIMIT" type="AR:LIMIT">
            <xsd:annotation>
               <xsd:documentation>This element specifies the lower limit of a closed, half-open or open interval. It can also be set to infinity by setting the attribute INTERVAL-TYPE to INFINITE. No value has to be set in the case of an infinite interval.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ScaleConstr.lowerLimit";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="UPPER-LIMIT" type="AR:LIMIT">
            <xsd:annotation>
               <xsd:documentation>This element specifies the upper limit of a closed, half-open or open interval. It can also be set to infinity by setting the attribute INTERVAL-TYPE to INFINITE. No value has to be set in the case of an infinite interval.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ScaleConstr.upperLimit";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- attribute group for class GlobalConstraints::ScaleConstr -->
   <xsd:attributeGroup name="SCALE-CONSTR">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ScaleConstr"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="VALIDITY" type="AR:SCALE-CONSTR-VALIDITY-ENUM">
         <xsd:annotation>
            <xsd:documentation>Specifies if the values defined by the scales are considered to be valid. If the attribute is missing then the default value is "VALID".</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="ScaleConstr.validity";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class GlobalConstraints::ScaleConstr -->
   <xsd:complexType abstract="false" mixed="false" name="SCALE-CONSTR">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ScaleConstr"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SCALE-CONSTR"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:SCALE-CONSTR"/>
   </xsd:complexType>
   <!-- element group for class GlobalConstraints::ScaleConstrs -->
   <xsd:group name="SCALE-CONSTRS">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ScaleConstrs"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="SCALE-CONSTR" type="AR:SCALE-CONSTR">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ScaleConstrs.scaleConstr";pureMM.maxOccurs="-1";pureMM.minOccurs="1";xml.roleElement="true";xml.roleWrapperElement="false";xml.sequenceOffset="20";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class GlobalConstraints::ScaleConstrs -->
   <xsd:complexType abstract="false" mixed="false" name="SCALE-CONSTRS">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ScaleConstrs"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SCALE-CONSTRS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- attribute group for class SpecialData::Sd -->
   <xsd:attributeGroup name="SD">
      <xsd:annotation>
         <xsd:documentation>This class is a "Special Data" element. By using this element it is possible to extend the model with arbirtrary information. In this case the "role" is specified using gid.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Sd"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="GID" type="xsd:NMTOKEN">
         <xsd:annotation>
            <xsd:documentation>This attributes specifies an identifier. Gid comes from the SGML-Term "Generic Identifier" which is the element name in XML. The role of this attribute is the same as the name of an XML - element.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Sd.gid";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class SpecialData::Sd -->
   <xsd:complexType abstract="false" mixed="true" name="SD">
      <xsd:annotation>
         <xsd:documentation>This class is a "Special Data" element. By using this element it is possible to extend the model with arbirtrary information. In this case the "role" is specified using gid.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Sd"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0"/>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:SD"/>
   </xsd:complexType>
   <!-- element group for class SpecialData::Sdg -->
   <xsd:group name="SDG">
      <xsd:annotation>
         <xsd:documentation>Sdg is a generic model which can be used to keep arbitrary information which is not explicitly modeled in the metamodel. Sdg can have various contets as defined by sdgContentsType. Special Data should only be used moderately since all elements should be defined in the metamodel. Thereby SDG should be considered as a temporary solution when no explicit model is available. If an sdgCaption is available, it is possible to establish a reference to the sdg structure.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Sdg"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SDG-CAPTION" type="AR:SDG-CAPTION">
            <xsd:annotation>
               <xsd:documentation>this aggregation allows to assign the properties of Identifiable to the sdg. By this, a shortName etc. can be assigned to the Sdg.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Sdg.sdgCaption";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SDG-CAPTION-REF">
            <xsd:annotation>
               <xsd:documentation>This association allows to reuse an already exisiting caption.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Sdg.sdgCaptionRef";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.name="SDG-CAPTION-REF";xml.sequenceOffset="25"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SDG-CAPTION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:choice maxOccurs="1" minOccurs="0">
            <xsd:group ref="AR:SDG-CONTENTS"/>
         </xsd:choice>
      </xsd:sequence>
   </xsd:group>
   <!-- attribute group for class SpecialData::Sdg -->
   <xsd:attributeGroup name="SDG">
      <xsd:annotation>
         <xsd:documentation>Sdg is a generic model which can be used to keep arbitrary information which is not explicitly modeled in the metamodel. Sdg can have various contets as defined by sdgContentsType. Special Data should only be used moderately since all elements should be defined in the metamodel. Thereby SDG should be considered as a temporary solution when no explicit model is available. If an sdgCaption is available, it is possible to establish a reference to the sdg structure.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Sdg"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="GID" type="xsd:NMTOKEN">
         <xsd:annotation>
            <xsd:documentation>This attributes specifies an identifier. Gid comes from the SGML-Term "Generic Identifier" which is the element name in XML. The role of this attribute is the same as the name of an XML - element.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Sdg.gid";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class SpecialData::Sdg -->
   <xsd:complexType abstract="false" mixed="false" name="SDG">
      <xsd:annotation>
         <xsd:documentation>Sdg is a generic model which can be used to keep arbitrary information which is not explicitly modeled in the metamodel. Sdg can have various contets as defined by sdgContentsType. Special Data should only be used moderately since all elements should be defined in the metamodel. Thereby SDG should be considered as a temporary solution when no explicit model is available. If an sdgCaption is available, it is possible to establish a reference to the sdg structure.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Sdg"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SDG"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:SDG"/>
   </xsd:complexType>
   <!-- complex type for class SpecialData::SdgCaption -->
   <xsd:complexType abstract="false" mixed="false" name="SDG-CAPTION">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SdgCaption"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="SDG-CAPTION--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="SDG-CAPTION"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class SpecialData::SdgContents -->
   <xsd:group name="SDG-CONTENTS">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SdgContents"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixed,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice>
         <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element maxOccurs="unbounded" minOccurs="0" name="SDX" type="AR:SDX">
               <xsd:annotation>
                  <xsd:documentation>This allows to refer to any identifiable object from within an Sdg.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="SdgContents.sdx";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element maxOccurs="unbounded" minOccurs="0" name="SD" type="AR:SD">
               <xsd:annotation>
                  <xsd:documentation>This is one particular special data element.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="SdgContents.sd";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element maxOccurs="unbounded" minOccurs="0" name="SDG" type="AR:SDG">
               <xsd:annotation>
                  <xsd:documentation>This aggregation allows to create an arbitrary structuring  of Sdg.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="SdgContents.sdg";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="50"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
         </xsd:choice>
      </xsd:choice>
   </xsd:group>
   <!-- complex type for class SpecialData::SdgContents -->
   <xsd:complexType abstract="false" mixed="false" name="SDG-CONTENTS">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SdgContents"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixed,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:SDG-CONTENTS"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- attribute group for class SpecialData::Sdx -->
   <xsd:attributeGroup name="SDX">
      <xsd:annotation>
         <xsd:documentation>This is a class which allows to refer to any identifiable object. It could be modeled as an association to Identifiable. But for compatibility reasons to ASAM it is left as it is.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Sdx"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="GID" type="xsd:NMTOKEN">
         <xsd:annotation>
            <xsd:documentation>This attributes specifies an identifier. Gid comes from the SGML-Term "Generic Identifier" which is the element name in XML. The role of this attribute is the same as the name of an XML - element.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Sdx.gid";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="ID-CLASS" type="xsd:string">
         <xsd:annotation>
            <xsd:documentation>This specifies the class of the referenced object.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Sdx.idClass";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class SpecialData::Sdx -->
   <xsd:complexType abstract="false" mixed="true" name="SDX">
      <xsd:annotation>
         <xsd:documentation>This is a class which allows to refer to any identifiable object. It could be modeled as an association to Identifiable. But for compatibility reasons to ASAM it is left as it is.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Sdx"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0"/>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:SDX"/>
   </xsd:complexType>
   <!-- element group for class CoreCommunication::SegmentPosition -->
   <xsd:group name="SEGMENT-POSITION">
      <xsd:annotation>
         <xsd:documentation>The StaticPart and the DynamicPart can be separated in multiple segments within the multiplexed PDU. 

      The ISignalIPdus are copied bit by bit into the MultiplexedIPdu. If the space of the first segment is 5 bits large than the first 5 bits of the ISignalIPdu are copied into this first segment and so on.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SegmentPosition"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SEGMENT-BYTE-ORDER" type="AR:BYTE-ORDER-ENUM">
            <xsd:annotation>
               <xsd:documentation>This attribute defines the order of the bytes of the segment and the packing into the MultiplexedIPdu. The byte ordering "Little Endian" (MostSignificantByteLast) and "Big Endian" (MostSignificantByteFirst) can be selected.

            A mix between Little Endian and Big Endian within a MultiplexedIPdu (staticPart, dynamicPart, selectorField) is not allowed.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SegmentPosition.segmentByteOrder";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SEGMENT-LENGTH" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Data Length of the segment in bits.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SegmentPosition.segmentLength";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SEGMENT-POSITION" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Segments bit position relatively to the beginning of a multiplexed IPdu.

            Note that the absolute position of the segment in the MultiplexedIPdu is determined by the definition of the segmentByteOrder attribute of the SegmentPosition. If Big Endian is specified, the start position indicates the bit position of the most significant bit in the IPdu. If Little Endian is specified, the start position indicates the bit position of the least significant bit in the IPdu.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SegmentPosition.segmentPosition";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::SegmentPosition -->
   <xsd:complexType abstract="false" mixed="false" name="SEGMENT-POSITION">
      <xsd:annotation>
         <xsd:documentation>The StaticPart and the DynamicPart can be separated in multiple segments within the multiplexed PDU. 

      The ISignalIPdus are copied bit by bit into the MultiplexedIPdu. If the space of the first segment is 5 bits large than the first 5 bits of the ISignalIPdu are copied into this first segment and so on.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SegmentPosition"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SEGMENT-POSITION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- complex type for class ApplicationAttributes::SenderAnnotation -->
   <xsd:complexType abstract="false" mixed="false" name="SENDER-ANNOTATION">
      <xsd:annotation>
         <xsd:documentation>Annotation of a sender port, specifying properties of data elements that don't affect communication or generation of the RTE.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SenderAnnotation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:GENERAL-ANNOTATION"/>
         <xsd:group ref="AR:SENDER-RECEIVER-ANNOTATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Communication::SenderComSpec -->
   <xsd:group name="SENDER-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>Communication attributes for a sender port (P-Port and sender-receiver interface).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SenderComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-ELEMENT-REF">
            <xsd:annotation>
               <xsd:documentation>Data element these quality of service attributes apply to.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SenderComSpec.dataElement";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:DATA-ELEMENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TRANSMISSION-ACKNOWLEDGE" type="AR:TRANSMISSION-ACKNOWLEDGEMENT-REQUEST">
            <xsd:annotation>
               <xsd:documentation>Requested transmission acknowledgement for data element.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="transmissionAcknowledge.SenderComSpec";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="USES-END-TO-END-PROTECTION" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>This indicates whether the corresponding dataElement shall be transmitted using end-to-end protection.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SenderComSpec.usesEndToEndProtection";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class DataMapping::SenderRecArrayElementMapping -->
   <xsd:group name="SENDER-REC-ARRAY-ELEMENT-MAPPING">
      <xsd:annotation>
         <xsd:documentation>The ArrayElement may be a primitive one or a composite one. If the element is primitive, it will be mapped to the "SystemSignal" (multiplicity 1).
      If the element is composite, there will be no mapping to the "SystemSignal" (multiplicity 0). In this case the "ArrayElementMapping" Element will aggregate the "TypeMapping" Element. In that way also the composite datatypes can be mapped to SystemSignals. 

      Regardless whether composite or primitive array element is mapped the indexed element always needs to be specified.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SenderRecArrayElementMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPLEX-TYPE-MAPPING">
            <xsd:annotation>
               <xsd:documentation>This aggregation will be used if the element is  composite.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="complexTypeMapping.SenderRecArrayElementMapping";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="SENDER-REC-ARRAY-TYPE-MAPPING" type="AR:SENDER-REC-ARRAY-TYPE-MAPPING"/>
                  <xsd:element name="SENDER-REC-RECORD-TYPE-MAPPING" type="AR:SENDER-REC-RECORD-TYPE-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INDEXED-ARRAY-ELEMENT" type="AR:INDEXED-ARRAY-ELEMENT">
            <xsd:annotation>
               <xsd:documentation>Reference to an indexed array element in the context of the dataElement or in the context of a composite element.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="indexedArrayElement.SenderRecArrayElementMapping";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SIGNAL-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the system signal used to carry the primitive ArrayElement.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SenderRecArrayElementMapping.signal";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SYSTEM-SIGNAL--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataMapping::SenderRecArrayElementMapping -->
   <xsd:complexType abstract="false" mixed="false" name="SENDER-REC-ARRAY-ELEMENT-MAPPING">
      <xsd:annotation>
         <xsd:documentation>The ArrayElement may be a primitive one or a composite one. If the element is primitive, it will be mapped to the "SystemSignal" (multiplicity 1).
      If the element is composite, there will be no mapping to the "SystemSignal" (multiplicity 0). In this case the "ArrayElementMapping" Element will aggregate the "TypeMapping" Element. In that way also the composite datatypes can be mapped to SystemSignals. 

      Regardless whether composite or primitive array element is mapped the indexed element always needs to be specified.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SenderRecArrayElementMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SENDER-REC-ARRAY-ELEMENT-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataMapping::SenderRecArrayTypeMapping -->
   <xsd:group name="SENDER-REC-ARRAY-TYPE-MAPPING">
      <xsd:annotation>
         <xsd:documentation>If the compositeType is an Array, the "ArrayTypeMapping" will be used.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SenderRecArrayTypeMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ARRAY-ELEMENT-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>Each ArrayElement must be mapped on a SystemSignal.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="arrayElementMapping.SenderRecArrayTypeMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SENDER-REC-ARRAY-ELEMENT-MAPPING" type="AR:SENDER-REC-ARRAY-ELEMENT-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataMapping::SenderRecArrayTypeMapping -->
   <xsd:complexType abstract="false" mixed="false" name="SENDER-REC-ARRAY-TYPE-MAPPING">
      <xsd:annotation>
         <xsd:documentation>If the compositeType is an Array, the "ArrayTypeMapping" will be used.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SenderRecArrayTypeMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SENDER-REC-ARRAY-TYPE-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataMapping::SenderRecRecordElementMapping -->
   <xsd:group name="SENDER-REC-RECORD-ELEMENT-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Mapping of a primitive record element to a SystemSignal. 

      If the element is composite, there will be no mapping (multiplicity 0). In this case the "RecordElementMapping" Element will aggregate the "TypeMapping" Element. In that way also the composite datatypes can be mapped to SystemSignals. 

      Regardless whether composite or primitive record element is mapped the record element always needs to be specified.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SenderRecRecordElementMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPLEX-TYPE-MAPPING">
            <xsd:annotation>
               <xsd:documentation>This aggregation will be used if the element is  composite.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="complexTypeMapping.SenderRecRecordElementMapping";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="SENDER-REC-ARRAY-TYPE-MAPPING" type="AR:SENDER-REC-ARRAY-TYPE-MAPPING"/>
                  <xsd:element name="SENDER-REC-RECORD-TYPE-MAPPING" type="AR:SENDER-REC-RECORD-TYPE-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RECORD-ELEMENT-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to a RecordElement in the context of the dataElement or in the context of a composite element.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SenderRecRecordElementMapping.recordElement";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:RECORD-ELEMENT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SIGNAL-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the system signal used to carry the primitive RecordElement.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SenderRecRecordElementMapping.signal";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SYSTEM-SIGNAL--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataMapping::SenderRecRecordElementMapping -->
   <xsd:complexType abstract="false" mixed="false" name="SENDER-REC-RECORD-ELEMENT-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Mapping of a primitive record element to a SystemSignal. 

      If the element is composite, there will be no mapping (multiplicity 0). In this case the "RecordElementMapping" Element will aggregate the "TypeMapping" Element. In that way also the composite datatypes can be mapped to SystemSignals. 

      Regardless whether composite or primitive record element is mapped the record element always needs to be specified.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SenderRecRecordElementMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SENDER-REC-RECORD-ELEMENT-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataMapping::SenderRecRecordTypeMapping -->
   <xsd:group name="SENDER-REC-RECORD-TYPE-MAPPING">
      <xsd:annotation>
         <xsd:documentation>If the compositeType is a Record, the "RecordTypeMapping" will be used.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SenderRecRecordTypeMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="RECORD-ELEMENT-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>Each RecordElement must be mapped on a SystemSignal.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="recordElementMapping.SenderRecRecordTypeMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SENDER-REC-RECORD-ELEMENT-MAPPING" type="AR:SENDER-REC-RECORD-ELEMENT-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataMapping::SenderRecRecordTypeMapping -->
   <xsd:complexType abstract="false" mixed="false" name="SENDER-REC-RECORD-TYPE-MAPPING">
      <xsd:annotation>
         <xsd:documentation>If the compositeType is a Record, the "RecordTypeMapping" will be used.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SenderRecRecordTypeMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SENDER-REC-RECORD-TYPE-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ApplicationAttributes::SenderReceiverAnnotation -->
   <xsd:group name="SENDER-RECEIVER-ANNOTATION">
      <xsd:annotation>
         <xsd:documentation>Annotation of the data elements in a port that realizes a sender/receiver interface.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SenderReceiverAnnotation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPUTED" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Flag whether this data element was not measured directly but instead was calculated from possibly several other measured or calculated values.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SenderReceiverAnnotation.computed";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-ELEMENT-REF">
            <xsd:annotation>
               <xsd:documentation>The instance of data element annotated.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SenderReceiverAnnotation.dataElement";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:DATA-ELEMENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="LIMIT-KIND" type="AR:LIMIT-KIND">
            <xsd:annotation>
               <xsd:documentation>This min or max has not to be mismatched with the min- and max for data-value in a CompuMethod. For example, this annotation shows when the result of the calculation performed in a RunnableEntity owned by one AtomicSoftwareComponentType is transmitted to another AtomicSoftwareComponentType whose RunnableEntity will use this value as a limit, e.g. the max.power which can be used by that software-component, or the current min. slip.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SenderReceiverAnnotation.limitKind";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PROCESSING-KIND" type="AR:PROCESSING-KIND">
            <xsd:annotation>
               <xsd:documentation>This attribute indicates how the data is processed according to the PorcessingKind.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SenderReceiverAnnotation.processingKind";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class PortInterface::SenderReceiverInterface -->
   <xsd:group name="SENDER-RECEIVER-INTERFACE">
      <xsd:annotation>
         <xsd:documentation>A sender/receiver interface declares a number of data elements to be sent and received.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SenderReceiverInterface"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpType</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-ELEMENTS">
            <xsd:annotation>
               <xsd:documentation>The dataelements of this sender/receiver interface.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="dataElement.interface";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="DATA-ELEMENT-PROTOTYPE" type="AR:DATA-ELEMENT-PROTOTYPE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODE-GROUPS">
            <xsd:annotation>
               <xsd:documentation>Modes which may be communicated via this interface.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="modeGroup.interface";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="MODE-DECLARATION-GROUP-PROTOTYPE" type="AR:MODE-DECLARATION-GROUP-PROTOTYPE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class PortInterface::SenderReceiverInterface -->
   <xsd:complexType abstract="false" mixed="false" name="SENDER-RECEIVER-INTERFACE">
      <xsd:annotation>
         <xsd:documentation>A sender/receiver interface declares a number of data elements to be sent and received.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SenderReceiverInterface"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpType</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PORT-INTERFACE"/>
         <xsd:group ref="AR:SENDER-RECEIVER-INTERFACE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class DataMapping::SenderReceiverToSignalGroupMapping -->
   <xsd:group name="SENDER-RECEIVER-TO-SIGNAL-GROUP-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Mapping of a sender receiver communication data element with a composite datatype to a signal group.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SenderReceiverToSignalGroupMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-ELEMENT-IREF" type="AR:SENDER-RECEIVER-TO-SIGNAL-GROUP-MAPPING--DATA-ELEMENT-IREF">
            <xsd:annotation>
               <xsd:documentation>Reference to the data element, which ought to be sent over the Communication bus. 
            Reference to a data element with a composite datatype which is mapped to a signal group.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="dataElement.SenderReceiverToSignalGroupMapping";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SIGNAL-GROUP-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the signal group, which contain all primitive datatypes of the composite type</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SenderReceiverToSignalGroupMapping.signalGroup";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SYSTEM-SIGNAL-GROUP--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TYPE-MAPPING">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="typeMapping.SenderReceiverToSignalGroupMapping";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="SENDER-REC-ARRAY-TYPE-MAPPING" type="AR:SENDER-REC-ARRAY-TYPE-MAPPING"/>
                  <xsd:element name="SENDER-REC-RECORD-TYPE-MAPPING" type="AR:SENDER-REC-RECORD-TYPE-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataMapping::SenderReceiverToSignalGroupMapping -->
   <xsd:complexType abstract="false" mixed="false" name="SENDER-RECEIVER-TO-SIGNAL-GROUP-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Mapping of a sender receiver communication data element with a composite datatype to a signal group.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SenderReceiverToSignalGroupMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SENDER-RECEIVER-TO-SIGNAL-GROUP-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class _instanceRef::SenderReceiverToSignalGroupMapping_dataElement -->
   <xsd:group name="SENDER-RECEIVER-TO-SIGNAL-GROUP-MAPPING--DATA-ELEMENT-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SenderReceiverToSignalGroupMapping_dataElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SOFTWARE-COMPOSITION-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SenderReceiverToSignalGroupMapping_dataElement.softwareComposition";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="10"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SOFTWARE-COMPOSITION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="COMPONENT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SenderReceiverToSignalGroupMapping_dataElement.componentPrototype";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMPONENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PORT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SenderReceiverToSignalGroupMapping_dataElement.portPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="1" name="DATA-ELEMENT-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SenderReceiverToSignalGroupMapping_dataElement.dataElement";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="40"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.target</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:DATA-ELEMENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class _instanceRef::SenderReceiverToSignalGroupMapping_dataElement -->
   <xsd:complexType abstract="false" mixed="false" name="SENDER-RECEIVER-TO-SIGNAL-GROUP-MAPPING--DATA-ELEMENT-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SenderReceiverToSignalGroupMapping_dataElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SENDER-RECEIVER-TO-SIGNAL-GROUP-MAPPING--DATA-ELEMENT-IREF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataMapping::SenderReceiverToSignalMapping -->
   <xsd:group name="SENDER-RECEIVER-TO-SIGNAL-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Mapping of a sender receiver communication data element with a primitive datatype to a signal. 
      If the data element has to be transmitted to several receivers there is still exactly one mapping defined.  In case of 1:n communication the DataElementPrototype in the ProvidePort of the ComponentPrototype is still mapped to only one SystemSignal.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SenderReceiverToSignalMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-ELEMENT-IREF" type="AR:SENDER-RECEIVER-TO-SIGNAL-MAPPING--DATA-ELEMENT-IREF">
            <xsd:annotation>
               <xsd:documentation>Reference to the data element, which ought to be sent over the Communication bus. This DataElement is described in the Software Component Template.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="dataElement.SenderReceiverToSignalMapping";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SIGNAL-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the system signal used to carry the data element.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SenderReceiverToSignalMapping.signal";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SYSTEM-SIGNAL--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataMapping::SenderReceiverToSignalMapping -->
   <xsd:complexType abstract="false" mixed="false" name="SENDER-RECEIVER-TO-SIGNAL-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Mapping of a sender receiver communication data element with a primitive datatype to a signal. 
      If the data element has to be transmitted to several receivers there is still exactly one mapping defined.  In case of 1:n communication the DataElementPrototype in the ProvidePort of the ComponentPrototype is still mapped to only one SystemSignal.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SenderReceiverToSignalMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SENDER-RECEIVER-TO-SIGNAL-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class _instanceRef::SenderReceiverToSignalMapping_dataElement -->
   <xsd:group name="SENDER-RECEIVER-TO-SIGNAL-MAPPING--DATA-ELEMENT-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SenderReceiverToSignalMapping_dataElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SOFTWARE-COMPOSITION-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SenderReceiverToSignalMapping_dataElement.softwareComposition";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="10"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SOFTWARE-COMPOSITION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="COMPONENT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SenderReceiverToSignalMapping_dataElement.componentPrototype";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMPONENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PORT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SenderReceiverToSignalMapping_dataElement.portPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="1" name="DATA-ELEMENT-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SenderReceiverToSignalMapping_dataElement.dataElement";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="40"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.target</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:DATA-ELEMENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class _instanceRef::SenderReceiverToSignalMapping_dataElement -->
   <xsd:complexType abstract="false" mixed="false" name="SENDER-RECEIVER-TO-SIGNAL-MAPPING--DATA-ELEMENT-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SenderReceiverToSignalMapping_dataElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SENDER-RECEIVER-TO-SIGNAL-MAPPING--DATA-ELEMENT-IREF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class SensorActuator::SensorActuatorHW -->
   <xsd:group name="SENSOR-ACTUATOR-HW">
      <xsd:annotation>
         <xsd:documentation>The common attributes for sensors and actuators.
      The sensor and actuators can be connected via a Peripheral HW Port, a Communication HW Port or a Power Driver HW Port.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SensorActuatorHW"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ACCURACY" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Defines the error in the representation of the Technical Signal in the data format
            This applies only if the Technical Signal is encoded before it is transferred to the ECU Electronics (e.g. via Communication Transceiver HW Port).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SensorActuatorHW.accuracy";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CYCLE-TIME" type="AR:TIME-RANGE">
            <xsd:annotation>
               <xsd:documentation>The time the sensor/actuator must be accessed for correct information. It is possible to give a minimum, a maximum and a typical cycle time.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="cycleTime.SensorActuatorHW";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RESOLUTION" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Defines the granularity of the representation of the Technical Signal in the data format.
            This applies only if the Technical Signal is encoded before it is transferred to the ECU Electronics (e.g. via Communication Transceiver HW Port).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SensorActuatorHW.resolution";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TYPE" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Defines the general type of the sensor/actuator type is a most common naming for a sensor/actuator and is an open list and is not restricted to the following items. Several sets of types exist. Type is mandatory for the usage of the template
            - Sensor: Temperature, Pressure, Distance, Hall
            - Actuator: DC Motor, Valve, Relay, Display</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SensorActuatorHW.type";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <xsd:simpleType name="SENSOR-ACTUATOR-HW--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ACTUATOR-HW"/>
         <xsd:enumeration value="DISPLAY-HW"/>
         <xsd:enumeration value="SENSOR-HW"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Components::SensorActuatorSoftwareComponentType -->
   <xsd:group name="SENSOR-ACTUATOR-SOFTWARE-COMPONENT-TYPE">
      <xsd:annotation>
         <xsd:documentation>The SensorActuatorSoftwareComponentType introduces the possibility to link from the software representation of a sensor/actuator to its hardware description provided by the ECU Resource Template.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SensorActuatorSoftwareComponentType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpType</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SENSOR-ACTUATOR-REF">
            <xsd:annotation>
               <xsd:documentation>Reference from the Sensor Actuator Software Component Type to the description of the actual hardware.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SensorActuatorSoftwareComponentType.sensorActuator";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SENSOR-ACTUATOR-HW--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Components::SensorActuatorSoftwareComponentType -->
   <xsd:complexType abstract="false" mixed="false" name="SENSOR-ACTUATOR-SOFTWARE-COMPONENT-TYPE">
      <xsd:annotation>
         <xsd:documentation>The SensorActuatorSoftwareComponentType introduces the possibility to link from the software representation of a sensor/actuator to its hardware description provided by the ECU Resource Template.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SensorActuatorSoftwareComponentType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpType</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COMPONENT-TYPE"/>
         <xsd:group ref="AR:SENSOR-ACTUATOR-SOFTWARE-COMPONENT-TYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class SensorActuator::SensorHW -->
   <xsd:group name="SENSOR-HW">
      <xsd:annotation>
         <xsd:documentation>HW Element Sensor definition.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SensorHW"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SIGNAL-QUALITY" type="AR:SENSOR-HW-SIGNAL-QUALITY-ENUM">
            <xsd:annotation>
               <xsd:documentation>Defines the quality of the data received from a sensor. Depending on this information later processing on the signal has to be done in HW or SW.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SensorHW.signalQuality";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SensorActuator::SensorHW -->
   <xsd:complexType abstract="false" mixed="false" name="SENSOR-HW">
      <xsd:annotation>
         <xsd:documentation>HW Element Sensor definition.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SensorHW"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HW-ELEMENT"/>
         <xsd:group ref="AR:SENSOR-ACTUATOR-HW"/>
         <xsd:group ref="AR:SENSOR-HW"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class SignalPaths::SeparateSignalPath -->
   <xsd:group name="SEPARATE-SIGNAL-PATH">
      <xsd:annotation>
         <xsd:documentation>The SeparateSignalPath describes that two SwcToSwcSignals and/or SwcToSwcOperationArguments must not take the same way (Signal Path) in the topology (e.g. Redundancy).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SeparateSignalPath"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="OPERATIONS">
            <xsd:annotation>
               <xsd:documentation>The SwcToSwcOperationArguments that must not take the same way (Signal Path) in the topology.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="operation.SeparateSignalPath";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SWC-TO-SWC-OPERATION-ARGUMENTS" type="AR:SWC-TO-SWC-OPERATION-ARGUMENTS"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SIGNALS">
            <xsd:annotation>
               <xsd:documentation>The SwcToSwcSignals that must not take the same way (Signal Path) in the topology.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="signal.SeparateSignalPath";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SWC-TO-SWC-SIGNAL" type="AR:SWC-TO-SWC-SIGNAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SignalPaths::SeparateSignalPath -->
   <xsd:complexType abstract="false" mixed="false" name="SEPARATE-SIGNAL-PATH">
      <xsd:annotation>
         <xsd:documentation>The SeparateSignalPath describes that two SwcToSwcSignals and/or SwcToSwcOperationArguments must not take the same way (Signal Path) in the topology (e.g. Redundancy).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SeparateSignalPath"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SEPARATE-SIGNAL-PATH"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataMapping::SequenceCounterMapping -->
   <xsd:group name="SEQUENCE-COUNTER-MAPPING">
      <xsd:annotation>
         <xsd:documentation>The purpose of sequence counters is to map a response to the correct request of a known client.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SequenceCounterMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYSTEM-SIGNAL-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the SystemSignal with the SequenceCounter.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SequenceCounterMapping.systemSignal";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SYSTEM-SIGNAL--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataMapping::SequenceCounterMapping -->
   <xsd:complexType abstract="false" mixed="false" name="SEQUENCE-COUNTER-MAPPING">
      <xsd:annotation>
         <xsd:documentation>The purpose of sequence counters is to map a response to the correct request of a known client.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SequenceCounterMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SEQUENCE-COUNTER-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ServerCall::ServerCallPoint -->
   <xsd:group name="SERVER-CALL-POINT">
      <xsd:annotation>
         <xsd:documentation>When a runnable has a serverCallPoint, it has the possibility to invoke any of the operations of a specific rport of the component.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ServerCallPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="OPERATION-IREFS">
            <xsd:annotation>
               <xsd:documentation>The operation that is called by this runnable.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="operation.ServerCallPoint";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.roleWrapperElement="true"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="OPERATION-IREF" type="AR:SERVER-CALL-POINT--OPERATION-IREF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMEOUT" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Time in seconds before the server call times out and returns with an error message. It depends on the call type (synchronous or asynchronous) how this is reported.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ServerCallPoint.timeout";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class _instanceRef::ServerCallPoint_operation -->
   <xsd:group name="SERVER-CALL-POINT--OPERATION-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ServerCallPoint_operation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="R-PORT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ServerCallPoint_operation.rPortPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="10"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:R-PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="1" name="OPERATION-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ServerCallPoint_operation.operationPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.target</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:OPERATION-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class _instanceRef::ServerCallPoint_operation -->
   <xsd:complexType abstract="false" mixed="false" name="SERVER-CALL-POINT--OPERATION-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ServerCallPoint_operation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SERVER-CALL-POINT--OPERATION-IREF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Communication::ServerComSpec -->
   <xsd:group name="SERVER-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>Communication attributes for a server port (P-Port and client-server interface).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ServerComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="OPERATION-REF">
            <xsd:annotation>
               <xsd:documentation>Operation these communication attributes apply to.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ServerComSpec.operation";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:OPERATION-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="QUEUE-LENGTH" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Length of call queue on the server side. The queue is implemented by the RTE.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ServerComSpec.queueLength";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Communication::ServerComSpec -->
   <xsd:complexType abstract="false" mixed="false" name="SERVER-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>Communication attributes for a server port (P-Port and client-server interface).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ServerComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SERVER-COM-SPEC"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Services::ServiceComponentPrototype -->
   <xsd:group name="SERVICE-COMPONENT-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>Each service in an ECU is represented by exactly one ServiceComponentPrototype. Instances of this class are only to be created in ECU Configuration phase for the specific purpose of the service configuration.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ServiceComponentPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SERVICE-COMPONENT-TREF">
            <xsd:annotation>
               <xsd:documentation>This represents the ServiceComponentType used to type the ServiceComponentPrototype.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ServiceComponentPrototype.serviceComponent";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">isOfType</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SERVICE-COMPONENT-TYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Services::ServiceComponentPrototype -->
   <xsd:complexType abstract="false" mixed="false" name="SERVICE-COMPONENT-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>Each service in an ECU is represented by exactly one ServiceComponentPrototype. Instances of this class are only to be created in ECU Configuration phase for the specific purpose of the service configuration.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ServiceComponentPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SERVICE-COMPONENT-PROTOTYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="SERVICE-COMPONENT-PROTOTYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="SERVICE-COMPONENT-PROTOTYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Components::ServiceComponentType -->
   <xsd:group name="SERVICE-COMPONENT-TYPE">
      <xsd:annotation>
         <xsd:documentation>ServiceComponentType is used for configuring services for a given ECU. Instances of this class are only to be created in ECU Configuration phase for the specific purpose of the service configuration.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ServiceComponentType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpType</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BSW-MODULE-DESCRIPTION-REFS">
            <xsd:annotation>
               <xsd:documentation>Reference from the ServiceComponentType to the Basic Software Module Description describing the BSW part of the Service Component.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ServiceComponentType.bswModuleDescription";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="BSW-MODULE-DESCRIPTION-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:BSW-MODULE-DESCRIPTION--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Components::ServiceComponentType -->
   <xsd:complexType abstract="false" mixed="false" name="SERVICE-COMPONENT-TYPE">
      <xsd:annotation>
         <xsd:documentation>ServiceComponentType is used for configuring services for a given ECU. Instances of this class are only to be created in ECU Configuration phase for the specific purpose of the service configuration.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ServiceComponentType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpType</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COMPONENT-TYPE"/>
         <xsd:group ref="AR:SERVICE-COMPONENT-TYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="SERVICE-COMPONENT-TYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="SERVICE-COMPONENT-TYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Composition::ServiceConnectorPrototype -->
   <xsd:group name="SERVICE-CONNECTOR-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>A ServiceConnectorPrototype connects a PortPrototype owned by an ComponentPrototype
      with the service PortPrototype owned by the ServiceComponentPrototype. A ServiceConnectorPrototype is only added to the model in ECU Configuration phase for the specific purpose of configuring services within an EcuSwComposition.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ServiceConnectorPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpStructureElement</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="APPLICATION-PORT-IREF" type="AR:SERVICE-CONNECTOR-PROTOTYPE--APPLICATION-PORT-IREF">
            <xsd:annotation>
               <xsd:documentation>Service port to be connected on application component side</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="applicationPort.ServiceConnectorPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SERVICE-PORT-IREF" type="AR:SERVICE-CONNECTOR-PROTOTYPE--SERVICE-PORT-IREF">
            <xsd:annotation>
               <xsd:documentation>Service port to be connected on service component side</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="servicePort.ServiceConnectorPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Composition::ServiceConnectorPrototype -->
   <xsd:complexType abstract="false" mixed="false" name="SERVICE-CONNECTOR-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>A ServiceConnectorPrototype connects a PortPrototype owned by an ComponentPrototype
      with the service PortPrototype owned by the ServiceComponentPrototype. A ServiceConnectorPrototype is only added to the model in ECU Configuration phase for the specific purpose of configuring services within an EcuSwComposition.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ServiceConnectorPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpStructureElement</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SERVICE-CONNECTOR-PROTOTYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class _instanceRef::ServiceConnectorPrototype_applicationPort -->
   <xsd:group name="SERVICE-CONNECTOR-PROTOTYPE--APPLICATION-PORT-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ServiceConnectorPrototype_applicationPort"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SOFTWARE-COMPOSITION-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ServiceConnectorPrototype_applicationPort.softwareComposition";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="10"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SOFTWARE-COMPOSITION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="COMPONENT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ServiceConnectorPrototype_applicationPort.componentPrototype";pureMM.maxOccurs="-1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMPONENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="1" name="PORT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ServiceConnectorPrototype_applicationPort.portPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.target</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class _instanceRef::ServiceConnectorPrototype_applicationPort -->
   <xsd:complexType abstract="false" mixed="false" name="SERVICE-CONNECTOR-PROTOTYPE--APPLICATION-PORT-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ServiceConnectorPrototype_applicationPort"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SERVICE-CONNECTOR-PROTOTYPE--APPLICATION-PORT-IREF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class _instanceRef::ServiceConnectorPrototype_servicePort -->
   <xsd:group name="SERVICE-CONNECTOR-PROTOTYPE--SERVICE-PORT-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ServiceConnectorPrototype_servicePort"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SERVICE-COMPONENT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ServiceConnectorPrototype_servicePort.serviceComponentPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="10"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SERVICE-COMPONENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="1" name="PORT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ServiceConnectorPrototype_servicePort.portPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.target</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class _instanceRef::ServiceConnectorPrototype_servicePort -->
   <xsd:complexType abstract="false" mixed="false" name="SERVICE-CONNECTOR-PROTOTYPE--SERVICE-PORT-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ServiceConnectorPrototype_servicePort"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SERVICE-CONNECTOR-PROTOTYPE--SERVICE-PORT-IREF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- complex type for class ServiceNeeds::ServiceNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="SERVICE-NEEDS">
      <xsd:annotation>
         <xsd:documentation>This expresses the abstract needs that a Software Component or Basic Software Module has on the configuration of an AUTOSAR Service to which it will be connected. "Abstract needs" means, that the model abstracts from the Configuration Paramaters of the underlying Basic Software.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="ServiceNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class CoreCommunication::SignalIPdu -->
   <xsd:group name="SIGNAL-I-PDU">
      <xsd:annotation>
         <xsd:documentation>Represents the I-PDU's handled by Com. 
      The SignalIPdu assembled and disassembled in AUTOSAR COM consists of one or more signals.

      In case no multiplexing is performed this IPdu is routed to/from the Interface Layer.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SignalIPdu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="I-PDU-TIMING-SPECIFICATION" type="AR:I-PDU-TIMING">
            <xsd:annotation>
               <xsd:documentation>Timing specification for Com IPdus (Transmission Modes).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="iPduTimingSpecification.SignalIPdu";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SIGNAL-TO-PDU-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>Definition of SignalToIPduMappings included in the SignalIPdu.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="signalToPduMapping.SignalIPdu";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="I-SIGNAL-TO-I-PDU-MAPPING" type="AR:I-SIGNAL-TO-I-PDU-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::SignalIPdu -->
   <xsd:complexType abstract="false" mixed="false" name="SIGNAL-I-PDU">
      <xsd:annotation>
         <xsd:documentation>Represents the I-PDU's handled by Com. 
      The SignalIPdu assembled and disassembled in AUTOSAR COM consists of one or more signals.

      In case no multiplexing is performed this IPdu is routed to/from the Interface Layer.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SignalIPdu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:I-PDU"/>
         <xsd:group ref="AR:SIGNAL-I-PDU"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="SIGNAL-I-PDU--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="SIGNAL-I-PDU"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Fibex4Multiplatform::SignalMapping -->
   <xsd:group name="SIGNAL-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Arranges those signals that are transferred by the gateway from one channel to the other in pairs and defines the mapping between them.
      Each pair consists in a source and a target referencing to a ISignalTriggering.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SignalMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SOURCE-SIGNAL-REF">
            <xsd:annotation>
               <xsd:documentation>Source destination of the referencing mapping.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SignalMapping.sourceSignal";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:I-SIGNAL-TRIGGERING--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TARGET-SIGNAL-REF">
            <xsd:annotation>
               <xsd:documentation>Target destination of the referencing mapping.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SignalMapping.targetSignal";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:I-SIGNAL-TRIGGERING--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Fibex4Multiplatform::SignalMapping -->
   <xsd:complexType abstract="false" mixed="false" name="SIGNAL-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Arranges those signals that are transferred by the gateway from one channel to the other in pairs and defines the mapping between them.
      Each pair consists in a source and a target referencing to a ISignalTriggering.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SignalMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SIGNAL-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CoreCommunication::SignalPort -->
   <xsd:group name="SIGNAL-PORT">
      <xsd:annotation>
         <xsd:documentation>Connectors reception or send port on the referenced channel referenced by an ISignalTriggering.

      If different timeouts or DataFilters for ISignals need to be specified several ISignalPorts may be created.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SignalPort"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-FILTER">
            <xsd:annotation>
               <xsd:documentation>Optional specification of  a signal COM filter at the receiver side in case that  the System Description doesn't use a complete Software Component Description (VFB View). This supports the inclusion of legacy system signals. If a full DataMapping exist for the SystemSignal this information may be available from a configured ReceiverComSpec. In this case the ReceiverComSpec overrides this optional specification.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="dataFilter.SignalPort";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="ALWAYS" type="AR:ALWAYS"/>
                  <xsd:element name="MASKED-NEW-DIFFERS-MASKED-OLD" type="AR:MASKED-NEW-DIFFERS-MASKED-OLD"/>
                  <xsd:element name="MASKED-NEW-DIFFERS-X" type="AR:MASKED-NEW-DIFFERS-X"/>
                  <xsd:element name="MASKED-NEW-EQUALS-X" type="AR:MASKED-NEW-EQUALS-X"/>
                  <xsd:element name="NEVER" type="AR:NEVER"/>
                  <xsd:element name="NEW-IS-OUTSIDE" type="AR:NEW-IS-OUTSIDE"/>
                  <xsd:element name="NEW-IS-WITHIN" type="AR:NEW-IS-WITHIN"/>
                  <xsd:element name="ONE-EVERY-N" type="AR:ONE-EVERY-N"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMEOUT" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Optional timeout value in seconds for the reception of the ISignal.
            In case the System Description doesn't use a complete Software Component Description (VFB View). This supports the inclusion of legacy system signals.

            If a full DataMapping exist for the SystemSignal this information may be available from a configured ReceiverComSpec, in this case the timeout value in ReceiverComSpec override this optional timeout specification.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SignalPort.timeout";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::SignalPort -->
   <xsd:complexType abstract="false" mixed="false" name="SIGNAL-PORT">
      <xsd:annotation>
         <xsd:documentation>Connectors reception or send port on the referenced channel referenced by an ISignalTriggering.

      If different timeouts or DataFilters for ISignals need to be specified several ISignalPorts may be created.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SignalPort"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COMM-CONNECTOR-PORT"/>
         <xsd:group ref="AR:SIGNAL-PORT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="SIGNAL-PORT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="SIGNAL-PORT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ECUResourceTemplate::SignalTransformation -->
   <xsd:group name="SIGNAL-TRANSFORMATION">
      <xsd:annotation>
         <xsd:documentation>The Signal Transformation defines the conversion of the signal attached to a HW Port (direction In) and a signal attached to a HW Port (direction Out).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SignalTransformation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="INPUT-HW-PORT-REFS">
            <xsd:annotation>
               <xsd:documentation>The input port the signal transformation is refering to.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SignalTransformation.inputHwPort";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="INPUT-HW-PORT-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:HW-PORT--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="OUTPUT-HW-PORT-REFS">
            <xsd:annotation>
               <xsd:documentation>The output port the signal transformation is refering to.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SignalTransformation.outputHwPort";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="OUTPUT-HW-PORT-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:HW-PORT--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUResourceTemplate::SignalTransformation -->
   <xsd:complexType abstract="false" mixed="false" name="SIGNAL-TRANSFORMATION">
      <xsd:annotation>
         <xsd:documentation>The Signal Transformation defines the conversion of the signal attached to a HW Port (direction In) and a signal attached to a HW Port (direction Out).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SignalTransformation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SIGNAL-TRANSFORMATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ExecutionTime::SimulatedExecutionTime -->
   <xsd:group name="SIMULATED-EXECUTION-TIME">
      <xsd:annotation>
         <xsd:documentation>Specifies the ExecutionTime which has been gathered using simulation means.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SimulatedExecutionTime"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="AVERAGE-EXECUTION-TIME" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Average SimulatedExecutionTime.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SimulatedExecutionTime.averageExecutionTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAXIMAL-EXECUTION-TIME" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Maximum SimulatedExecutionTime.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SimulatedExecutionTime.maximalExecutionTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MINIMAL-EXECUTION-TIME" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Minimum SimulatedExecutionTime.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SimulatedExecutionTime.minimalExecutionTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ExecutionTime::SimulatedExecutionTime -->
   <xsd:complexType abstract="false" mixed="false" name="SIMULATED-EXECUTION-TIME">
      <xsd:annotation>
         <xsd:documentation>Specifies the ExecutionTime which has been gathered using simulation means.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SimulatedExecutionTime"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:EXECUTION-TIME"/>
         <xsd:group ref="AR:SIMULATED-EXECUTION-TIME"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- complex type for class SingleLanguageData::SlData1 -->
   <xsd:complexType abstract="false" mixed="true" name="SL-DATA-1">
      <xsd:annotation>
         <xsd:documentation>SingleLanguageParagraph

      This is the content model of a single language paragraph in a documentation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SlData1"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:MIXED-CONTENT-1"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- complex type for class SingleLanguageData::SlData10 -->
   <xsd:complexType abstract="false" mixed="true" name="SL-DATA-10">
      <xsd:annotation>
         <xsd:documentation>SingleLanguagePlainText</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SlData10"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0"/>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- complex type for class SingleLanguageData::SlData2 -->
   <xsd:complexType abstract="false" mixed="true" name="SL-DATA-2">
      <xsd:annotation>
         <xsd:documentation>SingleLanguageOverviewParagraph

      This is the model for a single language paragraph in an overview item.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SlData2"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0"/>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- complex type for class SingleLanguageData::SlData3 -->
   <xsd:complexType abstract="false" mixed="true" name="SL-DATA-3">
      <xsd:annotation>
         <xsd:documentation>SingleLanguageUnitName</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SlData3"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0"/>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- attribute group for class SingleLanguageData::SlData3p -->
   <xsd:attributeGroup name="SL-DATA-3-P">
      <xsd:annotation>
         <xsd:documentation>SingleLanguageUnitNameVerbatim</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SlData3p"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="XMLSPACE" type="xsd:string">
         <xsd:annotation>
            <xsd:appinfo source="tags">mmt.qualifiedName="SlData3p.xml:space";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class SingleLanguageData::SlData3p -->
   <xsd:complexType abstract="false" mixed="true" name="SL-DATA-3-P">
      <xsd:annotation>
         <xsd:documentation>SingleLanguageUnitNameVerbatim</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SlData3p"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0"/>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:SL-DATA-3-P"/>
   </xsd:complexType>
   <!-- complex type for class SingleLanguageData::SlData4 -->
   <xsd:complexType abstract="false" mixed="true" name="SL-DATA-4">
      <xsd:annotation>
         <xsd:documentation>SingleLanguageLongName</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SlData4"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0"/>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- attribute group for class SingleLanguageData::SlData5 -->
   <xsd:attributeGroup name="SL-DATA-5">
      <xsd:annotation>
         <xsd:documentation>SingleLanguageVerbatim</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SlData5"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="ALLOW-BREAK" type="xsd:string">
         <xsd:annotation>
            <xsd:appinfo source="tags">mmt.qualifiedName="SlData5.allowBreak";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="FLOAT" type="xsd:string">
         <xsd:annotation>
            <xsd:appinfo source="tags">mmt.qualifiedName="SlData5.float";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="HELP-ENTRY" type="xsd:string">
         <xsd:annotation>
            <xsd:appinfo source="tags">mmt.qualifiedName="SlData5.helpEntry";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="KEEP-WITH-PREVIOUS" type="xsd:string">
         <xsd:annotation>
            <xsd:appinfo source="tags">mmt.qualifiedName="SlData5.keepWithPrevious";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="PGWIDE" type="xsd:string">
         <xsd:annotation>
            <xsd:appinfo source="tags">mmt.qualifiedName="SlData5.pgwide";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="XMLSPACE" type="xsd:string">
         <xsd:annotation>
            <xsd:appinfo source="tags">mmt.qualifiedName="SlData5.xml:space";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class SingleLanguageData::SlData5 -->
   <xsd:complexType abstract="false" mixed="true" name="SL-DATA-5">
      <xsd:annotation>
         <xsd:documentation>SingleLanguageVerbatim</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SlData5"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0"/>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:SL-DATA-5"/>
   </xsd:complexType>
   <!-- element group for class SystemTemplate::SoftwareComposition -->
   <xsd:group name="SOFTWARE-COMPOSITION">
      <xsd:annotation>
         <xsd:documentation>The Top-level software composition, containing all software components in the System in a hierarchical structure. The contained ComponentPrototypes are fully specified by their ComponentTypes (including PortPrototypes, PortInterfaces, DataElementPrototypes, InternalBehavior etc.), and their ports are interconnected using ConnectorPrototypes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SoftwareComposition"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SOFTWARE-COMPOSITION-TREF">
            <xsd:annotation>
               <xsd:documentation>We assume that there is exactly one top-level composition that includes all  Component instances  of the system</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SoftwareComposition.softwareComposition";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">isOfType</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMPOSITION-TYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SystemTemplate::SoftwareComposition -->
   <xsd:complexType abstract="false" mixed="false" name="SOFTWARE-COMPOSITION">
      <xsd:annotation>
         <xsd:documentation>The Top-level software composition, containing all software components in the System in a hierarchical structure. The contained ComponentPrototypes are fully specified by their ComponentTypes (including PortPrototypes, PortInterfaces, DataElementPrototypes, InternalBehavior etc.), and their ports are interconnected using ConnectorPrototypes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SoftwareComposition"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SOFTWARE-COMPOSITION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="SOFTWARE-COMPOSITION--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="SOFTWARE-COMPOSITION"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ResourceConsumption::SoftwareContext -->
   <xsd:group name="SOFTWARE-CONTEXT">
      <xsd:annotation>
         <xsd:documentation>Specifes the context the software is whose ExecutionTime is provided.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SoftwareContext"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="INPUT" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Specifies the input vector which is used to provide the ExecutionTime.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SoftwareContext.input";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="STATE" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Specifies the state the software is in when the ExecutionTime is provided.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SoftwareContext.state";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ResourceConsumption::SoftwareContext -->
   <xsd:complexType abstract="false" mixed="false" name="SOFTWARE-CONTEXT">
      <xsd:annotation>
         <xsd:documentation>Specifes the context the software is whose ExecutionTime is provided.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SoftwareContext"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SOFTWARE-CONTEXT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Fibex4Multiplatform::SourceIPduRef -->
   <xsd:group name="SOURCE-I-PDU-REF">
      <xsd:annotation>
         <xsd:documentation>Source destination of the referencing mapping.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SourceIPduRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DEFAULT-VALUE" type="AR:PDU-MAPPING-DEFAULT-VALUE">
            <xsd:annotation>
               <xsd:documentation>If no I-Pdu has been received a default value will be distributed.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="defaultValue.SourceIPduRef";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SOURCE-I-PDU-REF">
            <xsd:annotation>
               <xsd:documentation>IPdu Reference</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SourceIPduRef.sourceIPdu";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:I-PDU-TRIGGERING--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Fibex4Multiplatform::SourceIPduRef -->
   <xsd:complexType abstract="false" mixed="false" name="SOURCE-I-PDU-REF">
      <xsd:annotation>
         <xsd:documentation>Source destination of the referencing mapping.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SourceIPduRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SOURCE-I-PDU-REF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class StackUsage::StackUsage -->
   <xsd:group name="STACK-USAGE">
      <xsd:annotation>
         <xsd:documentation>Describes the stack memory usage of a software.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="StackUsage"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECU-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the ECU description this implementation is provided for.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="StackUsage.ecu";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ECU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="HARDWARE-CONFIGURATION" type="AR:HARDWARE-CONFIGURATION">
            <xsd:annotation>
               <xsd:documentation>Contains information about the hardware context this stack usage is describing.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="hardwareConfiguration.StackUsage";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RUNNABLE-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the runnable this stack usage is provided for.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="StackUsage.runnable";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:EXECUTABLE-ENTITY--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SOFTWARE-CONTEXT" type="AR:SOFTWARE-CONTEXT">
            <xsd:annotation>
               <xsd:documentation>Contains details about the software context this stack usage is provided for.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="softwareContext.StackUsage";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class CoreCommunication::StaticPart -->
   <xsd:group name="STATIC-PART">
      <xsd:annotation>
         <xsd:documentation>Some parts/signals of the I-PDU may be the same regardless of the selector field. Such a part is called static part. The static part is optional.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="StaticPart"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="I-PDU-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to a Com IPdu which is routed to the IPduM module and is combined to a multiplexedPdu.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="StaticPart.iPdu";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SIGNAL-I-PDU--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::StaticPart -->
   <xsd:complexType abstract="false" mixed="false" name="STATIC-PART">
      <xsd:annotation>
         <xsd:documentation>Some parts/signals of the I-PDU may be the same regardless of the selector field. Such a part is called static part. The static part is optional.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="StaticPart"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:MULTIPLEXED-PART"/>
         <xsd:group ref="AR:STATIC-PART"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- complex type for class Inlines::Std -->
   <xsd:complexType abstract="false" mixed="false" name="STD">
      <xsd:annotation>
         <xsd:documentation>Use &lt;std&gt; to reference external standards within a paragraph element.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Std"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Constants::StringLiteral -->
   <xsd:group name="STRING-LITERAL">
      <xsd:annotation>
         <xsd:documentation>A constant string.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="StringLiteral"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VALUE" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>The string itself.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="StringLiteral.value";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Constants::StringLiteral -->
   <xsd:complexType abstract="false" mixed="false" name="STRING-LITERAL">
      <xsd:annotation>
         <xsd:documentation>A constant string.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="StringLiteral"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpPrototype</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:DATA-PROTOTYPE"/>
         <xsd:group ref="AR:STRING-LITERAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUCParameterDefTemplate::StringParamDef -->
   <xsd:group name="STRING-PARAM-DEF">
      <xsd:annotation>
         <xsd:documentation>Configuration parameter type for String.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="StringParamDef";xml.sequenceOffset="0"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DEFAULT-VALUE" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Default value of the string configuration parameter.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="StringParamDef.defaultValue";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCParameterDefTemplate::StringParamDef -->
   <xsd:complexType abstract="false" mixed="false" name="STRING-PARAM-DEF">
      <xsd:annotation>
         <xsd:documentation>Configuration parameter type for String.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="StringParamDef";xml.sequenceOffset="0"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PARAM-CONF-MULTIPLICITY"/>
         <xsd:group ref="AR:COMMON-CONFIGURATION-ATTRIBUTES"/>
         <xsd:group ref="AR:CONFIG-PARAMETER"/>
         <xsd:group ref="AR:STRING-PARAM-DEF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Datatypes::StringType -->
   <xsd:group name="STRING-TYPE">
      <xsd:annotation>
         <xsd:documentation>This represents a string of characters out of the character-set specified by the given encoding.
      The maxNumberOfChars is the maximal number of characters which can be stored within the String. The actual number of bytes that is required to represent the string can be calculated out of maxNumberOfChars and the encoding:

      bytes required to represent the string =
      maxNumberOfChars * (max bytes per character using the given encoding) + 1 (terminating null)</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="StringType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpType</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ENCODING" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Specification of character encoding, e. g. ISO-8859-1.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="StringType.encoding";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-NUMBER-OF-CHARS" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The maxNumberOfChars is the maximum number of characters that can be stored in the string.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="StringType.maxNumberOfChars";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Datatypes::StringType -->
   <xsd:complexType abstract="false" mixed="false" name="STRING-TYPE">
      <xsd:annotation>
         <xsd:documentation>This represents a string of characters out of the character-set specified by the given encoding.
      The maxNumberOfChars is the maximal number of characters which can be stored within the String. The actual number of bytes that is required to represent the string can be calculated out of maxNumberOfChars and the encoding:

      bytes required to represent the string =
      maxNumberOfChars * (max bytes per character using the given encoding) + 1 (terminating null)</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="StringType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpType</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PRIMITIVE-TYPE"/>
         <xsd:group ref="AR:STRING-TYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ECUCDescriptionTemplate::StringValue -->
   <xsd:group name="STRING-VALUE">
      <xsd:annotation>
         <xsd:documentation>Representing a configuration value of definition type StringParamDef</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="StringValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VALUE" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Stores the value of the String parameter.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="StringValue.value";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ECUCDescriptionTemplate::StringValue -->
   <xsd:complexType abstract="false" mixed="false" name="STRING-VALUE">
      <xsd:annotation>
         <xsd:documentation>Representing a configuration value of definition type StringParamDef</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="StringValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:PARAMETER-VALUE"/>
         <xsd:group ref="AR:STRING-VALUE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class LinCommunication::SubstitutionFrame -->
   <xsd:group name="SUBSTITUTION-FRAME">
      <xsd:annotation>
         <xsd:documentation>A LIN specific extension of the common FRAME to enable the usual frame handling of a placeholder frame that is substituted at runtime. Substitution frame must not declare signal instances nor multiplexers.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SubstitutionFrame"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpStructureElement,atpType</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SUBSTITUTED-FRAME-REFS">
            <xsd:annotation>
               <xsd:documentation>Collecting the frames that are substituted by the refering one. 
            This reference is ordered. The order is used to describe the priority (Configuration parameter LinIfFramePriority). The first listed Substitution Frame has the highest priority.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SubstitutionFrame.substitutedFrame";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SUBSTITUTED-FRAME-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:FRAME--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SUBSTITUTION-TYPE" type="AR:SUBSTITUTION-TYPE">
            <xsd:annotation>
               <xsd:documentation>The type of substitution. Substitution frames can either be used for event triggered or for sporadic frames.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SubstitutionFrame.substitutionType";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class LinCommunication::SubstitutionFrame -->
   <xsd:complexType abstract="false" mixed="false" name="SUBSTITUTION-FRAME">
      <xsd:annotation>
         <xsd:documentation>A LIN specific extension of the common FRAME to enable the usual frame handling of a placeholder frame that is substituted at runtime. Substitution frame must not declare signal instances nor multiplexers.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SubstitutionFrame"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpStructureElement,atpType</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:FRAME"/>
         <xsd:group ref="AR:SUBSTITUTION-FRAME"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ServiceNeeds::SupervisedEntityNeeds -->
   <xsd:group name="SUPERVISED-ENTITY-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs on the configuration of the Watchdog Manager for one specific Supervised Entity (SE).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SupervisedEntityNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ACTIVATE-AT-START" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>true/false: supervision activation status of SE shall be enabled/disabled at start</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SupervisedEntityNeeds.activateAtStart";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ENABLE-DEACTIVATION" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>true: SWC shall be allowed to deactivate supervision of this SE
            false: not</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SupervisedEntityNeeds.enableDeactivation";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EXPECTED-ALIVE-CYCLE" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Expected cycle time of alive trigger of this SE (in seconds)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SupervisedEntityNeeds.expectedAliveCycle";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX-ALIVE-CYCLE" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Maximum cycle time of alive trigger of this SE (in seconds)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SupervisedEntityNeeds.maxAliveCycle";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MIN-ALIVE-CYCLE" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Minimum cycle time of alive trigger of this SE (in seconds)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SupervisedEntityNeeds.minAliveCycle";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TOLERATED-FAILED-CYCLES" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Number of consecutive failed alive cycles for this SE which shall be tolerated until the supervision status of the SE is set to EXPIRED (see WdgM documentation for details). Note that this has to be recalculated w.r.t. the WdgMs own cycle time for ECU configuration.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SupervisedEntityNeeds.toleratedFailedCycles";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceNeeds::SupervisedEntityNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="SUPERVISED-ENTITY-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specifies the abstract needs on the configuration of the Watchdog Manager for one specific Supervised Entity (SE).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SupervisedEntityNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SUPERVISED-ENTITY-NEEDS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ProcessingUnit::SupportedDataType -->
   <xsd:group name="SUPPORTED-DATA-TYPE">
      <xsd:annotation>
         <xsd:documentation>This element provides a list of all supported data types and its according data sizes of the described PU.
      Examples: Boolean (1, 8 bit), Bit String / Bit Field (x bit), Character (8, 16 bit), Signed / unsigned integer (8, 16, 24, 32, 48, 64 bit), Single / double float (56, 64 bit), Fixed point (24 bit), Fractional, Packed (two values handled in one register)</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SupportedDataType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SUPPORTED-DATA-SIZES">
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element maxOccurs="unbounded" minOccurs="0" name="SUPPORTED-DATA-SIZE" type="xsd:integer">
                     <xsd:annotation>
                        <xsd:documentation>The size of the data type.
                     Unit: Bit</xsd:documentation>
                        <xsd:appinfo source="tags">mmt.qualifiedName="SupportedDataType.supportedDataSize";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
                     </xsd:annotation>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ProcessingUnit::SupportedDataType -->
   <xsd:complexType abstract="false" mixed="false" name="SUPPORTED-DATA-TYPE">
      <xsd:annotation>
         <xsd:documentation>This element provides a list of all supported data types and its according data sizes of the described PU.
      Examples: Boolean (1, 8 bit), Bit String / Bit Field (x bit), Character (8, 16 bit), Signed / unsigned integer (8, 16, 24, 32, 48, 64 bit), Single / double float (56, 64 bit), Fixed point (24 bit), Fractional, Packed (two values handled in one register)</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SupportedDataType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SUPPORTED-DATA-TYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- complex type for class BasicElements::SupportsSafety -->
   <xsd:complexType abstract="false" mixed="false" name="SUPPORTS-SAFETY">
      <xsd:annotation>
         <xsd:documentation>In the current version of the ECU Resource Template the element SupportsSafety is optional. A HW Element uses this element if it provides a safety mechanism, otherwise this element is missing in the description of the HW Element.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SupportsSafety"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- complex type for class BasicElements::SupportsSecurity -->
   <xsd:complexType abstract="false" mixed="false" name="SUPPORTS-SECURITY">
      <xsd:annotation>
         <xsd:documentation>The ECU Resource Template provides the element SupportsSecurity storing the information about the supported security mechanism.
      In the current version of the ECU Resource Template the element SupportsSecurity is optional. A HW Element uses this element if it provides a security mechanism otherwise this element is missing in the description of the HW Element.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SupportsSecurity"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- complex type for class AuxillaryObjects::SwAddrMethod -->
   <xsd:complexType abstract="false" mixed="false" name="SW-ADDR-METHOD">
      <xsd:annotation>
         <xsd:documentation>Describes how variables or parameters are addressed in the ECU. It contains a description of the addressing process and a reference to the concerned CPU memory segment.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwAddrMethod"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="SW-ADDR-METHOD--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="SW-ADDR-METHOD"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class DataDefProperties::SwArraysize -->
   <xsd:group name="SW-ARRAYSIZE">
      <xsd:annotation>
         <xsd:documentation>The existence of SwArraysize turns the containing element into a multidimensional object. It is then possible to create arrays of variables, parameters etc. SwArraysize should not be used to imitate stereotypes such as curves or maps since these structures are modeled as separate elements, refer to SwCalprmAxisSet for an SwCalprm. Apart from that any array can be created.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwArraysize"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixed,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice>
         <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element maxOccurs="unbounded" minOccurs="0" name="VF" type="AR:VF">
               <xsd:annotation>
                  <xsd:documentation>Value calculated via a system constant. This element is included in every case, where parameters should be generated from numerical values during compile time (not runtime!). Thus for example, the influence of the cylinder number on conversion formulae, can be introduced in a repeatable manner.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="SwArraysize.vf";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element maxOccurs="unbounded" minOccurs="0" name="V" type="xsd:string">
               <xsd:annotation>
                  <xsd:documentation>Use &lt;v&gt; to enter a numerical value.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="SwArraysize.v";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
         </xsd:choice>
      </xsd:choice>
   </xsd:group>
   <!-- complex type for class DataDefProperties::SwArraysize -->
   <xsd:complexType abstract="false" mixed="false" name="SW-ARRAYSIZE">
      <xsd:annotation>
         <xsd:documentation>The existence of SwArraysize turns the containing element into a multidimensional object. It is then possible to create arrays of variables, parameters etc. SwArraysize should not be used to imitate stereotypes such as curves or maps since these structures are modeled as separate elements, refer to SwCalprmAxisSet for an SwCalprm. Apart from that any array can be created.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwArraysize"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixed,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:SW-ARRAYSIZE"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Axis::SwAxisGeneric -->
   <xsd:group name="SW-AXIS-GENERIC">
      <xsd:annotation>
         <xsd:documentation>This element defines an axis for the base points calculated in the ECU. The ECU is equipped with a fixed calculation algorithm. Parameters for the algorithm can be stored in the data component of the ECU.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisGeneric"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-AXIS-TYPE-REF">
            <xsd:annotation>
               <xsd:documentation>Associated axis calculation strategy.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisGeneric.swAxisType";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-AXIS-TYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-GENERIC-AXIS-PARAMS">
            <xsd:annotation>
               <xsd:documentation>Specific parameter of a generic axis.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisGeneric.swGenericAxisParam";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="true";xml.roleWrapperElement="true";xml.sequenceOffset="40";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SW-GENERIC-AXIS-PARAM" type="AR:SW-GENERIC-AXIS-PARAM"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Axis::SwAxisGeneric -->
   <xsd:complexType abstract="false" mixed="false" name="SW-AXIS-GENERIC">
      <xsd:annotation>
         <xsd:documentation>This element defines an axis for the base points calculated in the ECU. The ECU is equipped with a fixed calculation algorithm. Parameters for the algorithm can be stored in the data component of the ECU.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisGeneric"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SW-AXIS-GENERIC"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Axis::SwAxisGrouped -->
   <xsd:group name="SW-AXIS-GROUPED">
      <xsd:annotation>
         <xsd:documentation>An SwAxisGrouped is an axis which is shared between multiple calibration parameters.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisGrouped"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:choice maxOccurs="1" minOccurs="0">
            <xsd:group ref="AR:AR-CALPRM-REF"/>
         </xsd:choice>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Axis::SwAxisGrouped -->
   <xsd:complexType abstract="false" mixed="false" name="SW-AXIS-GROUPED">
      <xsd:annotation>
         <xsd:documentation>An SwAxisGrouped is an axis which is shared between multiple calibration parameters.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisGrouped"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SW-AXIS-GROUPED"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Axis::SwAxisIndividual -->
   <xsd:group name="SW-AXIS-INDIVIDUAL">
      <xsd:annotation>
         <xsd:documentation>This element describes an axis integrated into a parameter (field etc.). The integration makes this individual to each parameter. The so-called grouped axis represents the counterpart to this. It is conceived as an independent parameter (see class SwAxisGrouped).

      The attributes swVariableRefs, compuMethod and unit can exist in parallel, although physically speaking, only one is practical. This parallelism introduces flexibility into the development process, as axes can be described purely physically, without a conversion formula being available.
      The following priority exists:
      * swVariableRefs
      * compuMethod
      * unit</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisIndividual"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-VARIABLE-REFS">
            <xsd:annotation>
               <xsd:documentation>Refers to an input variable of the axis. It is possible to specify more than one variable. Here the following is valid:

            * The variable with the highest priority must be given first. It is used in the generation of the code and is also displayed first in the application system.

            * All variables referenced must be of the same physical nature. This is usually detected in that the conversion formulae affected refer back to the same SI-units.

            * This multiple referencing allows a base point distribution for more than one input variable to be used. One example of this are the temperature curves, which can depend both on the induction air temperature and the engine temperature.

            These variables can be displayed simultaneously by MCD systems (adjustment systems), enabling operating points to be shown in the curves.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisIndividual.swVariableRef";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="false";xml.roleWrapperElement="true";xml.sequenceOffset="20";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:group ref="AR:DATA-PROTOTYPE-REF"/>
                  <xsd:group ref="AR:RECORD-ELEMENT-REF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPU-METHOD-REF">
            <xsd:annotation>
               <xsd:documentation>This is the compuMethod which is expected for the axis. It is used in early stages if the particular input-value is not yet available.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisIndividual.compuMethod";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMPU-METHOD--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="UNIT-REF">
            <xsd:annotation>
               <xsd:documentation>Use &lt;unit&gt; to enter the unit of a parameter.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisIndividual.unit";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:UNIT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-MAX-AXIS-POINTS" type="AR:VF">
            <xsd:annotation>
               <xsd:documentation>Maximum number of base points contained in the axis of a map or curve.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisIndividual.swMaxAxisPoints";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="60"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-MIN-AXIS-POINTS" type="AR:VF">
            <xsd:annotation>
               <xsd:documentation>This element specifies the minimum number of base points on the current axis of a map or curve.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisIndividual.swMinAxisPoints";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="70"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-CONSTR-REF">
            <xsd:annotation>
               <xsd:documentation>Refers to constraints, e.g. for plausibility checks.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisIndividual.dataConstr";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="80"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:DATA-CONSTR--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-AXIS-GENERIC" type="AR:SW-AXIS-GENERIC">
            <xsd:annotation>
               <xsd:documentation>This element defines an axis for the base points calculated in the ECU. The ECU is equipped with a fixed calculation algorithm. Parameters for the algorithm can be stored in the data component of the ECU. The following is valid:

            * The algorithm to be used is specified as &lt;swAxisType&gt; in the data dictionary ** (reservation of keyword and specification of parameters). Thus when forming an axis, the algorithm is given through the appropriate reference ( &lt;swAxisTypeRef&gt; ).

            * The number of base points to be calculated is defined in &lt;SW-NUMER-OF-AXIS-POINTS&gt;. This element exists to enable the number of axis points to be stored explicitly, although it could also be described as &lt;swGenericAxisParam&gt; .

            * The calculated base points can be stored on a physical level in the element &lt;swValuesPhys&gt; , which means that it is not necessary for the required calculation algorithm to be implemented in every MCD system.

            * The calculated base points can be stored on a standardized level in the element &lt;swValuesCoded&gt; , which means that it is not necessary for the required calculation algorithm to be implemented in every MCD system.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisIndividual.swAxisGeneric";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="90"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Axis::SwAxisIndividual -->
   <xsd:complexType abstract="false" mixed="false" name="SW-AXIS-INDIVIDUAL">
      <xsd:annotation>
         <xsd:documentation>This element describes an axis integrated into a parameter (field etc.). The integration makes this individual to each parameter. The so-called grouped axis represents the counterpart to this. It is conceived as an independent parameter (see class SwAxisGrouped).

      The attributes swVariableRefs, compuMethod and unit can exist in parallel, although physically speaking, only one is practical. This parallelism introduces flexibility into the development process, as axes can be described purely physically, without a conversion formula being available.
      The following priority exists:
      * swVariableRefs
      * compuMethod
      * unit</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisIndividual"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SW-AXIS-INDIVIDUAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Axis::SwAxisType -->
   <xsd:group name="SW-AXIS-TYPE">
      <xsd:annotation>
         <xsd:documentation>Stands for a specific axis calculation strategy. No formal specification is given, due to the fact that it is possible to use arbitrary algorithms for calculating axis-points. Instead, the algorithm is described verbally but the parameters are specified formally with respect to their names and constraints. As a result, SwAxisType mainly reserves appropriate keywords.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-GENERIC-AXIS-PARAM-TYPES">
            <xsd:annotation>
               <xsd:documentation>Parameters for this calcultaion algorithm.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisType.swGenericAxisParamType";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="true";xml.roleWrapperElement="true";xml.sequenceOffset="30";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SW-GENERIC-AXIS-PARAM-TYPE" type="AR:SW-GENERIC-AXIS-PARAM-TYPE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Axis::SwAxisType -->
   <xsd:complexType abstract="false" mixed="false" name="SW-AXIS-TYPE">
      <xsd:annotation>
         <xsd:documentation>Stands for a specific axis calculation strategy. No formal specification is given, due to the fact that it is possible to use arbitrary algorithms for calculating axis-points. Instead, the algorithm is described verbally but the parameters are specified formally with respect to their names and constraints. As a result, SwAxisType mainly reserves appropriate keywords.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwAxisType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SW-AXIS-TYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="SW-AXIS-TYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="SW-AXIS-TYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- complex type for class BaseTypes::SwBaseType -->
   <xsd:complexType abstract="false" mixed="false" name="SW-BASE-TYPE">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwBaseType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:BASE-TYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="SW-BASE-TYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="SW-BASE-TYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class DataDefProperties::SwBitRepresentation -->
   <xsd:group name="SW-BIT-REPRESENTATION">
      <xsd:annotation>
         <xsd:documentation>Description of the structure of a bit variable: Comprises of the bitPosition in a memory object (e.g. swHostVariable, which stands parallel to swBitRepresentation) and the numberOfBits . In this way, interrelated memory areas can be described. Non-related memory areas are not supported.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwBitRepresentation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BIT-POSITION" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>If the "bit data object" is hosted witin another data object (e.g. if the memory can be accessed via byte as well as bit adress), this attribute specifies the position of the data object. The count starts at zero (0).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwBitRepresentation.bitPosition";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NUMBER-OF-BITS" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Number of bits allocated by a "bit data object" within its host data object.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwBitRepresentation.numberOfBits";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataDefProperties::SwBitRepresentation -->
   <xsd:complexType abstract="false" mixed="false" name="SW-BIT-REPRESENTATION">
      <xsd:annotation>
         <xsd:documentation>Description of the structure of a bit variable: Comprises of the bitPosition in a memory object (e.g. swHostVariable, which stands parallel to swBitRepresentation) and the numberOfBits . In this way, interrelated memory areas can be described. Non-related memory areas are not supported.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwBitRepresentation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SW-BIT-REPRESENTATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CalibrationParameter::SwCalprmAxis -->
   <xsd:group name="SW-CALPRM-AXIS">
      <xsd:annotation>
         <xsd:documentation>This element specifies an individual input parameter axis (abscissa).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwCalprmAxis"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-AXIS-INDEX" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Describes the index referring to the axis currently described, for which the contents is specified.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwCalprmAxis.swAxisIndex";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="CATEGORY" type="AR:CALPRM-AXIS-CATEGORY-ENUM">
            <xsd:annotation>
               <xsd:documentation>This property specifies the category of a particular axis.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwCalprmAxis.category";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:choice maxOccurs="1" minOccurs="0">
            <xsd:group ref="AR:SW-CALPRM-AXIS-COMMON-AXIS"/>
            <xsd:group ref="AR:SW-CALPRM-AXIS-INDIVIDUAL-AXIS"/>
         </xsd:choice>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-CALIBRATION-ACCESS" type="AR:SW-CALIBRATION-ACCESS-ENUM">
            <xsd:annotation>
               <xsd:documentation>Describes the applicability of parameters and variables.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwCalprmAxis.swCalibrationAccess";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="90"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DISPLAY-FORMAT" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>This property specifies how the axis values shall be displayed e.g. in documents or in measurement and calibration tools.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwCalprmAxis.displayFormat";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="100"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="BASE-TYPE-REF">
            <xsd:annotation>
               <xsd:documentation>The SwBaseType to be used for the axis.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwCalprmAxis.baseType";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="110"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-BASE-TYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CalibrationParameter::SwCalprmAxis -->
   <xsd:complexType abstract="false" mixed="false" name="SW-CALPRM-AXIS">
      <xsd:annotation>
         <xsd:documentation>This element specifies an individual input parameter axis (abscissa).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwCalprmAxis"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SW-CALPRM-AXIS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CalibrationParameter::SwCalprmAxisCommonAxis -->
   <xsd:group name="SW-CALPRM-AXIS-COMMON-AXIS">
      <xsd:annotation>
         <xsd:documentation>Container for the properties of a grouped axis.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwCalprmAxisCommonAxis"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-AXIS-GROUPED" type="AR:SW-AXIS-GROUPED">
            <xsd:annotation>
               <xsd:documentation>The grouped axis contained.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwCalprmAxisCommonAxis.swAxisGrouped";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="80"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CalibrationParameter::SwCalprmAxisCommonAxis -->
   <xsd:complexType abstract="false" mixed="false" name="SW-CALPRM-AXIS-COMMON-AXIS">
      <xsd:annotation>
         <xsd:documentation>Container for the properties of a grouped axis.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwCalprmAxisCommonAxis"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SW-CALPRM-AXIS-COMMON-AXIS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CalibrationParameter::SwCalprmAxisIndividualAxis -->
   <xsd:group name="SW-CALPRM-AXIS-INDIVIDUAL-AXIS">
      <xsd:annotation>
         <xsd:documentation>Container for the properties of an individual axis.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwCalprmAxisIndividualAxis"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-AXIS-INDIVIDUAL" type="AR:SW-AXIS-INDIVIDUAL">
            <xsd:annotation>
               <xsd:documentation>The grouped axis contained.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwCalprmAxisIndividualAxis.swAxisIndividual";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="60"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CalibrationParameter::SwCalprmAxisIndividualAxis -->
   <xsd:complexType abstract="false" mixed="false" name="SW-CALPRM-AXIS-INDIVIDUAL-AXIS">
      <xsd:annotation>
         <xsd:documentation>Container for the properties of an individual axis.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwCalprmAxisIndividualAxis"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SW-CALPRM-AXIS-INDIVIDUAL-AXIS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class CalibrationParameter::SwCalprmAxisSet -->
   <xsd:group name="SW-CALPRM-AXIS-SET">
      <xsd:annotation>
         <xsd:documentation>This element specifies the input parameter axes (abscissas) of parameters (and variables, if these are used adaptively).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwCalprmAxisSet"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="SW-CALPRM-AXIS" type="AR:SW-CALPRM-AXIS">
            <xsd:annotation>
               <xsd:documentation>One axis belonging to this SwCalprmAxisSet</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwCalprmAxisSet.swCalprmAxis";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="true";xml.roleWrapperElement="false";xml.sequenceOffset="20";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CalibrationParameter::SwCalprmAxisSet -->
   <xsd:complexType abstract="false" mixed="false" name="SW-CALPRM-AXIS-SET">
      <xsd:annotation>
         <xsd:documentation>This element specifies the input parameter axes (abscissas) of parameters (and variables, if these are used adaptively).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwCalprmAxisSet"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SW-CALPRM-AXIS-SET"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class SwClass::SwCalprmImpl -->
   <xsd:group name="SW-CALPRM-IMPL">
      <xsd:annotation>
         <xsd:documentation>This element describes the implementation details of a class attribute which manifests itself as a calibration parameter.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwCalprmImpl"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-CALPRM-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:documentation>This element describes the prototype declaration of a class attribute, which is used as a calibration parameter.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwCalprmImpl.swCalprmPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-CALPRM-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-DATA-DEF-PROPS" type="AR:SW-DATA-DEF-PROPS">
            <xsd:annotation>
               <xsd:documentation>This element describes all of the distinguishing characteristics of a data object (variable or parameter). &lt;swDataDefProps&gt; is used in every case, where characteristics of data objects must be given.

            It is inevitable that not all of the inputs are useful all of the time. Hence, the process definition or the DCI has the task of implementing limitations.

            The &lt;swDataDefProps&gt; describe the characteristics of all axes:

            * The characteristics of the argument axes (abscissas) are described in &lt;swCalprmAxisSet&gt; .

            * The characteristics of the value axis are described directly in &lt;swDataDefProps&gt; .</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwCalprmImpl.swDataDefProps";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SwClass::SwCalprmImpl -->
   <xsd:complexType abstract="false" mixed="false" name="SW-CALPRM-IMPL">
      <xsd:annotation>
         <xsd:documentation>This element describes the implementation details of a class attribute which manifests itself as a calibration parameter.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwCalprmImpl"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SW-CALPRM-IMPL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class SwClass::SwCalprmPrototype -->
   <xsd:group name="SW-CALPRM-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>This element describes the prototype declaration of a class attribute, which is used as a calibration parameter.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwCalprmPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-DATA-DEF-PROPS" type="AR:SW-DATA-DEF-PROPS">
            <xsd:annotation>
               <xsd:documentation>This element describes all of the distinguishing characteristics of a data object (variable or parameter). &lt;swDataDefProps&gt; is used in every case, where characteristics of data objects must be given.

            It is inevitable that not all of the inputs are useful all of the time. Hence, the process definition or the DCI has the task of implementing limitations.

            The &lt;swDataDefProps&gt; describe the characteristics of all axes:

            * The characteristics of the argument axes (abscissas) are described in &lt;swCalprmAxisSet&gt; .

            * The characteristics of the value axis are described directly in &lt;swDataDefProps&gt; .</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwCalprmPrototype.swDataDefProps";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SwClass::SwCalprmPrototype -->
   <xsd:complexType abstract="false" mixed="false" name="SW-CALPRM-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>This element describes the prototype declaration of a class attribute, which is used as a calibration parameter.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwCalprmPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SW-CALPRM-PROTOTYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="SW-CALPRM-PROTOTYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="SW-CALPRM-PROTOTYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- complex type for class DatadictionaryProxies::SwCalprmRefProxy -->
   <xsd:complexType abstract="false" mixed="false" name="SW-CALPRM-REF-PROXY">
      <xsd:annotation>
         <xsd:documentation>Parent class for several kinds of references to a calibration parameter.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwCalprmRefProxy"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- complex type for class CalibrationParameter::SwCalprmValueAxisLabels -->
   <xsd:complexType abstract="false" mixed="false" name="SW-CALPRM-VALUE-AXIS-LABELS">
      <xsd:annotation>
         <xsd:documentation>This element is used to record textual descriptions of axis values and is contained in ASAP1.4, for reasons of backward compatibility.

      In new systems, the application should be implemented via conversion formulae.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwCalprmValueAxisLabels"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class SwClass::SwClassAttr -->
   <xsd:group name="SW-CLASS-ATTR">
      <xsd:annotation>
         <xsd:documentation>Defines the object-oriented class-attributes containing the prototypes: &lt;swVariablePrototypes&gt; which denote attributes within the classes that are variables, &lt;swCalprmPrototypes&gt; which denote attributes within the classes that are calibration parameters , &lt;SW-SERVICE-PROTOTYPES&gt; which denote attributes within the classes that are services and &lt;swClassPrototypes&gt; which denote attributes within the classes that are class instances themselves.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwClassAttr"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-VARIABLE-PROTOTYPES">
            <xsd:annotation>
               <xsd:documentation>This element describes the prototype declaration of a class attribute, which appears in the form of a variable.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwClassAttr.swVariablePrototype";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="true";xml.roleWrapperElement="true";xml.sequenceOffset="20";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SW-VARIABLE-PROTOTYPE" type="AR:SW-VARIABLE-PROTOTYPE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-CALPRM-PROTOTYPES">
            <xsd:annotation>
               <xsd:documentation>This element describes the prototype declaration of a class attribute, which is used as a calibration parameter.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwClassAttr.swCalprmPrototype";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="true";xml.roleWrapperElement="true";xml.sequenceOffset="30";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SW-CALPRM-PROTOTYPE" type="AR:SW-CALPRM-PROTOTYPE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SwClass::SwClassAttr -->
   <xsd:complexType abstract="false" mixed="false" name="SW-CLASS-ATTR">
      <xsd:annotation>
         <xsd:documentation>Defines the object-oriented class-attributes containing the prototypes: &lt;swVariablePrototypes&gt; which denote attributes within the classes that are variables, &lt;swCalprmPrototypes&gt; which denote attributes within the classes that are calibration parameters , &lt;SW-SERVICE-PROTOTYPES&gt; which denote attributes within the classes that are services and &lt;swClassPrototypes&gt; which denote attributes within the classes that are class instances themselves.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwClassAttr"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SW-CLASS-ATTR"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class SwClass::SwClassAttrImpl -->
   <xsd:group name="SW-CLASS-ATTR-IMPL">
      <xsd:annotation>
         <xsd:documentation>Defines the object-oriented class-attributes: SW-VARIABLE-IMPLS which implement attributes that are variables, SW-CALPRM-IMPLS which implement attributes that are calibration parameters and SW-CLASS-IMPLS which implement attributes that are class instances themselves.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwClassAttrImpl"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-DATA-DEF-PROPS" type="AR:SW-DATA-DEF-PROPS">
            <xsd:annotation>
               <xsd:documentation>This element describes all of the distinguishing characteristics of a data object (variable or parameter). &lt;swDataDefProps&gt; is used in every case, where characteristics of data objects must be given.

            It is inevitable that not all of the inputs are useful all of the time. Hence, the process definition or the DCI has the task of implementing limitations.

            The &lt;swDataDefProps&gt; describe the characteristics of all axes:

            * The characteristics of the argument axes (abscissas) are described in &lt;swCalprmAxisSet&gt; .

            * The characteristics of the value axis are described directly in &lt;swDataDefProps&gt; .</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwClassAttrImpl.swDataDefProps";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-VARIABLE-IMPLS">
            <xsd:annotation>
               <xsd:documentation>This element describes the implementation details of a class attribute which manifests itself as a variable.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwClassAttrImpl.swVariableImpl";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="true";xml.roleWrapperElement="true";xml.sequenceOffset="40";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SW-VARIABLE-IMPL" type="AR:SW-VARIABLE-IMPL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-CALPRM-IMPLS">
            <xsd:annotation>
               <xsd:documentation>This element describes the implementation details of a class attribute which manifests itself as a calibration parameter.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwClassAttrImpl.swCalprmImpl";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="true";xml.roleWrapperElement="true";xml.sequenceOffset="60";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SW-CALPRM-IMPL" type="AR:SW-CALPRM-IMPL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SwClass::SwClassAttrImpl -->
   <xsd:complexType abstract="false" mixed="false" name="SW-CLASS-ATTR-IMPL">
      <xsd:annotation>
         <xsd:documentation>Defines the object-oriented class-attributes: SW-VARIABLE-IMPLS which implement attributes that are variables, SW-CALPRM-IMPLS which implement attributes that are calibration parameters and SW-CLASS-IMPLS which implement attributes that are class instances themselves.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwClassAttrImpl"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SW-CLASS-ATTR-IMPL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class SwClass::SwClassAttrInstanceImpl -->
   <xsd:group name="SW-CLASS-ATTR-INSTANCE-IMPL">
      <xsd:annotation>
         <xsd:documentation>&lt;swClassAttrInstanceImpl&gt; is used to create an instance from a model (Models are defined with SW-CLASS) where some specifications shall be changed / overwritten. This implementation will then be a instance specific implementation (Classes are usually only implemented under &lt;swClassImpls&gt;).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwClassAttrInstanceImpl"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-VARIABLE-IMPLS">
            <xsd:annotation>
               <xsd:documentation>This element describes the implementation details of a class attribute which manifests itself as a variable.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwClassAttrInstanceImpl.swVariableImpl";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="true";xml.roleWrapperElement="true";xml.sequenceOffset="20";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SW-VARIABLE-IMPL" type="AR:SW-VARIABLE-IMPL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-CALPRM-IMPLS">
            <xsd:annotation>
               <xsd:documentation>This element describes the implementation details of a class attribute which manifests itself as a calibration parameter.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwClassAttrInstanceImpl.swCalprmImpl";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="true";xml.roleWrapperElement="true";xml.sequenceOffset="30";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SW-CALPRM-IMPL" type="AR:SW-CALPRM-IMPL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-CLASS-IMPLS">
            <xsd:annotation>
               <xsd:documentation>This element describes the implementation details of a class attribute which manifests itself as a class.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwClassAttrInstanceImpl.swClassImpl";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="true";xml.roleWrapperElement="true";xml.sequenceOffset="40";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SW-CLASS-IMPL" type="AR:SW-CLASS-IMPL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SwClass::SwClassAttrInstanceImpl -->
   <xsd:complexType abstract="false" mixed="false" name="SW-CLASS-ATTR-INSTANCE-IMPL">
      <xsd:annotation>
         <xsd:documentation>&lt;swClassAttrInstanceImpl&gt; is used to create an instance from a model (Models are defined with SW-CLASS) where some specifications shall be changed / overwritten. This implementation will then be a instance specific implementation (Classes are usually only implemented under &lt;swClassImpls&gt;).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwClassAttrInstanceImpl"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SW-CLASS-ATTR-INSTANCE-IMPL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class SwClass::SwClassImpl -->
   <xsd:group name="SW-CLASS-IMPL">
      <xsd:annotation>
         <xsd:documentation>This element describes the implementation details of a class attribute which manifests itself as a class.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwClassImpl"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-CLASS-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:documentation>This element describes the prototype declaration of a class attribute, which appears in the form of a class.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwClassImpl.swClassPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-CLASS-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-DATA-DEF-PROPS" type="AR:SW-DATA-DEF-PROPS">
            <xsd:annotation>
               <xsd:documentation>This element describes all of the distinguishing characteristics of a data object (variable or parameter). &lt;swDataDefProps&gt; is used in every case, where characteristics of data objects must be given.

            It is inevitable that not all of the inputs are useful all of the time. Hence, the process definition or the DCI has the task of implementing limitations.

            The &lt;swDataDefProps&gt; describe the characteristics of all axes:

            * The characteristics of the argument axes (abscissas) are described in &lt;swCalprmAxisSet&gt; .

            * The characteristics of the value axis are described directly in &lt;swDataDefProps&gt; .</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwClassImpl.swDataDefProps";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SwClass::SwClassImpl -->
   <xsd:complexType abstract="false" mixed="false" name="SW-CLASS-IMPL">
      <xsd:annotation>
         <xsd:documentation>This element describes the implementation details of a class attribute which manifests itself as a class.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwClassImpl"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SW-CLASS-IMPL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class SwClass::SwClassInstance -->
   <xsd:group name="SW-CLASS-INSTANCE">
      <xsd:annotation>
         <xsd:documentation>Defines the particular instantiation of a referenced &lt;swClass&gt; .</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwClassInstance"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-DATA-DEF-PROPS" type="AR:SW-DATA-DEF-PROPS">
            <xsd:annotation>
               <xsd:documentation>This element describes all of the distinguishing characteristics of a data object (variable or parameter). &lt;swDataDefProps&gt; is used in every case, where characteristics of data objects must be given.

            It is inevitable that not all of the inputs are useful all of the time. Hence, the process definition or the DCI has the task of implementing limitations.

            The &lt;swDataDefProps&gt; describe the characteristics of all axes:

            * The characteristics of the argument axes (abscissas) are described in &lt;swCalprmAxisSet&gt; .

            * The characteristics of the value axis are described directly in &lt;swDataDefProps&gt; .</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwClassInstance.swDataDefProps";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-CLASS-ATTR-INSTANCE-IMPL" type="AR:SW-CLASS-ATTR-INSTANCE-IMPL">
            <xsd:annotation>
               <xsd:documentation>&lt;swClassAttrInstanceImpl&gt; is used to create an instance from a model (Models are defined with SW-CLASS) where some specifications shall be changed / overwritten. This implementation will then be a instance specific implementation (Classes are usually only implemented under &lt;swClassImpls&gt;).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwClassInstance.swClassAttrInstanceImpl";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="70"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SwClass::SwClassInstance -->
   <xsd:complexType abstract="false" mixed="false" name="SW-CLASS-INSTANCE">
      <xsd:annotation>
         <xsd:documentation>Defines the particular instantiation of a referenced &lt;swClass&gt; .</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwClassInstance"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SW-CLASS-INSTANCE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- complex type for class SwClass::SwClassPrototype -->
   <xsd:complexType abstract="false" mixed="false" name="SW-CLASS-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>This element describes the prototype declaration of a class attribute, which appears in the form of a class.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwClassPrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="SW-CLASS-PROTOTYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="SW-CLASS-PROTOTYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- complex type for class AuxillaryObjects::SwCodeSyntax -->
   <xsd:complexType abstract="false" mixed="false" name="SW-CODE-SYNTAX">
      <xsd:annotation>
         <xsd:documentation>SwCodeSyntax objects fix the representation of data objects, e.g. variables and parameters, in the program source file. These code syntax objects are defined centrally in SwCodeSyntaxes and are connected to data objects by means of SwCodeSyntaxRef.

      The principle role of this element is the declaration of keywords (in the subelement ShortName) for the code generation procedure. The process itself is given a verbal description (in SwCodeSyntaxDesc) rather than a formal one. This approach was adopted as the number of possible code syntax schematics is relatively small. A complete formal description would create unnecessary work.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwCodeSyntax"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="SW-CODE-SYNTAX--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="SW-CODE-SYNTAX"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class _instanceRef::SwCompToEcuMapping_component -->
   <xsd:group name="SW-COMP-TO-ECU-MAPPING--COMPONENT-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwCompToEcuMapping_component"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SOFTWARE-COMPOSITION-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwCompToEcuMapping_component.softwareComposition";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="10"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SOFTWARE-COMPOSITION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="COMPONENT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwCompToEcuMapping_component.componentPrototype";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMPONENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="1" name="TARGET-COMPONENT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwCompToEcuMapping_component.targetComponentPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.target</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMPONENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class _instanceRef::SwCompToEcuMapping_component -->
   <xsd:complexType abstract="false" mixed="false" name="SW-COMP-TO-ECU-MAPPING--COMPONENT-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwCompToEcuMapping_component"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SW-COMP-TO-ECU-MAPPING--COMPONENT-IREF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class _instanceRef::SwCompToImplMapping_component -->
   <xsd:group name="SW-COMP-TO-IMPL-MAPPING--COMPONENT-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwCompToImplMapping_component"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SOFTWARE-COMPOSITION-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwCompToImplMapping_component.softwareComposition";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="10"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SOFTWARE-COMPOSITION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="COMPONENT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwCompToImplMapping_component.componentPrototype";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMPONENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="1" name="TARGET-COMPONENT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwCompToImplMapping_component.targetComponentPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.target</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMPONENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class _instanceRef::SwCompToImplMapping_component -->
   <xsd:complexType abstract="false" mixed="false" name="SW-COMP-TO-IMPL-MAPPING--COMPONENT-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwCompToImplMapping_component"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SW-COMP-TO-IMPL-MAPPING--COMPONENT-IREF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataDefProperties::SwComparisonVariables -->
   <xsd:group name="SW-COMPARISON-VARIABLES">
      <xsd:annotation>
         <xsd:documentation>These variables can be used to display the value of a variable on the value axis of a calibration parameter (characteristic), that is currently displayed in the MCD-System. The purpose is to compare the appropriate result from the calibration parameter in question, with a value being calculated or taken from a sensor (the comparison variable).

      The sole purpose of this comparison-variable is to serve the calibration process.

      Screen representation of comparison variable
           Vs |              |
                              |              |
                              |              |
                           V _|______________|______________
                              |         /----|------
                              |  /-----/     |
                              | /            |
                              |/             |
                              |--------------|--------------
                                             tx          tmot
                      
                              tx: current temperature
                              V:  current speed as shown in the MCD system for comparison:
                                  this is the SwComparisonVariable
                              Vs: speed characteristic over temperature
                              tmot: motor temperature</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwComparisonVariables"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:group ref="AR:DATA-PROTOTYPE-REF"/>
            <xsd:group ref="AR:RECORD-ELEMENT-REF"/>
         </xsd:choice>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataDefProperties::SwComparisonVariables -->
   <xsd:complexType abstract="false" mixed="false" name="SW-COMPARISON-VARIABLES">
      <xsd:annotation>
         <xsd:documentation>These variables can be used to display the value of a variable on the value axis of a calibration parameter (characteristic), that is currently displayed in the MCD-System. The purpose is to compare the appropriate result from the calibration parameter in question, with a value being calculated or taken from a sensor (the comparison variable).

      The sole purpose of this comparison-variable is to serve the calibration process.

      Screen representation of comparison variable
           Vs |              |
                              |              |
                              |              |
                           V _|______________|______________
                              |         /----|------
                              |  /-----/     |
                              | /            |
                              |/             |
                              |--------------|--------------
                                             tx          tmot
                      
                              tx: current temperature
                              V:  current speed as shown in the MCD system for comparison:
                                  this is the SwComparisonVariable
                              Vs: speed characteristic over temperature
                              tmot: motor temperature</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwComparisonVariables"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SW-COMPARISON-VARIABLES"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- complex type for class GlobalConstraints::SwConstrObjects -->
   <xsd:complexType abstract="false" mixed="false" name="SW-CONSTR-OBJECTS">
      <xsd:annotation>
         <xsd:documentation>Parameters or variables can reference plausibility checks. The assignment of data to &lt;swConstrObjects&gt; makes the reverse direction possible.

      In this way for example plausibility libraries stored in external files can be latched beneath the previous element &lt;SW-DATA-CONSTRS&gt; -element.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwConstrObjects"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixed,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0"/>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataDefProperties::SwDataDefProps -->
   <xsd:group name="SW-DATA-DEF-PROPS">
      <xsd:annotation>
         <xsd:documentation>This class is a collection of properties relevant for data objects under various aspects. One could consider this class as a "pattern of inheritance by aggregation". The properties can be applied to all objects of all classes in which SwDataDefProps is agrregated.

      Note that not all of the attributes or associated elements are useful all of the time. Hence, the process definition (e.g. expressed with an OCL or a Document Control Instance) MSR-DCI has the task of implementing limitations.

      SwDataDefProps covers various aspects:

      * Structure of the data element, is it a single value, a curve, or a map, but also the recordLayouts which specify, how such elements are mapped/converted to the DataTypes in the programming language (or in Autosar). This is mainly expressed by properties like swRecordLayout and swCalprmAxisSet 

      * Implementation policy, mainly expressed by swImplPolicy, swVariableAccessImplPolicy, swAddrMethod 

      * Access policy for the MDC system, mainly expressed by swCalibrationAccess 

      * Semantics of the data element, mainly expressed by compuMethod and/or unit, dataConstr 

      * Code generation policy provided by swCodeSyntax</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ANNOTATIONS">
            <xsd:annotation>
               <xsd:documentation>This aggregation allows to add annotations (yellow pads ...) related to the current data object.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.annotation";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="true";xml.roleWrapperElement="true";xml.sequenceOffset="20";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ANNOTATION" type="AR:ANNOTATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-ADDR-METHOD-REF">
            <xsd:annotation>
               <xsd:documentation>Addressing method related to this data object.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.swAddrMethod";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-ADDR-METHOD--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="BASE-TYPE-REF">
            <xsd:annotation>
               <xsd:documentation>Base type associated with the value axis of this data object.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.baseType";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-BASE-TYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-BIT-REPRESENTATION" type="AR:SW-BIT-REPRESENTATION">
            <xsd:annotation>
               <xsd:documentation>Description of the binary representaion in case of a bit variable.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.swBitRepresentation";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="60"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-CALIBRATION-ACCESS" type="AR:SW-CALIBRATION-ACCESS-ENUM">
            <xsd:annotation>
               <xsd:documentation>Specifies the read or write access by MCD tools for this data object.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.swCalibrationAccess";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="70"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-VALUE-BLOCK-SIZE" type="AR:SW-ARRAYSIZE">
            <xsd:annotation>
               <xsd:documentation>Specifies the size in case the data object is an VAL_BLK. It is there for compatibility reasons, where value blocks were introduced as a kind of an array.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.swValueBlockSize";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="80"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-CALPRM-AXIS-SET" type="AR:SW-CALPRM-AXIS-SET">
            <xsd:annotation>
               <xsd:documentation>This specifies the properties of the axes in case of a curve or map etc. This is mainly applicable to calibration parameters.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.swCalprmAxisSet";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="90"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-TEXT-PROPS" type="AR:SW-TEXT-PROPS">
            <xsd:annotation>
               <xsd:documentation>the specific properties if the data object is a text object.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.swTextProps";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="120"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-CODE-SYNTAX-REF">
            <xsd:annotation>
               <xsd:documentation>Coding policy for this data object expressed as a reference to a Code syntax to be applied.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.swCodeSyntax";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="160"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-CODE-SYNTAX--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPU-METHOD-REF">
            <xsd:annotation>
               <xsd:documentation>Computation method associated with the semantics of this data object.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.compuMethod";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="180"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMPU-METHOD--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-CONSTR-REF">
            <xsd:annotation>
               <xsd:documentation>Data constraint for this data object.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.dataConstr";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="190"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:DATA-CONSTR--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-DATA-DEPENDENCY" type="AR:SW-DATA-DEPENDENCY">
            <xsd:annotation>
               <xsd:documentation>If the data object is virtual - that means it is not directly in the ecu, then this property describes how the "virtual variable" can be computed from the real ones.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.swDataDependency";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="200"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DISPLAY-FORMAT" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>This property describes how a number is to be rendered e.g. in documents or in a measurement and calibration system.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.displayFormat";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="210"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INVALID-VALUE">
            <xsd:annotation>
               <xsd:documentation>Optional value to express invalidity of the actual data element. If given, the owning component has the API to set this data element invalid, otherwise it does not.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.invalidValue";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="215"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="BOOLEAN-LITERAL" type="AR:BOOLEAN-LITERAL"/>
                  <xsd:element name="CHAR-LITERAL" type="AR:CHAR-LITERAL"/>
                  <xsd:element name="INTEGER-LITERAL" type="AR:INTEGER-LITERAL"/>
                  <xsd:element name="OPAQUE-LITERAL" type="AR:OPAQUE-LITERAL"/>
                  <xsd:element name="REAL-LITERAL" type="AR:REAL-LITERAL"/>
                  <xsd:element name="STRING-LITERAL" type="AR:STRING-LITERAL"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-HOST-VARIABLE" type="AR:SW-VARIABLE-REF">
            <xsd:annotation>
               <xsd:documentation>Contains a reference to a variable, which serves as a host-variable for a bit variable. Only applicable to bit objects.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.swHostVariable";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="220"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-IMPL-POLICY" type="AR:SW-IMPL-POLICY-ENUM">
            <xsd:annotation>
               <xsd:documentation>Implementation policy for this data object.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.swImplPolicy";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="230"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-POINTER" type="AR:SW-POINTER">
            <xsd:annotation>
               <xsd:documentation>Specifies that the containing data object is a pointer to another data object.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.swPointer";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="280"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-RECORD-LAYOUT-REF">
            <xsd:annotation>
               <xsd:documentation>Record layout for this data object.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.swRecordLayout";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="290"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-RECORD-LAYOUT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="UNIT-REF">
            <xsd:annotation>
               <xsd:documentation>Physical unit associated with the semantics of this data object. This attribute applies, if no compuMethod is specified. If buth units (this as well as via compuMethod is specified,the units ust be the same.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.unit";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="350"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:UNIT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-VARIABLE-ACCESS-IMPL-POLICY" type="AR:SW-VARIABLE-ACCESS-IMPL-POLICY-ENUM">
            <xsd:annotation>
               <xsd:documentation>In case of a swImplPolicy set to "message" the access policy can be refined here.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps.swVariableAccessImplPolicy";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="390"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataDefProperties::SwDataDefProps -->
   <xsd:complexType abstract="false" mixed="false" name="SW-DATA-DEF-PROPS">
      <xsd:annotation>
         <xsd:documentation>This class is a collection of properties relevant for data objects under various aspects. One could consider this class as a "pattern of inheritance by aggregation". The properties can be applied to all objects of all classes in which SwDataDefProps is agrregated.

      Note that not all of the attributes or associated elements are useful all of the time. Hence, the process definition (e.g. expressed with an OCL or a Document Control Instance) MSR-DCI has the task of implementing limitations.

      SwDataDefProps covers various aspects:

      * Structure of the data element, is it a single value, a curve, or a map, but also the recordLayouts which specify, how such elements are mapped/converted to the DataTypes in the programming language (or in Autosar). This is mainly expressed by properties like swRecordLayout and swCalprmAxisSet 

      * Implementation policy, mainly expressed by swImplPolicy, swVariableAccessImplPolicy, swAddrMethod 

      * Access policy for the MDC system, mainly expressed by swCalibrationAccess 

      * Semantics of the data element, mainly expressed by compuMethod and/or unit, dataConstr 

      * Code generation policy provided by swCodeSyntax</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDefProps"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SW-DATA-DEF-PROPS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataDefProperties::SwDataDependency -->
   <xsd:group name="SW-DATA-DEPENDENCY">
      <xsd:annotation>
         <xsd:documentation>This element describes the interdependencies of data objects, e.g. variables and parameters. It can be used for example to treat virtual parameters.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDependency"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-DATA-DEPENDENCY-FORMULA" type="AR:COMPU-GENERIC-MATH">
            <xsd:annotation>
               <xsd:documentation>This element describes the formula with which the dependencies between the participating objects are defined.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDependency.swDataDependencyFormula";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-DATA-DEPENDENCY-ARGS" type="AR:SW-DATA-DEPENDENCY-ARGS">
            <xsd:annotation>
               <xsd:documentation>Specifies the arguments used in the data dependency. Note that this is 0..1 since the aggregated class is a container (atpMixed).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDependency.swDataDependencyArgs";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataDefProperties::SwDataDependency -->
   <xsd:complexType abstract="false" mixed="false" name="SW-DATA-DEPENDENCY">
      <xsd:annotation>
         <xsd:documentation>This element describes the interdependencies of data objects, e.g. variables and parameters. It can be used for example to treat virtual parameters.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDependency"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SW-DATA-DEPENDENCY"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataDefProperties::SwDataDependencyArgs -->
   <xsd:group name="SW-DATA-DEPENDENCY-ARGS">
      <xsd:annotation>
         <xsd:documentation>This element specifies the elements used in a SwDataDependency.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDependencyArgs"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixed,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice>
         <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:choice maxOccurs="unbounded" minOccurs="0">
               <xsd:group ref="AR:AR-CALPRM-REF"/>
            </xsd:choice>
            <xsd:choice maxOccurs="unbounded" minOccurs="0">
               <xsd:group ref="AR:DATA-PROTOTYPE-REF"/>
               <xsd:group ref="AR:RECORD-ELEMENT-REF"/>
            </xsd:choice>
         </xsd:choice>
      </xsd:choice>
   </xsd:group>
   <!-- complex type for class DataDefProperties::SwDataDependencyArgs -->
   <xsd:complexType abstract="false" mixed="false" name="SW-DATA-DEPENDENCY-ARGS">
      <xsd:annotation>
         <xsd:documentation>This element specifies the elements used in a SwDataDependency.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwDataDependencyArgs"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixed,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:SW-DATA-DEPENDENCY-ARGS"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Axis::SwGenericAxisParam -->
   <xsd:group name="SW-GENERIC-AXIS-PARAM">
      <xsd:annotation>
         <xsd:documentation>This element describes a specific parameter of a generic axis. The name of the parameter is defined through a reference to a parameter type defined on a corresponding axis type.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwGenericAxisParam"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-GENERIC-AXIS-PARAM-TYPE-REF">
            <xsd:annotation>
               <xsd:documentation>Parameter type defined on a corresponding axis type. References can only be made to axis parameters types which are defined within the referenced axis type.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwGenericAxisParam.swGenericAxisParamType";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-GENERIC-AXIS-PARAM-TYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:choice maxOccurs="1" minOccurs="0">
            <xsd:group ref="AR:SW-GENERIC-AXIS-PARAM-VALUE"/>
         </xsd:choice>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Axis::SwGenericAxisParam -->
   <xsd:complexType abstract="false" mixed="false" name="SW-GENERIC-AXIS-PARAM">
      <xsd:annotation>
         <xsd:documentation>This element describes a specific parameter of a generic axis. The name of the parameter is defined through a reference to a parameter type defined on a corresponding axis type.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwGenericAxisParam"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SW-GENERIC-AXIS-PARAM"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- complex type for class Axis::SwGenericAxisParamType -->
   <xsd:complexType abstract="false" mixed="false" name="SW-GENERIC-AXIS-PARAM-TYPE">
      <xsd:annotation>
         <xsd:documentation>This element describes a generic axis parameter type, namely:

      * Plausibility checks can be specified via dataConstr.

      * Textual description (desc), as a formal description is not of any use, due to the large variety of possibilities.

      * If this parameter contains structures, these can be simulated through the recursive use of swGenericAxisParamTypes.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwGenericAxisParamType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="SW-GENERIC-AXIS-PARAM-TYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="SW-GENERIC-AXIS-PARAM-TYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class DataDefProperties::SwGenericAxisParamValue -->
   <xsd:group name="SW-GENERIC-AXIS-PARAM-VALUE">
      <xsd:annotation>
         <xsd:documentation>Contains the value for the generic axis parameter.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwGenericAxisParamValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixed,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice>
         <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element maxOccurs="unbounded" minOccurs="0" name="VF" type="AR:VF">
               <xsd:annotation>
                  <xsd:documentation>Value calculated via a system constant. This element is included in every case, where parameters should be generated from numerical values during compile time (not runtime!). Thus for example, the influence of the cylinder number on conversion formulae, can be introduced in a repeatable manner.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="SwGenericAxisParamValue.vf";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="40"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element maxOccurs="unbounded" minOccurs="0" name="V" type="xsd:string">
               <xsd:annotation>
                  <xsd:documentation>Use &lt;v&gt; to enter a numerical value.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="SwGenericAxisParamValue.v";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="50"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
         </xsd:choice>
      </xsd:choice>
   </xsd:group>
   <!-- complex type for class DataDefProperties::SwGenericAxisParamValue -->
   <xsd:complexType abstract="false" mixed="false" name="SW-GENERIC-AXIS-PARAM-VALUE">
      <xsd:annotation>
         <xsd:documentation>Contains the value for the generic axis parameter.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwGenericAxisParamValue"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixed,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:SW-GENERIC-AXIS-PARAM-VALUE"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataDefProperties::SwPointer -->
   <xsd:group name="SW-POINTER">
      <xsd:annotation>
         <xsd:documentation>This element indicates, that the data object (which is specified by the containing element) is a reference to another data object. The properties of the referred data object are described in the swDataDefProps contained by the SwPointer .</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwPointer"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-DATA-DEF-PROPS" type="AR:SW-DATA-DEF-PROPS">
            <xsd:annotation>
               <xsd:documentation>The properties of the data object, to which the pointer points.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwPointer.swDataDefProps";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataDefProperties::SwPointer -->
   <xsd:complexType abstract="false" mixed="false" name="SW-POINTER">
      <xsd:annotation>
         <xsd:documentation>This element indicates, that the data object (which is specified by the containing element) is a reference to another data object. The properties of the referred data object are described in the swDataDefProps contained by the SwPointer .</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwPointer"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SW-POINTER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class AuxillaryObjects::SwRecordLayout -->
   <xsd:group name="SW-RECORD-LAYOUT">
      <xsd:annotation>
         <xsd:documentation>Defines how the data objects (variables, calibration parameters etc.) are to be stored in the ECU memory. As an example, this definition specifies the sequence of axis points in the ECU memory. Iterations through axis values are stored within the subelements swRecordLayoutGroup . These subelements might be stored nested to support multidimensional data objects.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayout"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="SW-RECORD-LAYOUT-GROUP" type="AR:SW-RECORD-LAYOUT-GROUP">
            <xsd:annotation>
               <xsd:documentation>Set up for the record layout of axis values.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayout.swRecordLayoutGroup";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="true";xml.roleWrapperElement="false";xml.sequenceOffset="20";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class AuxillaryObjects::SwRecordLayout -->
   <xsd:complexType abstract="false" mixed="false" name="SW-RECORD-LAYOUT">
      <xsd:annotation>
         <xsd:documentation>Defines how the data objects (variables, calibration parameters etc.) are to be stored in the ECU memory. As an example, this definition specifies the sequence of axis points in the ECU memory. Iterations through axis values are stored within the subelements swRecordLayoutGroup . These subelements might be stored nested to support multidimensional data objects.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayout"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SW-RECORD-LAYOUT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="SW-RECORD-LAYOUT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="SW-RECORD-LAYOUT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class AuxillaryObjects::SwRecordLayoutGroup -->
   <xsd:group name="SW-RECORD-LAYOUT-GROUP">
      <xsd:annotation>
         <xsd:documentation>Specifies how a record layout is set up. Using SwRecordLayoutGroup it recursively models iterations through axis values. The subelement swRecordLayoutGroupContentType may reference other SwRecordLayouts, SwRecordLayoutVs and SwRecordLayoutGroups for the modeled record layout.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutGroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-RECORD-LAYOUT-GROUP-AXIS" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>The contents of this element specifies the axis number within a record layout group.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutGroup.swRecordLayoutGroupAxis";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-RECORD-LAYOUT-GROUP-INDEX" type="AR:IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>This element attributes a symbolic name to the iterator of the superimposed record layout group. This can be referenced as a loop index beneath superimposed or subsequent SwRecordLayoutV elements.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutGroup.swRecordLayoutGroupIndex";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-RECORD-LAYOUT-GROUP-FROM" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>This element specifies the iterator index for the point in the axis from which a record layout group is commenced. Negative values are also possible, i.e. the value -4 counts from the fourth value from the end.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutGroup.swRecordLayoutGroupFrom";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="60"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-RECORD-LAYOUT-GROUP-TO" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>This element specifies the iterator index for a point in the axis up to which iteration for a record layout group takes place. Negative values are also possible, i.e. the value -4 counts up to the fourth value from the end.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutGroup.swRecordLayoutGroupTo";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="70"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-RECORD-LAYOUT-GROUP-STEP" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>This element specifies the step width for the iterator index, which is used for a record layout group .</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutGroup.swRecordLayoutGroupStep";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="80"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-RECORD-LAYOUT-COMPONENT" type="AR:IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>This element is used to denote the component to which the group in question applies. Thus, the record layout supports structured objects. This secures independence from the sequence of components, because they can be referred to via name.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutGroup.swRecordLayoutComponent";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="90"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:choice maxOccurs="1" minOccurs="0">
            <xsd:group ref="AR:SW-RECORD-LAYOUT-GROUP-CONTENT"/>
         </xsd:choice>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class AuxillaryObjects::SwRecordLayoutGroup -->
   <xsd:complexType abstract="false" mixed="false" name="SW-RECORD-LAYOUT-GROUP">
      <xsd:annotation>
         <xsd:documentation>Specifies how a record layout is set up. Using SwRecordLayoutGroup it recursively models iterations through axis values. The subelement swRecordLayoutGroupContentType may reference other SwRecordLayouts, SwRecordLayoutVs and SwRecordLayoutGroups for the modeled record layout.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutGroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SW-RECORD-LAYOUT-GROUP"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class AuxillaryObjects::SwRecordLayoutGroupContent -->
   <xsd:group name="SW-RECORD-LAYOUT-GROUP-CONTENT">
      <xsd:annotation>
         <xsd:documentation>This is the contents of a RecordLaoyut which is inserted for every iteration. Note that since this is atpMixed, multiple properties can be inserted for each iteration.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutGroupContent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixed,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice>
         <xsd:choice maxOccurs="unbounded" minOccurs="0">
            <xsd:element maxOccurs="unbounded" minOccurs="0" name="SW-RECORD-LAYOUT-REF">
               <xsd:annotation>
                  <xsd:documentation>this association allows to support reusable "sub"-record layouts. In particluar, the contents of the referenced record layout must be used here. So semantically it would be equivalent to replace the particluar association with the swRecordLayoutGroups of the referred SwRecordLayout.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutGroupContent.swRecordLayout";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="110"</xsd:appinfo>
               </xsd:annotation>
               <xsd:complexType>
                  <xsd:simpleContent>
                     <xsd:extension base="AR:REF">
                        <xsd:attribute name="DEST" type="AR:SW-RECORD-LAYOUT--SUBTYPES-ENUM" use="required"/>
                     </xsd:extension>
                  </xsd:simpleContent>
               </xsd:complexType>
            </xsd:element>
            <xsd:element maxOccurs="unbounded" minOccurs="0" name="SW-RECORD-LAYOUT-V" type="AR:SW-RECORD-LAYOUT-V">
               <xsd:annotation>
                  <xsd:documentation>Particular Value specification for this record layout group.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutGroupContent.swRecordLayoutV";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="120"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
            <xsd:element maxOccurs="unbounded" minOccurs="0" name="SW-RECORD-LAYOUT-GROUP" type="AR:SW-RECORD-LAYOUT-GROUP">
               <xsd:annotation>
                  <xsd:documentation>This aggregation provides support for nested iterations. For example if a map is to be handled, then we might have two nested SwRecordLayoutGroups, one for the x-axis and one for the y-axis. The inner iteration runs faster.</xsd:documentation>
                  <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutGroupContent.swRecordLayoutGroup";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="130"</xsd:appinfo>
               </xsd:annotation>
            </xsd:element>
         </xsd:choice>
      </xsd:choice>
   </xsd:group>
   <!-- complex type for class AuxillaryObjects::SwRecordLayoutGroupContent -->
   <xsd:complexType abstract="false" mixed="false" name="SW-RECORD-LAYOUT-GROUP-CONTENT">
      <xsd:annotation>
         <xsd:documentation>This is the contents of a RecordLaoyut which is inserted for every iteration. Note that since this is atpMixed, multiple properties can be inserted for each iteration.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutGroupContent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixed,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
         <xsd:group ref="AR:SW-RECORD-LAYOUT-GROUP-CONTENT"/>
      </xsd:choice>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class AuxillaryObjects::SwRecordLayoutV -->
   <xsd:group name="SW-RECORD-LAYOUT-V">
      <xsd:annotation>
         <xsd:documentation>This element specifies which values are stored for the current SwRecordLayoutGroup. If no baseType is present, the SwBaseType referenced initially in the father element SwRecordLayoutGroup is valid. The specification of swRecordLayoutVAxis gives the axis of the values to be stored in accordance with the current record layout SwRecordLayoutGroup. In swRecordLayoutVProp you are able to specify the type of values that are to be stored, e.g. number or value. Under swRecordLayoutVIndex, the symbolic values of the axes can be given, for which the value given under swRecordLayoutVProp is iterated. These symbolic values relate to the values given in swRecordLayoutGroupIndex.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutV"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BASE-TYPE-REF">
            <xsd:annotation>
               <xsd:documentation>SwBaseType to be used for the values within this SwRecordLayoutV.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutV.baseType";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-BASE-TYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-RECORD-LAYOUT-V-AXIS" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>This attribute specifies the axis from which the value properties are used.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutV.swRecordLayoutVAxis";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-RECORD-LAYOUT-V-PROP" type="xsd:NMTOKEN">
            <xsd:annotation>
               <xsd:documentation>The contents of this attribute describes the type of values to be stored in the record.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutV.swRecordLayoutVProp";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-RECORD-LAYOUT-V-INDEX" type="AR:IDENTIFIER">
            <xsd:annotation>
               <xsd:documentation>The symbolic value for iteration, or the symbolic values separated by white-spaces, refer to the symbolic values given in swRecordLayoutGroupIndex . The iterators are processed from left to right, in such a manner that they symbolize the loop index from the outside to the inside.

            An error has occurred if a parameter references a record layout which contains an swRecordLayoutVIndex with more components than the number of parameter axes.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutV.swRecordLayoutVIndex";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="60"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-RECORD-LAYOUT-V-FIX-VALUE" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>This attribute specifies the filler character for the current record layout, in the form of hex digits. The element present parallel to this in swRecordLayoutVProp must therefore have the contents FILL.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutV.swRecordLayoutVFixValue";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="80"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-RECORD-LAYOUT-REF">
            <xsd:annotation>
               <xsd:documentation>tbd: I (bernhard Weichel) ar not sure if this association is superfluous ...</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutV.swRecordLayout";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="90"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-RECORD-LAYOUT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class AuxillaryObjects::SwRecordLayoutV -->
   <xsd:complexType abstract="false" mixed="false" name="SW-RECORD-LAYOUT-V">
      <xsd:annotation>
         <xsd:documentation>This element specifies which values are stored for the current SwRecordLayoutGroup. If no baseType is present, the SwBaseType referenced initially in the father element SwRecordLayoutGroup is valid. The specification of swRecordLayoutVAxis gives the axis of the values to be stored in accordance with the current record layout SwRecordLayoutGroup. In swRecordLayoutVProp you are able to specify the type of values that are to be stored, e.g. number or value. Under swRecordLayoutVIndex, the symbolic values of the axes can be given, for which the value given under swRecordLayoutVProp is iterated. These symbolic values relate to the values given in swRecordLayoutGroupIndex.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwRecordLayoutV"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SW-RECORD-LAYOUT-V"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- complex type for class AuxillaryObjects::SwRelatedConstrs -->
   <xsd:complexType abstract="false" mixed="false" name="SW-RELATED-CONSTRS">
      <xsd:annotation>
         <xsd:documentation>This element describes plausibility rules that go beyond the individual data object. E.g. the overrun shut-off engine speed must not be higher than the maximum engine speed. This plausibility rule is defined in exactly the same way as the contexts and dependencies of virtual characteristic variables and variables.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwRelatedConstrs"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class DataDefProperties::SwSemaphore -->
   <xsd:group name="SW-SEMAPHORE">
      <xsd:annotation>
         <xsd:documentation>This element denotes a variable which servers as a semaphore for a particular resource which is specified in the surrounding data object, e.g. SwDataDefProps.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwSemaphore"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:choice maxOccurs="1" minOccurs="0">
            <xsd:group ref="AR:DATA-PROTOTYPE-REF"/>
            <xsd:group ref="AR:RECORD-ELEMENT-REF"/>
         </xsd:choice>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataDefProperties::SwSemaphore -->
   <xsd:complexType abstract="false" mixed="false" name="SW-SEMAPHORE">
      <xsd:annotation>
         <xsd:documentation>This element denotes a variable which servers as a semaphore for a particular resource which is specified in the surrounding data object, e.g. SwDataDefProps.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwSemaphore"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SW-SEMAPHORE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ServiceProcessTask::SwService -->
   <xsd:group name="SW-SERVICE">
      <xsd:annotation>
         <xsd:documentation>Describes a procedure call in the software. Depending on the usage, the description can contain properties of the function call (signature) and of its implementation as well.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwService"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-SERVICE-RETURN" type="AR:SW-SERVICE-ARG">
            <xsd:annotation>
               <xsd:documentation>The return type belonging to this SwService.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwService.swServiceReturn";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-SERVICE-ARGS">
            <xsd:annotation>
               <xsd:documentation>An argument belonging to this SwService.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwService.swServiceArg";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="true";xml.roleWrapperElement="true";xml.sequenceOffset="30";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SW-SERVICE-ARG" type="AR:SW-SERVICE-ARG"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-SERVICE-ACCESSED-ELEMENT-SETS">
            <xsd:annotation>
               <xsd:documentation>Interface elements accessed by this SwService.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwService.swServiceAccessedElementSet";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="true";xml.roleWrapperElement="true";xml.sequenceOffset="80";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SW-SERVICE-ACCESSED-ELEMENT-SET" type="AR:SW-SERVICE-ACCESSED-ELEMENT-SET"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-SERVICE-PROPS" type="AR:SW-SERVICE-PROPS">
            <xsd:annotation>
               <xsd:documentation>The properties assigned to this SwService.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwService.swServiceProps";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="90"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceProcessTask::SwService -->
   <xsd:complexType abstract="false" mixed="false" name="SW-SERVICE">
      <xsd:annotation>
         <xsd:documentation>Describes a procedure call in the software. Depending on the usage, the description can contain properties of the function call (signature) and of its implementation as well.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwService"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SW-SERVICE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- complex type for class ServiceProcessTask::SwServiceAccessedElementSet -->
   <xsd:complexType abstract="false" mixed="false" name="SW-SERVICE-ACCESSED-ELEMENT-SET">
      <xsd:annotation>
         <xsd:documentation>This element is similar to &lt;SW-INTERFACE-ACCESSED-ELEMENT-SET&gt; but applies to &lt;SW-SERVICE&gt; . To some extent it is now possible to epress the access to interface elements

      * within a software component represented by ( &lt;swFeature&gt; ), which is the mainly a functional view

      * within a process represented by &lt;SW-SERVICE&gt;, which is more the dynamic view. These processes are part of compontents (represented by ownership and imports, which makes it possible to retrieve the functional view from the dynamic view (but ** vice versa).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwServiceAccessedElementSet"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ServiceProcessTask::SwServiceArg -->
   <xsd:group name="SW-SERVICE-ARG">
      <xsd:annotation>
         <xsd:documentation>Specifies the properties of a data object exchanged during the call of an SwService, e.g. an argument or a return value.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwServiceArg"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-ARRAYSIZE" type="AR:SW-ARRAYSIZE">
            <xsd:annotation>
               <xsd:documentation>The existence of &lt;swArraysize&gt; turns the parent element into a multidimensional object. It is then possible to create arrays of variables, parameters etc. &lt;swArraysize&gt; should ** to imitate stereotypes such as curves or maps since these structures are stored in the DTD itself as own elements, refer to &lt;swCalprmAxisSet&gt; for a &lt;swCalprm&gt;. Apart from that any array can be created.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwServiceArg.swArraysize";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-DATA-DEF-PROPS" type="AR:SW-DATA-DEF-PROPS">
            <xsd:annotation>
               <xsd:documentation>Data properties of this SwServiceArg.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwServiceArg.swDataDefProps";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceProcessTask::SwServiceArg -->
   <xsd:complexType abstract="false" mixed="false" name="SW-SERVICE-ARG">
      <xsd:annotation>
         <xsd:documentation>Specifies the properties of a data object exchanged during the call of an SwService, e.g. an argument or a return value.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwServiceArg"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SW-SERVICE-ARG"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- complex type for class ServiceProcessTask::SwServiceImpl -->
   <xsd:complexType abstract="false" mixed="false" name="SW-SERVICE-IMPL">
      <xsd:annotation>
         <xsd:documentation>tbd</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwServiceImpl"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ServiceProcessTask::SwServiceProps -->
   <xsd:group name="SW-SERVICE-PROPS">
      <xsd:annotation>
         <xsd:documentation>Describes certain properties of the service implementation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwServiceProps"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-SERVICE-REENTRANCE" type="AR:SW-SERVICE-REENTRANCE-ENUM">
            <xsd:annotation>
               <xsd:documentation>Reentrance enables or prohibits the service to be invoked again, before the service has
            finished and delivered a result. If the attribute is missing, then reentrance is prohibited.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwServiceProps.swServiceReentrance";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-IMPL-POLICY" type="AR:SW-SERVICE-IMPL-POLICY-ENUM">
            <xsd:annotation>
               <xsd:documentation>Enables the specification of an implementation strategy. In this way, the direction of the implementation to come, can be specified in advance in an earlier phase.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwServiceProps.swImplPolicy";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceProcessTask::SwServiceProps -->
   <xsd:complexType abstract="false" mixed="false" name="SW-SERVICE-PROPS">
      <xsd:annotation>
         <xsd:documentation>Describes certain properties of the service implementation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwServiceProps"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SW-SERVICE-PROPS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- complex type for class SwClass::SwServicePrototype -->
   <xsd:complexType abstract="false" mixed="false" name="SW-SERVICE-PROTOTYPE">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwServicePrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class DataDefProperties::SwTextProps -->
   <xsd:group name="SW-TEXT-PROPS">
      <xsd:annotation>
         <xsd:documentation>The properties specific for a textual calibration parameter / variable.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwTextProps"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-MAX-TEXT-SIZE" type="AR:VF">
            <xsd:annotation>
               <xsd:documentation>Specifies the maximum text size in characters. Note the the size in bytes depends on the encoding in the corresponding baseType.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwTextProps.swMaxTextSize";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-FILL-CHARACTER" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Filler character for text parameter to pad up to the maximum length &lt;SwMaxTextSize&gt;.
            The filler character for texts which are shorter than the maximum permitted text length.
            The value will be interpreted according to the encoding specified in the associated base type of the data object., e.g. 0x30 (hex) represents the ASCII character zero as filler character and 0 (dez) represents an end of string as filler character.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwTextProps.swFillCharacter";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataDefProperties::SwTextProps -->
   <xsd:complexType abstract="false" mixed="false" name="SW-TEXT-PROPS">
      <xsd:annotation>
         <xsd:documentation>The properties specific for a textual calibration parameter / variable.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwTextProps"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SW-TEXT-PROPS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class SwClass::SwVariableImpl -->
   <xsd:group name="SW-VARIABLE-IMPL">
      <xsd:annotation>
         <xsd:documentation>This element describes the implementation details of a class attribute which manifests itself as a variable.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwVariableImpl"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-VARIABLE-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:documentation>This element describes the prototype declaration of a class attribute, which appears in the form of a variable.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwVariableImpl.swVariablePrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SW-VARIABLE-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-DATA-DEF-PROPS" type="AR:SW-DATA-DEF-PROPS">
            <xsd:annotation>
               <xsd:documentation>This element describes all of the distinguishing characteristics of a data object (variable or parameter). &lt;swDataDefProps&gt; is used in every case, where characteristics of data objects must be given.

            It is inevitable that not all of the inputs are useful all of the time. Hence, the process definition or the DCI has the task of implementing limitations.

            The &lt;swDataDefProps&gt; describe the characteristics of all axes:

            * The characteristics of the argument axes (abscissas) are described in &lt;swCalprmAxisSet&gt; .

            * The characteristics of the value axis are described directly in &lt;swDataDefProps&gt; .</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwVariableImpl.swDataDefProps";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SwClass::SwVariableImpl -->
   <xsd:complexType abstract="false" mixed="false" name="SW-VARIABLE-IMPL">
      <xsd:annotation>
         <xsd:documentation>This element describes the implementation details of a class attribute which manifests itself as a variable.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwVariableImpl"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SW-VARIABLE-IMPL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class SwClass::SwVariablePrototype -->
   <xsd:group name="SW-VARIABLE-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>This element describes the prototype declaration of a class attribute, which appears in the form of a variable.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwVariablePrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-DATA-DEF-PROPS" type="AR:SW-DATA-DEF-PROPS">
            <xsd:annotation>
               <xsd:documentation>This element describes all of the distinguishing characteristics of a data object (variable or parameter). &lt;swDataDefProps&gt; is used in every case, where characteristics of data objects must be given.

            It is inevitable that not all of the inputs are useful all of the time. Hence, the process definition or the DCI has the task of implementing limitations.

            The &lt;swDataDefProps&gt; describe the characteristics of all axes:

            * The characteristics of the argument axes (abscissas) are described in &lt;swCalprmAxisSet&gt; .

            * The characteristics of the value axis are described directly in &lt;swDataDefProps&gt; .</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwVariablePrototype.swDataDefProps";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SwClass::SwVariablePrototype -->
   <xsd:complexType abstract="false" mixed="false" name="SW-VARIABLE-PROTOTYPE">
      <xsd:annotation>
         <xsd:documentation>This element describes the prototype declaration of a class attribute, which appears in the form of a variable.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwVariablePrototype"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SW-VARIABLE-PROTOTYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="SW-VARIABLE-PROTOTYPE--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="SW-VARIABLE-PROTOTYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class DataDefProperties::SwVariableRef -->
   <xsd:group name="SW-VARIABLE-REF">
      <xsd:annotation>
         <xsd:documentation>This class establishes a reference to a variable. It is mainly introduced by the reverse engineering tool.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwVariableRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:choice maxOccurs="1" minOccurs="0">
            <xsd:group ref="AR:DATA-PROTOTYPE-REF"/>
            <xsd:group ref="AR:RECORD-ELEMENT-REF"/>
         </xsd:choice>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class DataDefProperties::SwVariableRef -->
   <xsd:complexType abstract="false" mixed="false" name="SW-VARIABLE-REF">
      <xsd:annotation>
         <xsd:documentation>This class establishes a reference to a variable. It is mainly introduced by the reverse engineering tool.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwVariableRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SW-VARIABLE-REF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class ServiceMapping::SwcComMgrUserNeeds -->
   <xsd:group name="SWC-COM-MGR-USER-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specialization of the ComMgrUserNeeds for the case it is owned by a SoftwareComponentType.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcComMgrUserNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CALLBACK-PORTS">
            <xsd:annotation>
               <xsd:documentation>This is the provided service to be called by the Com Manager to handle a particular communication channel of the Com Manager.

            The value of the role attribute in the aggregated class  must be a name of a PortInterface as standardized in "Specification ot Com Manager" (e.g. something like "modeRequester")</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcComMgrUserNeeds.callbackPort";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ROLE-BASED-P-PORT-ASSIGNMENT" type="AR:ROLE-BASED-P-PORT-ASSIGNMENT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SERVICE-CALL-PORTS">
            <xsd:annotation>
               <xsd:documentation>This is the expected service to be called by the software component to handle a particular Com Manger event.

            The value of the role attribute in the aggregated class  must be a name of a PortInterface as standardized in "Specification ot Com Manager" (e.g. something like "modeRequester")</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcComMgrUserNeeds.serviceCallPort";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ROLE-BASED-R-PORT-ASSIGNMENT" type="AR:ROLE-BASED-R-PORT-ASSIGNMENT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceMapping::SwcComMgrUserNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="SWC-COM-MGR-USER-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specialization of the ComMgrUserNeeds for the case it is owned by a SoftwareComponentType.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcComMgrUserNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:COM-MGR-USER-NEEDS"/>
         <xsd:group ref="AR:SWC-COM-MGR-USER-NEEDS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ServiceMapping::SwcDiagnosticCommunicationNeeds -->
   <xsd:group name="SWC-DIAGNOSTIC-COMMUNICATION-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specialization of the DiagnosticCommunicationNeeds for the case it is owned by a SoftwareComponentType.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcDiagnosticCommunicationNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CALLBACK-PORTS">
            <xsd:annotation>
               <xsd:documentation>This is the provided service to be called by the Diagnostic Communication Manager to handle a particular Diagnostic Communication..

            The value of the role attribute in the aggregated class  must be a name of a PortInterface as standardized in "Specification ot Diagnostic Communication Manager" (e.g. something like "CallBakReqTreatment").</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcDiagnosticCommunicationNeeds.callbackPort";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ROLE-BASED-P-PORT-ASSIGNMENT" type="AR:ROLE-BASED-P-PORT-ASSIGNMENT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SERVICE-CALL-PORT" type="AR:ROLE-BASED-R-PORT-ASSIGNMENT">
            <xsd:annotation>
               <xsd:documentation>This is the expected service to be called by the software component to handle a particular Diagnostic Communkication.

            The value of the role attribute in the aggregated class  must be a name of a PortInterface as standardized in "Specification ot Diagnostic Communication Manager" (e.g. something like "DcmService")</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcDiagnosticCommunicationNeeds.serviceCallPort";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceMapping::SwcDiagnosticCommunicationNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="SWC-DIAGNOSTIC-COMMUNICATION-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specialization of the DiagnosticCommunicationNeeds for the case it is owned by a SoftwareComponentType.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcDiagnosticCommunicationNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SWC-DIAGNOSTIC-COMMUNICATION-NEEDS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ServiceMapping::SwcDiagnosticEventNeeds -->
   <xsd:group name="SWC-DIAGNOSTIC-EVENT-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specialization of the DiagnosticEventNeeds for the case it is owned by a SoftwareComponentType. It allows to navigate to all ports associated with this diagnostic event.

      Note that there may be further ports to communicate with the DEM Service (e.g. setting the operation cycle type)  which are not included in this mapping because they are independent of the diagnostic event.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcDiagnosticEventNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CALLBACK-PORTS">
            <xsd:annotation>
               <xsd:documentation>This aggregation specifies the expected service to be called by the Diagnostic Event Manager.

            The value of the role attribute in the aggregated class must be be a name of a PortInterface as standardized in "Specification of Diagnostics Event Manager", for example CallbackInitMonitorForEvent.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcDiagnosticEventNeeds.callbackPort";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ROLE-BASED-P-PORT-ASSIGNMENT" type="AR:ROLE-BASED-P-PORT-ASSIGNMENT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SERVICE-CALL-PORTS">
            <xsd:annotation>
               <xsd:documentation>This is the expected service to be called by the software component to handle a particular diagnostic event.

            The value of the role attribute in the aggregated class  must be a name of a PortInterface as standardized in "Specification of Diagnostics Event Manager", for example "DiagnosticMonitor".</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcDiagnosticEventNeeds.serviceCallPort";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ROLE-BASED-R-PORT-ASSIGNMENT" type="AR:ROLE-BASED-R-PORT-ASSIGNMENT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceMapping::SwcDiagnosticEventNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="SWC-DIAGNOSTIC-EVENT-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specialization of the DiagnosticEventNeeds for the case it is owned by a SoftwareComponentType. It allows to navigate to all ports associated with this diagnostic event.

      Note that there may be further ports to communicate with the DEM Service (e.g. setting the operation cycle type)  which are not included in this mapping because they are independent of the diagnostic event.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcDiagnosticEventNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SWC-DIAGNOSTIC-EVENT-NEEDS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ServiceMapping::SwcEcuStateMgrUserNeeds -->
   <xsd:group name="SWC-ECU-STATE-MGR-USER-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specialization of the EcuStateMgrUserNeeds for the case it is owned  by a SoftwareComponentType. It allows to navigate to all the ports which are used by this component to put requests for this "user".

      Note that there are further ports which a component can use to obtain various information from the ECU State Manager. These ports are not included in the mapping because they will be implemented as pure function calls which can be called independently of being a certain"user".

      Note that the AUTOSAR ECU State Manager does not support callbacks to services provided by users of ECU State Manger, therefore there is not property "callbackPort".</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcEcuStateMgrUserNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SERVICE-CALL-PORTS">
            <xsd:annotation>
               <xsd:documentation>This is the expected service to be called by the software component to handle a particular User of the Ecu State Manager..

            The value of the role attribute in the aggregated class  must be a name of a PortInterface as standardized in "Specification ot ECU State Manager". Examples are "CurrentMode", "ShutdownTarget", "BootTarget" , "ApplicationMode", "StateRequest".</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcEcuStateMgrUserNeeds.serviceCallPort";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ROLE-BASED-R-PORT-ASSIGNMENT" type="AR:ROLE-BASED-R-PORT-ASSIGNMENT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceMapping::SwcEcuStateMgrUserNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="SWC-ECU-STATE-MGR-USER-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specialization of the EcuStateMgrUserNeeds for the case it is owned  by a SoftwareComponentType. It allows to navigate to all the ports which are used by this component to put requests for this "user".

      Note that there are further ports which a component can use to obtain various information from the ECU State Manager. These ports are not included in the mapping because they will be implemented as pure function calls which can be called independently of being a certain"user".

      Note that the AUTOSAR ECU State Manager does not support callbacks to services provided by users of ECU State Manger, therefore there is not property "callbackPort".</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcEcuStateMgrUserNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SWC-ECU-STATE-MGR-USER-NEEDS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ServiceMapping::SwcFunctionInhibitionNeeds -->
   <xsd:group name="SWC-FUNCTION-INHIBITION-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specialization of the FunctionInhibitionNeeds for the case it is owned by a SoftwareComponentType.

      Note that the Function Inhibit Manger does not provide callbacks to services provided by software components. Therefoer there is no property "callbackPort".</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcFunctionInhibitionNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SERVICE-CALL-PORTS">
            <xsd:annotation>
               <xsd:documentation>This is the expected service to be called by the software component to handle a particular inhibition of a particular function. This inhibition is controlled by the FunctionInhibitManager.

            The value of the role attribute in the aggregated class  must be a name of a PortInterface as standardized in "Specification ot Function Inhibition Manager". e-g- "FunctionInhibition".</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcFunctionInhibitionNeeds.serviceCallPort";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ROLE-BASED-R-PORT-ASSIGNMENT" type="AR:ROLE-BASED-R-PORT-ASSIGNMENT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceMapping::SwcFunctionInhibitionNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="SWC-FUNCTION-INHIBITION-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specialization of the FunctionInhibitionNeeds for the case it is owned by a SoftwareComponentType.

      Note that the Function Inhibit Manger does not provide callbacks to services provided by software components. Therefoer there is no property "callbackPort".</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcFunctionInhibitionNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SWC-FUNCTION-INHIBITION-NEEDS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class SwcImplementation::SwcImplementation -->
   <xsd:group name="SWC-IMPLEMENTATION">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcImplementation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="BEHAVIOR-REF">
            <xsd:annotation>
               <xsd:documentation>The internal behavior implemented by this Implementation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcImplementation.behavior";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:INTERNAL-BEHAVIOR--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PER-INSTANCE-MEMORY-SIZES">
            <xsd:annotation>
               <xsd:documentation>Allows a definition of the size of the per-instance memory for this implementation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="perInstanceMemorySize.SwcImplementation";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="PER-INSTANCE-MEMORY-SIZE" type="AR:PER-INSTANCE-MEMORY-SIZE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="REQUIRED-RTE-VENDOR" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Identify a specific RTE vendor. This information is potentially important at the time of integrating (in particular: linking) the application code with the RTE. The semantics is that (if the association exists) the corresponding code has been created to fit to the vendor-mode RTE provided by this specific vendor. Attempting to integrate the code with another RTE generated in vendor mode is in general not possible.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcImplementation.requiredRTEVendor";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SwcImplementation::SwcImplementation -->
   <xsd:complexType abstract="false" mixed="false" name="SWC-IMPLEMENTATION">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcImplementation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:IMPLEMENTATION"/>
         <xsd:group ref="AR:SWC-IMPLEMENTATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="SWC-IMPLEMENTATION--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="SWC-IMPLEMENTATION"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class ServiceMapping::SwcNvBlockNeeds -->
   <xsd:group name="SWC-NV-BLOCK-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specialization of NvBlockNeeds for the case it is owned by a SoftwareComponentType. It specifies all mappings to elements of the SoftwareComponentType concerning a single Nv block. Note that the mapping is the same for all instances of a SoftwareComponentType (because the code depends on it).

      Note that the block size is not specified here because
      - it can be derived from the associated PerInstanceMemory size (implementatiion specific) in case of implicit storage/restauration of the block
      - if can be derived from the array size passed via the correponding operations of the Service Interface in case of explicit storage/restauration of the block</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcNvBlockNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CALL-BACK-PORTS">
            <xsd:annotation>
               <xsd:documentation>This is the provided service to be called by the NvRam Manager to handle a particular NvBlock.

            The value of the role attribute in the aggregated class  must be a name of a PortInterface as standardized in "Specification of NVRAM Manager" (e.g. something like "NvMNotify")</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcNvBlockNeeds.callBackPort";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ROLE-BASED-P-PORT-ASSIGNMENT" type="AR:ROLE-BASED-P-PORT-ASSIGNMENT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="DEFAULT-BLOCK-REF">
            <xsd:annotation>
               <xsd:documentation>Defines the ROM default for an Nv block. This data can be also calibratable.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcNvBlockNeeds.defaultBlock";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:CALPRM-ELEMENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MIRROR-BLOCK-REF">
            <xsd:annotation>
               <xsd:documentation>Defines the RAM mirror in case of a permanant Nv block.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcNvBlockNeeds.mirrorBlock";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PER-INSTANCE-MEMORY--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SERVICE-CALL-PORTS">
            <xsd:annotation>
               <xsd:documentation>This is the expected service to be called by the software component to handle a particular NvBlock.

            The value of the role attribute in the aggregated class  must be a name of a PortInterface as standardized in "Specification of NVRAM Manager" (e.g. something like "NvMAdministration" , "NvMService")</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcNvBlockNeeds.serviceCallPort";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ROLE-BASED-R-PORT-ASSIGNMENT" type="AR:ROLE-BASED-R-PORT-ASSIGNMENT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceMapping::SwcNvBlockNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="SWC-NV-BLOCK-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specialization of NvBlockNeeds for the case it is owned by a SoftwareComponentType. It specifies all mappings to elements of the SoftwareComponentType concerning a single Nv block. Note that the mapping is the same for all instances of a SoftwareComponentType (because the code depends on it).

      Note that the block size is not specified here because
      - it can be derived from the associated PerInstanceMemory size (implementatiion specific) in case of implicit storage/restauration of the block
      - if can be derived from the array size passed via the correponding operations of the Service Interface in case of explicit storage/restauration of the block</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcNvBlockNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:NV-BLOCK-NEEDS"/>
         <xsd:group ref="AR:SWC-NV-BLOCK-NEEDS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ServiceMapping::SwcObdControlServiceNeeds -->
   <xsd:group name="SWC-OBD-CONTROL-SERVICE-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specialization of the ObdControlServiceNeeds for the case it is owned by a SoftwareComponentType. It allows to navigate to all ports associated with this particular TID.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcObdControlServiceNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CALLBACK-PORT" type="AR:ROLE-BASED-P-PORT-ASSIGNMENT">
            <xsd:annotation>
               <xsd:documentation>Port which must be used for reading the test result data provided by trhe Software Component.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcObdControlServiceNeeds.callbackPort";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceMapping::SwcObdControlServiceNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="SWC-OBD-CONTROL-SERVICE-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specialization of the ObdControlServiceNeeds for the case it is owned by a SoftwareComponentType. It allows to navigate to all ports associated with this particular TID.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcObdControlServiceNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:OBD-CONTROL-SERVICE-NEEDS"/>
         <xsd:group ref="AR:SWC-OBD-CONTROL-SERVICE-NEEDS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ServiceMapping::SwcObdInfoServiceNeeds -->
   <xsd:group name="SWC-OBD-INFO-SERVICE-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specialization of the ObdInfoServiceNeeds for the case it is owned by a SoftwareComponentType. It allows to navigate to all ports associated with this particular InfoType.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcObdInfoServiceNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CALLBACK-PORT" type="AR:ROLE-BASED-P-PORT-ASSIGNMENT">
            <xsd:annotation>
               <xsd:documentation>Port which must be used for reading this InfoType.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcObdInfoServiceNeeds.callbackPort";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceMapping::SwcObdInfoServiceNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="SWC-OBD-INFO-SERVICE-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specialization of the ObdInfoServiceNeeds for the case it is owned by a SoftwareComponentType. It allows to navigate to all ports associated with this particular InfoType.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcObdInfoServiceNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:OBD-INFO-SERVICE-NEEDS"/>
         <xsd:group ref="AR:SWC-OBD-INFO-SERVICE-NEEDS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ServiceMapping::SwcObdMonitorServiceNeeds -->
   <xsd:group name="SWC-OBD-MONITOR-SERVICE-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specialization of the ObdMonitorServiceNeeds for the case it is owned by a SoftwareComponentType. It allows to navigate to all ports associated with this particular ratio monitoring.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcObdMonitorServiceNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CALLBACK-PORT" type="AR:ROLE-BASED-P-PORT-ASSIGNMENT">
            <xsd:annotation>
               <xsd:documentation>Port which must be used for reading the TID data provided by trhe Software Component.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcObdMonitorServiceNeeds.callbackPort";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceMapping::SwcObdMonitorServiceNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="SWC-OBD-MONITOR-SERVICE-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specialization of the ObdMonitorServiceNeeds for the case it is owned by a SoftwareComponentType. It allows to navigate to all ports associated with this particular ratio monitoring.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcObdMonitorServiceNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:OBD-MONITOR-SERVICE-NEEDS"/>
         <xsd:group ref="AR:SWC-OBD-MONITOR-SERVICE-NEEDS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ServiceMapping::SwcObdPidServiceNeeds -->
   <xsd:group name="SWC-OBD-PID-SERVICE-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specialization of the ObdPidServiceNeeds for the case it is owned by a SoftwareComponentType. It allows to navigate to all ports associated with this particular PID.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcObdPidServiceNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CALLBACK-PORT" type="AR:ROLE-BASED-P-PORT-ASSIGNMENT">
            <xsd:annotation>
               <xsd:documentation>This aggregation specifies the expected port to be called by the Diagnostic Event Manager or Diagnosticc Communication Manager in order to read the PID value.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcObdPidServiceNeeds.callbackPort";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceMapping::SwcObdPidServiceNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="SWC-OBD-PID-SERVICE-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specialization of the ObdPidServiceNeeds for the case it is owned by a SoftwareComponentType. It allows to navigate to all ports associated with this particular PID.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcObdPidServiceNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:OBD-PID-SERVICE-NEEDS"/>
         <xsd:group ref="AR:SWC-OBD-PID-SERVICE-NEEDS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ServiceMapping::SwcObdRatioServiceNeeds -->
   <xsd:group name="SWC-OBD-RATIO-SERVICE-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specialization of the ObdRatioServicetNeeds for the case it is owned by a SoftwareComponentType. It allows to navigate to all ports associated with this element.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcObdRatioServiceNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SERVICE-CALL-PORT" type="AR:ROLE-BASED-R-PORT-ASSIGNMENT">
            <xsd:annotation>
               <xsd:documentation>Via calls from this port the Software Component is expected to handle a particular ratio monitoring.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcObdRatioServiceNeeds.serviceCallPort";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceMapping::SwcObdRatioServiceNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="SWC-OBD-RATIO-SERVICE-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specialization of the ObdRatioServicetNeeds for the case it is owned by a SoftwareComponentType. It allows to navigate to all ports associated with this element.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcObdRatioServiceNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:OBD-RATIO-SERVICE-NEEDS"/>
         <xsd:group ref="AR:SWC-OBD-RATIO-SERVICE-NEEDS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ServiceMapping::SwcSupervisedEntityNeeds -->
   <xsd:group name="SWC-SUPERVISED-ENTITY-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specialization of SupervisedEntityNeeds for the case it is owned by a SoftwareComponentType.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcSupervisedEntityNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SERVICE-CALL-PORTS">
            <xsd:annotation>
               <xsd:documentation>This is the expected service to be called by the software component to handle a supervised entity by the watchdoc.

            The value of the role attribute in the aggregated class  must be a name of a PortInterface as standardized in "Specification of Watchdog Manager" (e.g. something like "WdgMService")</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcSupervisedEntityNeeds.serviceCallPort";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ROLE-BASED-R-PORT-ASSIGNMENT" type="AR:ROLE-BASED-R-PORT-ASSIGNMENT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ServiceMapping::SwcSupervisedEntityNeeds -->
   <xsd:complexType abstract="false" mixed="false" name="SWC-SUPERVISED-ENTITY-NEEDS">
      <xsd:annotation>
         <xsd:documentation>Specialization of SupervisedEntityNeeds for the case it is owned by a SoftwareComponentType.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcSupervisedEntityNeeds"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SUPERVISED-ENTITY-NEEDS"/>
         <xsd:group ref="AR:SWC-SUPERVISED-ENTITY-NEEDS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class SWmapping::SwcToEcuMapping -->
   <xsd:group name="SWC-TO-ECU-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Map software components to a specific ECU Instance.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcToEcuMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPONENT-IREFS">
            <xsd:annotation>
               <xsd:documentation>References to the software component instances that are mapped to the referenced ECUInstance. If the component prototype referenced is a composition, this indicates that all atomic software components within the composition are mapped to the ECU. 

            If there is aditionally a mapping of some ComponentPrototype INSIDE the Composition to another ECU Instance the inner mapping overrides the outer mapping.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="component.SwcToEcuMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="COMPONENT-IREF" type="AR:SW-COMP-TO-ECU-MAPPING--COMPONENT-IREF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECU-INSTANCE-REF">
            <xsd:annotation>
               <xsd:documentation>EcuInstance is a reference to an ECU Instance description</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcToEcuMapping.ecuInstance";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:ECU-INSTANCE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SWmapping::SwcToEcuMapping -->
   <xsd:complexType abstract="false" mixed="false" name="SWC-TO-ECU-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Map software components to a specific ECU Instance.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcToEcuMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SWC-TO-ECU-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="SWC-TO-ECU-MAPPING--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="SWC-TO-ECU-MAPPING"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class SWmapping::SwcToEcuMappingConstraint -->
   <xsd:group name="SWC-TO-ECU-MAPPING-CONSTRAINT">
      <xsd:annotation>
         <xsd:documentation>The System Constraint Description has to describe dedicated and exclusive mapping of SW-Cs to one or more ECUs. Dedicated mapping means that the SW-C can only be mapped to the ECUs it is dedicated to. Exclusive Mapping means that the SW-C cannot be mapped to the ECUs it is excluded from.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcToEcuMappingConstraint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPONENT-IREFS">
            <xsd:annotation>
               <xsd:documentation>Reference to ComponentPrototypes for which the dedicated or exclusive mapping is defined.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="component.SwcToEcuMappingConstraint";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="COMPONENT-IREF" type="AR:SWC-TO-ECU-MAPPING-CONSTRAINT--COMPONENT-IREF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECU-INSTANCE-REFS">
            <xsd:annotation>
               <xsd:documentation>If the dedicated mapping is described, the ComponentPrototypes can only be mapped to these referenced ECUInstances. 

            If the exclusive mapping is described, the ComponentPrototypes cannot be mapped to these referenced ECUInstances.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcToEcuMappingConstraint.ecuInstance";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ECU-INSTANCE-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:ECU-INSTANCE--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SWC-TO-ECU-MAPPING-CONSTRAINT-TYPE" type="AR:SWC-TO-ECU-MAPPING-CONSTRAINT-TYPE">
            <xsd:annotation>
               <xsd:documentation>This attribute determines if dedicated or exclusive mapping is used.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcToEcuMappingConstraint.swcToEcuMappingConstraintType";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SWmapping::SwcToEcuMappingConstraint -->
   <xsd:complexType abstract="false" mixed="false" name="SWC-TO-ECU-MAPPING-CONSTRAINT">
      <xsd:annotation>
         <xsd:documentation>The System Constraint Description has to describe dedicated and exclusive mapping of SW-Cs to one or more ECUs. Dedicated mapping means that the SW-C can only be mapped to the ECUs it is dedicated to. Exclusive Mapping means that the SW-C cannot be mapped to the ECUs it is excluded from.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcToEcuMappingConstraint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SWC-TO-ECU-MAPPING-CONSTRAINT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class _instanceRef::SwcToEcuMappingConstraint_component -->
   <xsd:group name="SWC-TO-ECU-MAPPING-CONSTRAINT--COMPONENT-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcToEcuMappingConstraint_component"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SOFTWARE-COMPOSITION-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcToEcuMappingConstraint_component.softwareComposition";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="10"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SOFTWARE-COMPOSITION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="COMPONENT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcToEcuMappingConstraint_component.componentPrototype";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMPONENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="1" name="TARGET-COMPONENT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcToEcuMappingConstraint_component.targetComponentPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.target</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMPONENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class _instanceRef::SwcToEcuMappingConstraint_component -->
   <xsd:complexType abstract="false" mixed="false" name="SWC-TO-ECU-MAPPING-CONSTRAINT--COMPONENT-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcToEcuMappingConstraint_component"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SWC-TO-ECU-MAPPING-CONSTRAINT--COMPONENT-IREF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class SWmapping::SwcToImplMapping -->
   <xsd:group name="SWC-TO-IMPL-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Map instances of an AtomicSoftwareComponentType to a specific Implementation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcToImplMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPONENT-IMPLEMENTATION-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to a specific Implementation description.

            Implementation to be used by the specified SW component instance. This allows to achieve more precise estimates for the resource consumption that results from mapping the instance of an atomic SW component onto an ECU.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcToImplMapping.componentImplementation";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SWC-IMPLEMENTATION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COMPONENT-IREFS">
            <xsd:annotation>
               <xsd:documentation>Reference to the software component instances that are being mapped to the specified Implementation. The targeted ComponentPrototype needs be of the AtomicSoftwareComponentType being implemented by the referenced Implementation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="component.SwcToImplMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="COMPONENT-IREF" type="AR:SW-COMP-TO-IMPL-MAPPING--COMPONENT-IREF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SWmapping::SwcToImplMapping -->
   <xsd:complexType abstract="false" mixed="false" name="SWC-TO-IMPL-MAPPING">
      <xsd:annotation>
         <xsd:documentation>Map instances of an AtomicSoftwareComponentType to a specific Implementation.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcToImplMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SWC-TO-IMPL-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class SignalPaths::SwcToSwcOperationArguments -->
   <xsd:group name="SWC-TO-SWC-OPERATION-ARGUMENTS">
      <xsd:annotation>
         <xsd:documentation>The SwcToSwcOperationArguments describes the information (client server operation arguments, plus the operation identification, if required) that are exchanged between two SW Components from exactly one client to one server, or from one server back to one client. The direction attribute defines which direction is described. If direction == IN, all arguments sent from the client to the server are described by the SwcToSwcOperationArguments, in direction == OUT, it's the arguments sent back from server to client.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcToSwcOperationArguments"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DIRECTION" type="AR:SWC-TO-SWC-OPERATION-ARGUMENTS-DIRECTION-ENUM">
            <xsd:annotation>
               <xsd:documentation>direction addressed by this SwcToSwcClientServerOperation element.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcToSwcOperationArguments.direction";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="OPERATION-IREFS">
            <xsd:annotation>
               <xsd:documentation>Reference to the operation at the client and at the server side whose arguments are described by SwcToSwcOperationArguments. The two ports referenced must be connected by a connector in the software component description.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="operation.SwcToSwcOperationArguments";pureMM.maxOccurs="2";pureMM.minOccurs="2"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="2" minOccurs="0">
                  <xsd:element name="OPERATION-IREF" type="AR:SWC-TO-SWC-OPERATION-ARGUMENTS--OPERATION-IREF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SignalPaths::SwcToSwcOperationArguments -->
   <xsd:complexType abstract="false" mixed="false" name="SWC-TO-SWC-OPERATION-ARGUMENTS">
      <xsd:annotation>
         <xsd:documentation>The SwcToSwcOperationArguments describes the information (client server operation arguments, plus the operation identification, if required) that are exchanged between two SW Components from exactly one client to one server, or from one server back to one client. The direction attribute defines which direction is described. If direction == IN, all arguments sent from the client to the server are described by the SwcToSwcOperationArguments, in direction == OUT, it's the arguments sent back from server to client.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcToSwcOperationArguments"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SWC-TO-SWC-OPERATION-ARGUMENTS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class _instanceRef::SwcToSwcOperationArguments_operation -->
   <xsd:group name="SWC-TO-SWC-OPERATION-ARGUMENTS--OPERATION-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcToSwcOperationArguments_operation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SOFTWARE-COMPOSITION-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcToSwcOperationArguments_operation.softwareComposition";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="10"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SOFTWARE-COMPOSITION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="COMPONENT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcToSwcOperationArguments_operation.componentPrototype";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMPONENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PORT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcToSwcOperationArguments_operation.portPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="1" name="OPERATION-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcToSwcOperationArguments_operation.operationPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="40"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.target</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:OPERATION-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class _instanceRef::SwcToSwcOperationArguments_operation -->
   <xsd:complexType abstract="false" mixed="false" name="SWC-TO-SWC-OPERATION-ARGUMENTS--OPERATION-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcToSwcOperationArguments_operation"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SWC-TO-SWC-OPERATION-ARGUMENTS--OPERATION-IREF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class SignalPaths::SwcToSwcSignal -->
   <xsd:group name="SWC-TO-SWC-SIGNAL">
      <xsd:annotation>
         <xsd:documentation>The SwcToSwcSignal describes the information (data element) that is exchanged between two SW Components. On the SWC Level it is possible that a SW Component sends one data element from one P-Port to two different SW Components (1:n Communication). The SwcToSwcSignal describes exactly the information which is exchanged between one P-Port of a SW Component and one R-Port of another SW Component.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcToSwcSignal"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-ELEMENT-IREFS">
            <xsd:annotation>
               <xsd:documentation>Reference to a data element on the PPort and to the same data element on the RPort. 
            Reference to a data element on the PPort and to the same data element on the RPort. 
            Reference to a data element on the PPort and to the same data element on the RPort.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="dataElement.SwcToSwcSignal";pureMM.maxOccurs="2";pureMM.minOccurs="2"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="2" minOccurs="0">
                  <xsd:element name="DATA-ELEMENT-IREF" type="AR:SWC-TO-SWC-SIGNAL--DATA-ELEMENT-IREF"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SignalPaths::SwcToSwcSignal -->
   <xsd:complexType abstract="false" mixed="false" name="SWC-TO-SWC-SIGNAL">
      <xsd:annotation>
         <xsd:documentation>The SwcToSwcSignal describes the information (data element) that is exchanged between two SW Components. On the SWC Level it is possible that a SW Component sends one data element from one P-Port to two different SW Components (1:n Communication). The SwcToSwcSignal describes exactly the information which is exchanged between one P-Port of a SW Component and one R-Port of another SW Component.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcToSwcSignal"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SWC-TO-SWC-SIGNAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class _instanceRef::SwcToSwcSignal_dataElement -->
   <xsd:group name="SWC-TO-SWC-SIGNAL--DATA-ELEMENT-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcToSwcSignal_dataElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SOFTWARE-COMPOSITION-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcToSwcSignal_dataElement.softwareComposition";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="10"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:SOFTWARE-COMPOSITION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="unbounded" minOccurs="0" name="COMPONENT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcToSwcSignal_dataElement.componentPrototype";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:COMPONENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PORT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcToSwcSignal_dataElement.portPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="30"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.context</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PORT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="1" name="DATA-ELEMENT-PROTOTYPE-REF">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SwcToSwcSignal_dataElement.dataElementPrototype";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="40"</xsd:appinfo>
               <xsd:appinfo source="stereotypes">instanceRef.target</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:DATA-ELEMENT-PROTOTYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class _instanceRef::SwcToSwcSignal_dataElement -->
   <xsd:complexType abstract="false" mixed="false" name="SWC-TO-SWC-SIGNAL--DATA-ELEMENT-IREF">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SwcToSwcSignal_dataElement"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,instanceRef</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SWC-TO-SWC-SIGNAL--DATA-ELEMENT-IREF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- complex type for class ECUCParameterDefTemplate::SymbolicNameReferenceParamDef -->
   <xsd:complexType abstract="false" mixed="false" name="SYMBOLIC-NAME-REFERENCE-PARAM-DEF">
      <xsd:annotation>
         <xsd:documentation>This specialization of a ReferenceParamDef specifies that the implementation of the reference is done using a symbolic name defined by the referenced Container's shortName.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SymbolicNameReferenceParamDef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:PARAM-CONF-MULTIPLICITY"/>
         <xsd:group ref="AR:COMMON-CONFIGURATION-ATTRIBUTES"/>
         <xsd:group ref="AR:REFERENCE-PARAM-DEF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- complex type for class ServerCall::SynchronousServerCallPoint -->
   <xsd:complexType abstract="false" mixed="false" name="SYNCHRONOUS-SERVER-CALL-POINT">
      <xsd:annotation>
         <xsd:documentation>This means that the runnable will block for a response from the server.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SynchronousServerCallPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SERVER-CALL-POINT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class SystemTemplate::System -->
   <xsd:group name="SYSTEM">
      <xsd:annotation>
         <xsd:documentation>The top level element of the System Description.
      The System description defines five major elements: Topology, Software, Communication, Mapping and Mapping Constraints.

      The System element directly aggregates the elements describing the Software, Mapping and Mapping Constraints; it contains a reference to an ASAM FIBEX description specifying Communication and Topology.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="System"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpStructureElement</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECU-EXTRACT-VERSION" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Version number of the Ecu Extract.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="System.ecuExtractVersion";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FIBEX-ELEMENT-REFS">
            <xsd:annotation>
               <xsd:documentation>Reference to ASAM FIBEX elements specifying Communication and Topology.

            All Fibex Elements used within a System Description shall 
            be referenced from the System Element.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="System.fibexElement";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="FIBEX-ELEMENT-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:FIBEX-ELEMENT--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAPPING" type="AR:SYSTEM-MAPPING">
            <xsd:annotation>
               <xsd:documentation>Aggregation of all mapping aspects (mapping of SW components to ECUs, mapping of data elements to signals, and mapping constraints).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="mapping.System";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PNC-VECTOR-LENGTH" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Length of the partial networking request release information vector.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="System.pncVectorLength";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PNC-VECTOR-OFFSET" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Absolute offset (with respect to the Frame) of the partial networking request release information vector.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="System.pncVectorOffset";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SOFTWARE-COMPOSITION" type="AR:SOFTWARE-COMPOSITION">
            <xsd:annotation>
               <xsd:documentation>Aggregation of the top-level software composition, containing all software components in the System in a hierarchical structure.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="softwareComposition.System";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYSTEM-VERSION" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>Version number of the System Description.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="System.systemVersion";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SystemTemplate::System -->
   <xsd:complexType abstract="false" mixed="false" name="SYSTEM">
      <xsd:annotation>
         <xsd:documentation>The top level element of the System Description.
      The System description defines five major elements: Topology, Software, Communication, Mapping and Mapping Constraints.

      The System element directly aggregates the elements describing the Software, Mapping and Mapping Constraints; it contains a reference to an ASAM FIBEX description specifying Communication and Topology.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="System"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject,atpStructureElement</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SYSTEM"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="SYSTEM--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="SYSTEM"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class SystemTemplate::SystemMapping -->
   <xsd:group name="SYSTEM-MAPPING">
      <xsd:annotation>
         <xsd:documentation>The system mapping aggregates all mapping aspects (mapping of SW components to ECUs, mapping of data elements to signals, and mapping constraints).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SystemMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>The data mappings defined.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="dataMapping.SystemMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CLIENT-SERVER-TO-SIGNAL-GROUP-MAPPING" type="AR:CLIENT-SERVER-TO-SIGNAL-GROUP-MAPPING"/>
                  <xsd:element name="SENDER-RECEIVER-TO-SIGNAL-GROUP-MAPPING" type="AR:SENDER-RECEIVER-TO-SIGNAL-GROUP-MAPPING"/>
                  <xsd:element name="SENDER-RECEIVER-TO-SIGNAL-MAPPING" type="AR:SENDER-RECEIVER-TO-SIGNAL-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="ECU-RESOURCE-MAPPINGS">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="ecuResourceMapping.SystemMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ECU-MAPPING" type="AR:ECU-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAPPING-CONSTRAINTS">
            <xsd:annotation>
               <xsd:documentation>Constraints that limit the mapping freedom for the mapping of SW components to ECUs.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="mappingConstraint.SystemMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="COMPONENT-CLUSTERING" type="AR:COMPONENT-CLUSTERING"/>
                  <xsd:element name="COMPONENT-SEPARATION" type="AR:COMPONENT-SEPARATION"/>
                  <xsd:element name="SWC-TO-ECU-MAPPING-CONSTRAINT" type="AR:SWC-TO-ECU-MAPPING-CONSTRAINT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PNC-MAPPINGS">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="pncMapping.SystemMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="PNC-MAPPING" type="AR:PNC-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RESOURCE-ESTIMATIONS">
            <xsd:annotation>
               <xsd:documentation>Resource estimations for this set of mappings, zero or one per ECU instance.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="resourceEstimation.SystemMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="ECU-RESOURCE-ESTIMATION" type="AR:ECU-RESOURCE-ESTIMATION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SIGNAL-PATH-CONSTRAINTS">
            <xsd:annotation>
               <xsd:documentation>Constraints that limit the mapping freedom for the mapping of data elements to signals.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="signalPathConstraint.SystemMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="COMMON-SIGNAL-PATH" type="AR:COMMON-SIGNAL-PATH"/>
                  <xsd:element name="FORBIDDEN-SIGNAL-PATH" type="AR:FORBIDDEN-SIGNAL-PATH"/>
                  <xsd:element name="PERMISSIBLE-SIGNAL-PATH" type="AR:PERMISSIBLE-SIGNAL-PATH"/>
                  <xsd:element name="SEPARATE-SIGNAL-PATH" type="AR:SEPARATE-SIGNAL-PATH"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-IMPL-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>The mappings of AtomicSoftwareComponent Instances to Implementations.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="swImplMapping.SystemMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SWC-TO-IMPL-MAPPING" type="AR:SWC-TO-IMPL-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SW-MAPPINGS">
            <xsd:annotation>
               <xsd:documentation>The mappings of SW components to ECUs.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="swMapping.SystemMapping";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SWC-TO-ECU-MAPPING" type="AR:SWC-TO-ECU-MAPPING"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class SystemTemplate::SystemMapping -->
   <xsd:complexType abstract="false" mixed="false" name="SYSTEM-MAPPING">
      <xsd:annotation>
         <xsd:documentation>The system mapping aggregates all mapping aspects (mapping of SW components to ECUs, mapping of data elements to signals, and mapping constraints).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SystemMapping"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SYSTEM-MAPPING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class CoreCommunication::SystemSignal -->
   <xsd:group name="SYSTEM-SIGNAL">
      <xsd:annotation>
         <xsd:documentation>The system signal represents the communication system's view of data exchanged between SW components which reside on different ECUs. The system signals allow to represent this communication in a flattened structure, with exactly one system signal defined for each data element prototype sent and received by connected SW component instances.
       
      According to the COM Specification, signal groups without signals are allowed. These have a "signalLength" = 0. In this case there shall be an "update-bit" configured.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SystemSignal"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-TYPE-REF">
            <xsd:annotation>
               <xsd:documentation>Optional reference to a SystemSignal's datatype in case the System Description doesn't use a complete Software Component Description (VFB View). This supports the inclusion of legacy system signals. 

            This reference can be used to configure the "ComSignalDataInvalidValue" and the Data Semantics. 

            If a full DataMapping exist for the SystemSignal this information is additionally available from the mapped DataElement. In this case the referenced datatypes needs to be compatible.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SystemSignal.dataType";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PRIMITIVE-TYPE--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INIT-VALUE-REF">
            <xsd:annotation>
               <xsd:documentation>Optional reference to a SystemSignal's initValue in case the System Description doesn't use a complete Software Component Description (VFB View). This supports the inclusion of legacy system signals. 

            This reference can be used to configure the Signal's "InitValue". 

            If a full DataMapping exist for the SystemSignal this information may be available from a configured SenderComSpec and ReceiverComSpec. 
            In this case the initvalues in SenderComSpec and/or ReceiverComSpec override this optional value specification. Further restrictions apply from the RTE specification.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SystemSignal.initValue";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:VALUE-SPECIFICATION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="LENGTH" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Size of the signal in bits.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SystemSignal.length";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::SystemSignal -->
   <xsd:complexType abstract="false" mixed="false" name="SYSTEM-SIGNAL">
      <xsd:annotation>
         <xsd:documentation>The system signal represents the communication system's view of data exchanged between SW components which reside on different ECUs. The system signals allow to represent this communication in a flattened structure, with exactly one system signal defined for each data element prototype sent and received by connected SW component instances.
       
      According to the COM Specification, signal groups without signals are allowed. These have a "signalLength" = 0. In this case there shall be an "update-bit" configured.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SystemSignal"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SYSTEM-SIGNAL"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="SYSTEM-SIGNAL--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="SYSTEM-SIGNAL"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class CoreCommunication::SystemSignalGroup -->
   <xsd:group name="SYSTEM-SIGNAL-GROUP">
      <xsd:annotation>
         <xsd:documentation>A signal group refers to a set of signals that must always be kept together. A signal group is used to guarantee the atomic transfer of AUTOSAR composite data types.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SystemSignalGroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SYSTEM-SIGNAL-REFS">
            <xsd:annotation>
               <xsd:documentation>Reference to a set of signals that must always be kept together.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="SystemSignalGroup.systemSignal";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="SYSTEM-SIGNAL-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:SYSTEM-SIGNAL--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::SystemSignalGroup -->
   <xsd:complexType abstract="false" mixed="false" name="SYSTEM-SIGNAL-GROUP">
      <xsd:annotation>
         <xsd:documentation>A signal group refers to a set of signals that must always be kept together. A signal group is used to guarantee the atomic transfer of AUTOSAR composite data types.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="SystemSignalGroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:SYSTEM-SIGNAL-GROUP"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="SYSTEM-SIGNAL-GROUP--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="SYSTEM-SIGNAL-GROUP"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Fibex4Multiplatform::TargetIPduRef -->
   <xsd:group name="TARGET-I-PDU-REF">
      <xsd:annotation>
         <xsd:documentation>Target destination of the referencing mapping.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TargetIPduRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DEFAULT-VALUE" type="AR:PDU-MAPPING-DEFAULT-VALUE">
            <xsd:annotation>
               <xsd:documentation>If no I-Pdu has been received a default value will be distributed.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="defaultValue.TargetIPduRef";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TARGET-I-PDU-REF">
            <xsd:annotation>
               <xsd:documentation>IPdu Reference</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TargetIPduRef.targetIPdu";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:I-PDU-TRIGGERING--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Fibex4Multiplatform::TargetIPduRef -->
   <xsd:complexType abstract="false" mixed="false" name="TARGET-I-PDU-REF">
      <xsd:annotation>
         <xsd:documentation>Target destination of the referencing mapping.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TargetIPduRef"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:TARGET-I-PDU-REF"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class BasicElements::Temperature -->
   <xsd:group name="TEMPERATURE">
      <xsd:annotation>
         <xsd:documentation>General element to describe temperature ranges and need for cooling/heating.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Temperature"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="NEEDS-COOLING" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>These attributes describe that there is an active cooling system required for this HW Element.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Temperature.needsCooling";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="NEEDS-HEATING" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>These attributes describe that there is an active heating system required for this HW Element.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Temperature.needsHeating";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="OPERATION-MAX" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>It describes the temperature range (max) in which the HW Element can be operated.
            Unit: Kelvin (K)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Temperature.operationMax";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="OPERATION-MIN" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>It describes the temperature range (min) in which the HW Element can be operated.
            Unit: Kelvin (K)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Temperature.operationMin";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="OPERATION-TYPICAL" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>It describes the temperature range (typical) in which the HW Element can be operated.
            Unit: Kelvin (K)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Temperature.operationTypical";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="STORAGE-MAX" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The storage temperature defines maximum temperature the device is allowed to be stored. The HW Element is not in an operational state.
            Unit: Kelvin (K)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Temperature.storageMax";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="STORAGE-MIN" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>The storage temperature defines minimum temperature the device is allowed to be stored. The HW Element is not in an operational state.
            Unit: Kelvin (K)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Temperature.storageMin";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BasicElements::Temperature -->
   <xsd:complexType abstract="false" mixed="false" name="TEMPERATURE">
      <xsd:annotation>
         <xsd:documentation>General element to describe temperature ranges and need for cooling/heating.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Temperature"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:TEMPERATURE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class BasicElements::TimeRange -->
   <xsd:group name="TIME-RANGE">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TimeRange"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAX" type="xsd:double">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TimeRange.max";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MIN" type="xsd:double">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TimeRange.min";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TYPICAL" type="xsd:double">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TimeRange.typical";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class BasicElements::TimeRange -->
   <xsd:complexType abstract="false" mixed="false" name="TIME-RANGE">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TimeRange"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:TIME-RANGE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Timing::TimeRangeType -->
   <xsd:group name="TIME-RANGE-TYPE">
      <xsd:annotation>
         <xsd:documentation>The timeRange can be specified with the value attribute. Optionally a tolerance can be defined.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TimeRangeType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TOLERANCE">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="tolerance.TimeRangeType";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="ABSOLUTE-TOLERANCE" type="AR:ABSOLUTE-TOLERANCE"/>
                  <xsd:element name="RELATIVE-TOLERANCE" type="AR:RELATIVE-TOLERANCE"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="VALUE" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Average value of a date (in seconds)</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TimeRangeType.value";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Timing::TimeRangeType -->
   <xsd:complexType abstract="false" mixed="false" name="TIME-RANGE-TYPE">
      <xsd:annotation>
         <xsd:documentation>The timeRange can be specified with the value attribute. Optionally a tolerance can be defined.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TimeRangeType"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:TIME-RANGE-TYPE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Peripherals::Timer -->
   <xsd:group name="TIMER">
      <xsd:annotation>
         <xsd:documentation>The simplest form is an array of directly coupled D-flip flops, which build up a shift register, with separate output from each stage, thus forming a time-register. A clock signal at the input increments the value of the register. Some cases uses some logic in combination of the shift register in order to form a special adopted representation of the information or to fulfil special requirements.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Timer"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CAN-BE-RE-INIT" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Defines if the peripheral can automatically be reset during operation.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Timer.canBeReInit";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="COUNT-DIRECTION" type="AR:TIMER-COUNT-DIRECTION-ENUM">
            <xsd:annotation>
               <xsd:documentation>The direction defines if the counter of a timer counts up, down or if it can be selected.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Timer.countDirection";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODE" type="AR:TIMER-MODE-ENUM">
            <xsd:annotation>
               <xsd:documentation>single: The timer is counted from a defined start value to a defined end value and then stopped. 
            continuous: The timer is counted from a defined start value to a defined end value and then restarted with the start value.
            free: The timer is counted always to the available maximum value of the timer structure, then a wrap around occurs and the timer starts again from the HW defined startpoint; e.g. a 16 bit Timer counts from 0(hex)....0FFFF(hex), then after the overflow again from 0(hex)....0FFFF(hex).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Timer.mode";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Peripherals::Timer -->
   <xsd:complexType abstract="false" mixed="false" name="TIMER">
      <xsd:annotation>
         <xsd:documentation>The simplest form is an array of directly coupled D-flip flops, which build up a shift register, with separate output from each stage, thus forming a time-register. A clock signal at the input increments the value of the register. Some cases uses some logic in combination of the shift register in order to form a special adopted representation of the information or to fulfil special requirements.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Timer"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HW-ELEMENT"/>
         <xsd:group ref="AR:PERIPHERAL"/>
         <xsd:group ref="AR:GENERAL-PURPOSE-TIMER"/>
         <xsd:group ref="AR:TIMER"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class RTEEvents::TimingEvent -->
   <xsd:group name="TIMING-EVENT">
      <xsd:annotation>
         <xsd:documentation>TimingEvent references the runnable that need to be started in response to the TimingEvent</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TimingEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="PERIOD" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Period of timing event in seconds.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TimingEvent.period";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class RTEEvents::TimingEvent -->
   <xsd:complexType abstract="false" mixed="false" name="TIMING-EVENT">
      <xsd:annotation>
         <xsd:documentation>TimingEvent references the runnable that need to be started in response to the TimingEvent</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TimingEvent"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:RTE-EVENT"/>
         <xsd:group ref="AR:TIMING-EVENT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class TransportProtocols::TpAddress -->
   <xsd:group name="TP-ADDRESS">
      <xsd:annotation>
         <xsd:documentation>An ECUs TP address on the referenced channel. This represents the diagnostic Address.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TpAddress"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TP-ADDRESS" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>An ECUs TP address on the referenced channel. This represents the diagnostic Address.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TpAddress.tpAddress";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class TransportProtocols::TpAddress -->
   <xsd:complexType abstract="false" mixed="false" name="TP-ADDRESS">
      <xsd:annotation>
         <xsd:documentation>An ECUs TP address on the referenced channel. This represents the diagnostic Address.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TpAddress"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:TP-ADDRESS"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="TP-ADDRESS--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="TP-ADDRESS"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class TransportProtocols::TpNode -->
   <xsd:group name="TP-NODE">
      <xsd:annotation>
         <xsd:documentation>TP Node (Sender or Receiver) provides the TP Address and the connection to the Topology description.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TpNode"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CONNECTOR-REFS">
            <xsd:annotation>
               <xsd:documentation>Asscociation  to one or more physical connectors (max number of connectors for FlexRay: 2).

            In a System Description this reference is mandatory. In an ECU Extract this reference is optional (references to ECUs that are not part of the ECU Extract shall be avoided).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TpNode.connector";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="CONNECTOR-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:COMMUNICATION-CONNECTOR--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TP-ADDRESS-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to the TP Address that is used by the TpNode. This reference is optional in case that the multicast TP Address is used (reference from TpConnection).</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TpNode.tpAddress";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:TP-ADDRESS--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- element group for class Communication::TransmissionAcknowledgementRequest -->
   <xsd:group name="TRANSMISSION-ACKNOWLEDGEMENT-REQUEST">
      <xsd:annotation>
         <xsd:documentation>Requests transmission acknowledgement that data has been sent successfully. Success/failure is reported via a SendPoint of a Runnable.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TransmissionAcknowledgementRequest"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMEOUT" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Number of seconds before an error is reported or in case of allowed redundancy, the value is sent again.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TransmissionAcknowledgementRequest.timeout";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Communication::TransmissionAcknowledgementRequest -->
   <xsd:complexType abstract="false" mixed="false" name="TRANSMISSION-ACKNOWLEDGEMENT-REQUEST">
      <xsd:annotation>
         <xsd:documentation>Requests transmission acknowledgement that data has been sent successfully. Success/failure is reported via a SendPoint of a Runnable.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TransmissionAcknowledgementRequest"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:TRANSMISSION-ACKNOWLEDGEMENT-REQUEST"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Timing::TransmissionModeCondition -->
   <xsd:group name="TRANSMISSION-MODE-CONDITION">
      <xsd:annotation>
         <xsd:documentation>Possibility to attach a condition to each signal within an I-PDU.

      If at least one condition evaluates to true,
      TRANSMISSION MODE True shall be used for this I-Pdu. In all other cases, the TRANSMISSION MODE FALSE shall be used.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TransmissionModeCondition"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DATA-FILTER">
            <xsd:annotation>
               <xsd:documentation>Possibilities to define conditions</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="dataFilter.TransmissionModeCondition";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="1" minOccurs="0">
                  <xsd:element name="ALWAYS" type="AR:ALWAYS"/>
                  <xsd:element name="MASKED-NEW-DIFFERS-MASKED-OLD" type="AR:MASKED-NEW-DIFFERS-MASKED-OLD"/>
                  <xsd:element name="MASKED-NEW-DIFFERS-X" type="AR:MASKED-NEW-DIFFERS-X"/>
                  <xsd:element name="MASKED-NEW-EQUALS-X" type="AR:MASKED-NEW-EQUALS-X"/>
                  <xsd:element name="NEVER" type="AR:NEVER"/>
                  <xsd:element name="NEW-IS-OUTSIDE" type="AR:NEW-IS-OUTSIDE"/>
                  <xsd:element name="NEW-IS-WITHIN" type="AR:NEW-IS-WITHIN"/>
                  <xsd:element name="ONE-EVERY-N" type="AR:ONE-EVERY-N"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="SIGNAL-IN-I-PDU-REF">
            <xsd:annotation>
               <xsd:documentation>Reference to a signal to which a condition is attached.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="TransmissionModeCondition.signalInIPdu";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:I-SIGNAL-TO-I-PDU-MAPPING--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Timing::TransmissionModeCondition -->
   <xsd:complexType abstract="false" mixed="false" name="TRANSMISSION-MODE-CONDITION">
      <xsd:annotation>
         <xsd:documentation>Possibility to attach a condition to each signal within an I-PDU.

      If at least one condition evaluates to true,
      TRANSMISSION MODE True shall be used for this I-Pdu. In all other cases, the TRANSMISSION MODE FALSE shall be used.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TransmissionModeCondition"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:TRANSMISSION-MODE-CONDITION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Timing::TransmissionModeDeclaration -->
   <xsd:group name="TRANSMISSION-MODE-DECLARATION">
      <xsd:annotation>
         <xsd:documentation>AUTOSAR COM provides the possibility to define two different TRANSMISSION MODES (True and False) for each I-PDU. In case only the TRUE transmission mode is used there is no need for the "TransmissionModeDeclaration" and its sub-structure.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TransmissionModeDeclaration"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TRANSMISSION-MODE-CONDITIONS">
            <xsd:annotation>
               <xsd:documentation>The Transmission Mode Selector evaluates the conditions for a subset of signals and decides which transmission mode should be used.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="transmissionModeCondition.TransmissionModeDeclaration";pureMM.maxOccurs="-1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="TRANSMISSION-MODE-CONDITION" type="AR:TRANSMISSION-MODE-CONDITION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TRANSMISSION-MODE-FALSE-TIMING" type="AR:TRANSMISSION-MODE-FALSE-TIMING">
            <xsd:annotation>
               <xsd:documentation>Timing Specification if the COM Transmission Mode is false.  
            The Transmission Mode Selector is defined to be false, if all Conditions evaluate to false.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="transmissionModeFalseTiming.TransmissionModeDeclaration";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Timing::TransmissionModeDeclaration -->
   <xsd:complexType abstract="false" mixed="false" name="TRANSMISSION-MODE-DECLARATION">
      <xsd:annotation>
         <xsd:documentation>AUTOSAR COM provides the possibility to define two different TRANSMISSION MODES (True and False) for each I-PDU. In case only the TRUE transmission mode is used there is no need for the "TransmissionModeDeclaration" and its sub-structure.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TransmissionModeDeclaration"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:TRANSMISSION-MODE-DECLARATION"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Timing::TransmissionModeFalseTiming -->
   <xsd:group name="TRANSMISSION-MODE-FALSE-TIMING">
      <xsd:annotation>
         <xsd:documentation>If the COM Transmission Mode is false the timing is aggregated by the TransmissionModeIFalseTiming element.  If the COM Transmission Mode is true the timing is aggregated by the SignalIPdu/IPduTiming element.  

      COM supports the following Transmission Modes: 
      Periodic (Cyclic Timing)
      Direct /n-times (EventControlledTiming)
      Mixed (Cyclic and EventControlledTiming are assigned)
      None (no timing is assigned)</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TransmissionModeFalseTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CYCLIC-TIMING" type="AR:CYCLIC-TIMING">
            <xsd:annotation>
               <xsd:documentation>Periodic Transmission Mode.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="cyclicTiming.TransmissionModeFalseTiming";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="EVENT-CONTROLLED-TIMING" type="AR:EVENT-CONTROLLED-TIMING">
            <xsd:annotation>
               <xsd:documentation>Direct Transmission Mode.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="eventControlledTiming.TransmissionModeFalseTiming";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Timing::TransmissionModeFalseTiming -->
   <xsd:complexType abstract="false" mixed="false" name="TRANSMISSION-MODE-FALSE-TIMING">
      <xsd:annotation>
         <xsd:documentation>If the COM Transmission Mode is false the timing is aggregated by the TransmissionModeIFalseTiming element.  If the COM Transmission Mode is true the timing is aggregated by the SignalIPdu/IPduTiming element.  

      COM supports the following Transmission Modes: 
      Periodic (Cyclic Timing)
      Direct /n-times (EventControlledTiming)
      Mixed (Cyclic and EventControlledTiming are assigned)
      None (no timing is assigned)</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="TransmissionModeFalseTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:TRANSMISSION-MODE-FALSE-TIMING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- complex type for class Inlines::Tt -->
   <xsd:complexType abstract="false" mixed="true" name="TT">
      <xsd:annotation>
         <xsd:documentation>Use &lt;tt&gt; to format technical terms within the paragraph element.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Tt"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0"/>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class LinCommunication::UnassignFrameIdTiming -->
   <xsd:group name="UNASSIGN-FRAME-ID-TIMING">
      <xsd:annotation>
         <xsd:documentation>Schedule entry for an Unassign Frame Id master request where the protected identifier is assigned the value 0x40. This will disable reception/transmission of a previously dynamically assigned frame identifier.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="UnassignFrameIdTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="UNASSIGNED-FRAME-TRIGGERING-REF">
            <xsd:annotation>
               <xsd:documentation>The frame whose identifier is reset by this assignment.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="UnassignFrameIdTiming.unassignedFrameTriggering";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:LIN-FRAME-TRIGGERING--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class LinCommunication::UnassignFrameIdTiming -->
   <xsd:complexType abstract="false" mixed="false" name="UNASSIGN-FRAME-ID-TIMING">
      <xsd:annotation>
         <xsd:documentation>Schedule entry for an Unassign Frame Id master request where the protected identifier is assigned the value 0x40. This will disable reception/transmission of a previously dynamically assigned frame identifier.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="UnassignFrameIdTiming"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:RELATIVELY-SCHEDULED-TIMING"/>
         <xsd:group ref="AR:ASSIGNMENT-TIMING-TYPE"/>
         <xsd:group ref="AR:UNASSIGN-FRAME-ID-TIMING"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Units::Unit -->
   <xsd:group name="UNIT">
      <xsd:annotation>
         <xsd:documentation>This is a physical measurement unit. All units that might be defined should stem from SI units. In order to convert one unit into another factor and offset are defined. For the calculation from SI-unit to the defined unit the factor (factorSiToUnit ) and the offset (offsetSiToUnit ) are applied:

       unit = siUnit * factorSiToUnit + offsetSiToUnit 

      For the calculation from a unit to SI-unit the reciprocal of the factor (factorSiToUnit ) and the negation of the offset (offsetSiToUnit ) are applied:

      siUnit = (unit - offsetSiToUnit) / factorSiToUnit</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Unit"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="DISPLAY-NAME" type="AR:SL-DATA-3">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Unit.displayName";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="FACTOR-SI-TO-UNIT" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>this is the factor for the convesion from and to siUnits.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Unit.factorSiToUnit";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="OFFSET-SI-TO-UNIT" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>this is the offset for the convesion from and to siUnits.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Unit.offsetSiToUnit";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="40"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PHYSICAL-DIMENSION-REF">
            <xsd:annotation>
               <xsd:documentation>This association represents the physical dimension to which the unit belongs to. Note that only values with units of the same physical dimensions might be converted.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Unit.physicalDimension";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:PHYSICAL-DIMENSION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Units::Unit -->
   <xsd:complexType abstract="false" mixed="false" name="UNIT">
      <xsd:annotation>
         <xsd:documentation>This is a physical measurement unit. All units that might be defined should stem from SI units. In order to convert one unit into another factor and offset are defined. For the calculation from SI-unit to the defined unit the factor (factorSiToUnit ) and the offset (offsetSiToUnit ) are applied:

       unit = siUnit * factorSiToUnit + offsetSiToUnit 

      For the calculation from a unit to SI-unit the reciprocal of the factor (factorSiToUnit ) and the negation of the offset (offsetSiToUnit ) are applied:

      siUnit = (unit - offsetSiToUnit) / factorSiToUnit</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Unit"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:UNIT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="UNIT--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="UNIT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- element group for class Units::UnitGroup -->
   <xsd:group name="UNIT-GROUP">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="UnitGroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="UNIT-REFS">
            <xsd:annotation>
               <xsd:documentation>Use &lt;unit&gt; to enter the unit of a parameter.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="UnitGroup.unit";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="UNIT-REF">
                     <xsd:complexType>
                        <xsd:simpleContent>
                           <xsd:extension base="AR:REF">
                              <xsd:attribute name="DEST" type="AR:UNIT--SUBTYPES-ENUM" use="required"/>
                           </xsd:extension>
                        </xsd:simpleContent>
                     </xsd:complexType>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Units::UnitGroup -->
   <xsd:complexType abstract="false" mixed="false" name="UNIT-GROUP">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="UnitGroup"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:UNIT-GROUP"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Units::UnitSpec -->
   <xsd:group name="UNIT-SPEC">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="UnitSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="UNIT-GROUPS">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="UnitSpec.unitGroup";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="true";xml.roleWrapperElement="true";xml.sequenceOffset="40";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="UNIT-GROUP" type="AR:UNIT-GROUP"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="UNITS">
            <xsd:annotation>
               <xsd:documentation>Use &lt;unit&gt; to enter the unit of a parameter.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="UnitSpec.unit";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="true";xml.roleWrapperElement="true";xml.sequenceOffset="50";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="UNIT" type="AR:UNIT"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="PHYSICAL-DIMENSIONS">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="UnitSpec.physicalDimension";pureMM.maxOccurs="-1";pureMM.minOccurs="0";xml.roleElement="true";xml.roleWrapperElement="true";xml.sequenceOffset="60";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element name="PHYSICAL-DIMENSION" type="AR:PHYSICAL-DIMENSION"/>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Units::UnitSpec -->
   <xsd:complexType abstract="false" mixed="false" name="UNIT-SPEC">
      <xsd:annotation>
         <xsd:appinfo source="tags">mmt.qualifiedName="UnitSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:UNIT-SPEC"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Communication::UnqueuedReceiverComSpec -->
   <xsd:group name="UNQUEUED-RECEIVER-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>Communication attributes specific to unqueued receiving.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="UnqueuedReceiverComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="ALIVE-TIMEOUT" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Specify the amount of time (in seconds) after which the software component (via the RTE)  needs to be notified if the corresponding data item have not been received according to the specified timing description.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="UnqueuedReceiverComSpec.aliveTimeout";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="HANDLE-INVALID" type="AR:HANDLE-INVALID-TYPE">
            <xsd:annotation>
               <xsd:documentation>Specifies strategy of handling the reception of invalidValue.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="UnqueuedReceiverComSpec.handleInvalid";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="HANDLE-NEVER-RECEIVED" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>This attribute specifies whether for the corresponding DataElementPrototype the "never received" flag is available. If yes, the RTE is supposed to assume that initially the DataElementPrototype has not been received before.
            After the first reception of the corresponding DataElementPrototype the flag is cleared.
            If the value of this attribute is set to TRUE the flag is required. If set to FALSE, the RTE shall not support the "never received" functionality for the corresponding DataElementPrototype.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="UnqueuedReceiverComSpec.handleNeverReceived";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INIT-VALUE-REF">
            <xsd:annotation>
               <xsd:documentation>Initial value to be used in case the sending component is not yet initialized. If the sender also specifies an init value the receiver's value will be used.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="UnqueuedReceiverComSpec.initValue";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:VALUE-SPECIFICATION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="RESYNC-TIME" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Time allowed for resynchronization of data values after current data is lost, e.g. after an ECU reset.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="UnqueuedReceiverComSpec.resyncTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Communication::UnqueuedReceiverComSpec -->
   <xsd:complexType abstract="false" mixed="false" name="UNQUEUED-RECEIVER-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>Communication attributes specific to unqueued receiving.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="UnqueuedReceiverComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:RECEIVER-COM-SPEC"/>
         <xsd:group ref="AR:UNQUEUED-RECEIVER-COM-SPEC"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Communication::UnqueuedSenderComSpec -->
   <xsd:group name="UNQUEUED-SENDER-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>Communication attributes specific to distribution of data (P-Port, sender-receiver interface and data element carries "data" opposed to carrying an "event").</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="UnqueuedSenderComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CAN-INVALIDATE" type="xsd:boolean">
            <xsd:annotation>
               <xsd:documentation>Flag whether the component can actively invalidate data.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="UnqueuedSenderComSpec.canInvalidate";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="INIT-VALUE-REF">
            <xsd:annotation>
               <xsd:documentation>Init value to be sent if sender component is not yet fully initialized, but receiver needs data already.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="UnqueuedSenderComSpec.initValue";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:VALUE-SPECIFICATION--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Communication::UnqueuedSenderComSpec -->
   <xsd:complexType abstract="false" mixed="false" name="UNQUEUED-SENDER-COM-SPEC">
      <xsd:annotation>
         <xsd:documentation>Communication attributes specific to distribution of data (P-Port, sender-receiver interface and data element carries "data" opposed to carrying an "event").</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="UnqueuedSenderComSpec"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:SENDER-COM-SPEC"/>
         <xsd:group ref="AR:UNQUEUED-SENDER-COM-SPEC"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Inlines::Url -->
   <xsd:group name="URL">
      <xsd:annotation>
         <xsd:documentation>This element specifies the Uniform Resource Locator (URL) of the context contained in the &lt;url&gt; element.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Url"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="VALUE" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>This is the url itself</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Url.value";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.roleElement="false";xml.roleWrapperElement="false";xml.typeElement="false";xml.typeWrapperElement="false"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- attribute group for class Inlines::Url -->
   <xsd:attributeGroup name="URL">
      <xsd:annotation>
         <xsd:documentation>This element specifies the Uniform Resource Locator (URL) of the context contained in the &lt;url&gt; element.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Url"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="MIME-TYPE" type="xsd:string">
         <xsd:annotation>
            <xsd:documentation>this denotes the mime type of the resource located by the url.</xsd:documentation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Url.mimeType";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class Inlines::Url -->
   <xsd:complexType name="URL">
      <xsd:annotation>
         <xsd:documentation>This element specifies the Uniform Resource Locator (URL) of the context contained in the &lt;url&gt; element.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Url"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:simpleContent>
         <xsd:extension base="xsd:string">
            <xsd:attributeGroup ref="AR:AR-OBJECT"/>
            <xsd:attributeGroup ref="AR:URL"/>
         </xsd:extension>
      </xsd:simpleContent>
   </xsd:complexType>
   <!-- element group for class CoreCommunication::UserDefinedIPdu -->
   <xsd:group name="USER-DEFINED-I-PDU">
      <xsd:annotation>
         <xsd:documentation>UserDefinedIPdu allows to describe PDU-based communication over Complex Communication Drivers. If a new BSW module is added above the PduR (e.g. a Diagnostic Service ) then this IPdu element shall be used to describe the communication.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="UserDefinedIPdu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CDD-TYPE" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>This attribute defines the CDD that transmits or receives the UserDefinedPdu. If several CDDs are defined this attribute is used to distinguish between them.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="UserDefinedIPdu.cddType";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::UserDefinedIPdu -->
   <xsd:complexType abstract="false" mixed="false" name="USER-DEFINED-I-PDU">
      <xsd:annotation>
         <xsd:documentation>UserDefinedIPdu allows to describe PDU-based communication over Complex Communication Drivers. If a new BSW module is added above the PduR (e.g. a Diagnostic Service ) then this IPdu element shall be used to describe the communication.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="UserDefinedIPdu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:I-PDU"/>
         <xsd:group ref="AR:USER-DEFINED-I-PDU"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class CoreCommunication::UserDefinedPdu -->
   <xsd:group name="USER-DEFINED-PDU">
      <xsd:annotation>
         <xsd:documentation>UserDefinedPdu allows to describe PDU-based communication over Complex Communication Drivers. If a new BSW module is added above the BusIf (e.g. a new Nm module or XCP) then this Pdu element shall be used to describe the communication.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="UserDefinedPdu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CDD-TYPE" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>This attribute defines the CDD that transmits or receives the UserDefinedIPdu. If several CDDs are defined this attribute is used to distinguish between them.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="UserDefinedPdu.cddType";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class CoreCommunication::UserDefinedPdu -->
   <xsd:complexType abstract="false" mixed="false" name="USER-DEFINED-PDU">
      <xsd:annotation>
         <xsd:documentation>UserDefinedPdu allows to describe PDU-based communication over Complex Communication Drivers. If a new BSW module is added above the BusIf (e.g. a new Nm module or XCP) then this Pdu element shall be used to describe the communication.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="UserDefinedPdu"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:USER-DEFINED-PDU"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- complex type for class ValueModel::V -->
   <xsd:complexType abstract="false" mixed="true" name="V">
      <xsd:annotation>
         <xsd:documentation>Use &lt;v&gt; to enter a numerical value.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="V"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0"/>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <xsd:simpleType name="VALUE-SPECIFICATION--SUBTYPES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ARRAY-SPECIFICATION"/>
         <xsd:enumeration value="BOOLEAN-LITERAL"/>
         <xsd:enumeration value="CHAR-LITERAL"/>
         <xsd:enumeration value="CONSTANT-REFERENCE"/>
         <xsd:enumeration value="INTEGER-LITERAL"/>
         <xsd:enumeration value="OPAQUE-LITERAL"/>
         <xsd:enumeration value="REAL-LITERAL"/>
         <xsd:enumeration value="RECORD-SPECIFICATION"/>
         <xsd:enumeration value="STRING-LITERAL"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- complex type for class ValueModel::Vf -->
   <xsd:complexType abstract="false" mixed="true" name="VF">
      <xsd:annotation>
         <xsd:documentation>Value calculated via a system constant. This element is included in every case, where parameters should be generated from numerical values during compile time (not runtime!). Thus for example, the influence of the cylinder number on conversion formulae, can be introduced in a repeatable manner.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Vf"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0"/>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- attribute group for class ValueModel::Vt -->
   <xsd:attributeGroup name="VT">
      <xsd:annotation>
         <xsd:documentation>&lt;vt&gt; represents one particular textual value of the calibration item.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Vt"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:attribute name="XMLSPACE" type="xsd:string">
         <xsd:annotation>
            <xsd:appinfo source="tags">mmt.qualifiedName="Vt.xml:space";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.attribute="true"</xsd:appinfo>
         </xsd:annotation>
      </xsd:attribute>
   </xsd:attributeGroup>
   <!-- complex type for class ValueModel::Vt -->
   <xsd:complexType abstract="false" mixed="true" name="VT">
      <xsd:annotation>
         <xsd:documentation>&lt;vt&gt; represents one particular textual value of the calibration item.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Vt"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0"/>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:VT"/>
   </xsd:complexType>
   <!-- element group for class RTEEvents::WaitPoint -->
   <xsd:group name="WAIT-POINT">
      <xsd:annotation>
         <xsd:documentation>This defines a wait-point for which the runnable can wait.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="WaitPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="TIMEOUT" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Time in seconds before the waitpoint times out and the blocking wait call returns with an error indicating the timeout.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="WaitPoint.timeout";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TRIGGER-REF">
            <xsd:annotation>
               <xsd:documentation>Events this wait point is waiting for.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="WaitPoint.trigger";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:RTE-EVENT--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class RTEEvents::WaitPoint -->
   <xsd:complexType abstract="false" mixed="false" name="WAIT-POINT">
      <xsd:annotation>
         <xsd:documentation>This defines a wait-point for which the runnable can wait.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="WaitPoint"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:WAIT-POINT"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- complex type for class ApplicationAttributes::WakeUp -->
   <xsd:complexType abstract="false" mixed="false" name="WAKE-UP">
      <xsd:annotation>
         <xsd:documentation>This attribut indicates wheter the software component reading this value provides dedicated runnables to handle a wake-up call by the IoHwAbstraction layer.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="WakeUp"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence/>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Peripherals::WatchDog -->
   <xsd:group name="WATCH-DOG">
      <xsd:annotation>
         <xsd:documentation>A form of interval timer, which is used to detect a possible malfunction of the processing unit. The timer is started as a countdown and has to be triggered within a specific time. Either the trigger only has to occur before the count-down runs out, or the trigger has to occur within a specific window before the timeout, therefore a trigger too early will also set off the watchdog. If the trigger is not correctly performed the watchdog will set off and will initiate an interrupt or perform a reset of the whole processing unit or ECU.
      The watchdog can be implemented in software or hardware and if the implementation is in hardware it can be integrated into the processing unit or connected externally.
      Depending on the complexity of the watchdog the interfacing is either a serial communication or some discrete I/O lines. Also the trigger itself can be just some digital peak or can be some calculated request-response mechanism. The actual handling of the watchdog has to be covered by some specific driver software.
      The watchdog will use at least an interrupt of the processing unit and also some peripheral connections for the control and set-up.
      To enable different operating modes of the processing unit and the ECU it is important to specify if the watchdog can be disabled (e.g. during flash programming).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="WatchDog"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="CLOCK-SOURCE-REF">
            <xsd:annotation>
               <xsd:documentation>The clock input to a timer can have different sources like the internal system clock or an external clock. If the clock is pre-scaled this information should be entered in the table.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="WatchDog.clockSource";pureMM.maxOccurs="1";pureMM.minOccurs="0"</xsd:appinfo>
            </xsd:annotation>
            <xsd:complexType>
               <xsd:simpleContent>
                  <xsd:extension base="AR:REF">
                     <xsd:attribute name="DEST" type="AR:OSCILLATOR--SUBTYPES-ENUM" use="required"/>
                  </xsd:extension>
               </xsd:simpleContent>
            </xsd:complexType>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MODE" type="AR:WATCH-DOG-MODE-ENUM">
            <xsd:annotation>
               <xsd:documentation>A Watchdog can be running in different modes. In normal mode must the watchdog be kicked within a certain maximum time. In the windowed mode there is also a lower limit of the time when the watchdog has to be kicked. In debug mode is the watchdog disabled. Sometimes it's also required that the watchdog can be disabled and enabled during software download. To ensure that this mode is not entered in normal operation there is often some kind of security procedure to enter the mode.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="WatchDog.mode";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="THRESHOLD-VALUES">
            <xsd:complexType>
               <xsd:choice maxOccurs="unbounded" minOccurs="0">
                  <xsd:element maxOccurs="unbounded" minOccurs="0" name="THRESHOLD-VALUE" type="xsd:integer">
                     <xsd:annotation>
                        <xsd:documentation>The threshold is the definition of a counter value. When the counter has reached this value some action is performed, e.g. an interrupt can be generated.</xsd:documentation>
                        <xsd:appinfo source="tags">mmt.qualifiedName="WatchDog.thresholdValue";pureMM.maxOccurs="-1";pureMM.minOccurs="0"</xsd:appinfo>
                     </xsd:annotation>
                  </xsd:element>
               </xsd:choice>
            </xsd:complexType>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Peripherals::WatchDog -->
   <xsd:complexType abstract="false" mixed="false" name="WATCH-DOG">
      <xsd:annotation>
         <xsd:documentation>A form of interval timer, which is used to detect a possible malfunction of the processing unit. The timer is started as a countdown and has to be triggered within a specific time. Either the trigger only has to occur before the count-down runs out, or the trigger has to occur within a specific window before the timeout, therefore a trigger too early will also set off the watchdog. If the trigger is not correctly performed the watchdog will set off and will initiate an interrupt or perform a reset of the whole processing unit or ECU.
      The watchdog can be implemented in software or hardware and if the implementation is in hardware it can be integrated into the processing unit or connected externally.
      Depending on the complexity of the watchdog the interfacing is either a serial communication or some discrete I/O lines. Also the trigger itself can be just some digital peak or can be some calculated request-response mechanism. The actual handling of the watchdog has to be covered by some specific driver software.
      The watchdog will use at least an interrupt of the processing unit and also some peripheral connections for the control and set-up.
      To enable different operating modes of the processing unit and the ECU it is important to specify if the watchdog can be disabled (e.g. during flash programming).</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="WatchDog"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HW-ELEMENT"/>
         <xsd:group ref="AR:PERIPHERAL"/>
         <xsd:group ref="AR:WATCH-DOG"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class ExecutionTime::WorstCaseExecutionTime -->
   <xsd:group name="WORST-CASE-EXECUTION-TIME">
      <xsd:annotation>
         <xsd:documentation>WorstCaseExecutionTime provides an analytic method for specifying the minimum and maximum execution time.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="WorstCaseExecutionTime"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MAXIMAL-EXECUTION-TIME" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Maximum WorstCaseExecutionTime.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="WorstCaseExecutionTime.maximalExecutionTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="MINIMAL-EXECUTION-TIME" type="xsd:double">
            <xsd:annotation>
               <xsd:documentation>Minimum WorstCaseExecutionTime.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="WorstCaseExecutionTime.minimalExecutionTime";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class ExecutionTime::WorstCaseExecutionTime -->
   <xsd:complexType abstract="false" mixed="false" name="WORST-CASE-EXECUTION-TIME">
      <xsd:annotation>
         <xsd:documentation>WorstCaseExecutionTime provides an analytic method for specifying the minimum and maximum execution time.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="WorstCaseExecutionTime"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:EXECUTION-TIME"/>
         <xsd:group ref="AR:WORST-CASE-EXECUTION-TIME"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class HeapUsage::WorstCaseHeapUsage -->
   <xsd:group name="WORST-CASE-HEAP-USAGE">
      <xsd:annotation>
         <xsd:documentation>Provides a formal worst case heap usage.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="WorstCaseHeapUsage"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MEMORY-CONSUMPTION" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Worst case heap consumption.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="WorstCaseHeapUsage.memoryConsumption";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class HeapUsage::WorstCaseHeapUsage -->
   <xsd:complexType abstract="false" mixed="false" name="WORST-CASE-HEAP-USAGE">
      <xsd:annotation>
         <xsd:documentation>Provides a formal worst case heap usage.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="WorstCaseHeapUsage"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:HEAP-USAGE"/>
         <xsd:group ref="AR:WORST-CASE-HEAP-USAGE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class StackUsage::WorstCaseStackUsage -->
   <xsd:group name="WORST-CASE-STACK-USAGE">
      <xsd:annotation>
         <xsd:documentation>Provides a formal worst case stack usage.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="WorstCaseStackUsage"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="MEMORY-CONSUMPTION" type="xsd:integer">
            <xsd:annotation>
               <xsd:documentation>Worst case stack consumption.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="WorstCaseStackUsage.memoryConsumption";pureMM.maxOccurs="1";pureMM.minOccurs="1"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class StackUsage::WorstCaseStackUsage -->
   <xsd:complexType abstract="false" mixed="false" name="WORST-CASE-STACK-USAGE">
      <xsd:annotation>
         <xsd:documentation>Provides a formal worst case stack usage.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="WorstCaseStackUsage"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:STACK-USAGE"/>
         <xsd:group ref="AR:WORST-CASE-STACK-USAGE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- complex type for class Inlines::Xdoc -->
   <xsd:complexType abstract="false" mixed="false" name="XDOC">
      <xsd:annotation>
         <xsd:documentation>Use &lt;xdoc&gt; , to reference an external document.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Xdoc"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- element group for class Inlines::Xfile -->
   <xsd:group name="XFILE">
      <xsd:annotation>
         <xsd:documentation>Use &lt;xfile&gt; , to reference an external file.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Xfile"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="SHORT-NAME" type="AR:IDENTIFIER">
            <xsd:annotation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Xfile.shortName";pureMM.maxOccurs="1";pureMM.minOccurs="1";xml.sequenceOffset="10"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="LONG-NAME-1" type="AR:SL-DATA-4">
            <xsd:annotation>
               <xsd:documentation>Use &lt;longName1&gt; to create a comprehensive name for the context element</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Xfile.longName1";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="20"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="URL" type="AR:URL">
            <xsd:annotation>
               <xsd:documentation>This element specifies the Uniform Resource Locator (URL) of the context contained in the &lt;url&gt; element.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Xfile.url";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TOOL" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>This element describes the tool which was used to generate the corresponding &lt;xfile&gt; . Kept as a string.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Xfile.tool";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TOOL-VERSION" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>This element describes the tool version which was used to generate the corresponding &lt;xfile&gt; . Kept as a string.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="Xfile.toolVersion";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="60"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Inlines::Xfile -->
   <xsd:complexType abstract="false" mixed="false" name="XFILE">
      <xsd:annotation>
         <xsd:documentation>Use &lt;xfile&gt; , to reference an external file.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Xfile"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:XFILE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- element group for class Implementation::XfileSo -->
   <xsd:group name="XFILE-SO">
      <xsd:annotation>
         <xsd:documentation>This meta class represents the ability to refer to an external file in a standalone context. Note that Xfile does the same but embedded in a documentation block paragraph.

      This meta class maintains backward compatibility of xml schema wrt. to Code.xfile and Dependency.xfile.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="XfileSo"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:element maxOccurs="1" minOccurs="0" name="URL" type="AR:URL">
            <xsd:annotation>
               <xsd:documentation>This element specifies the Uniform Resource Locator (URL) of the context contained in the &lt;url&gt; element.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="XfileSo.url";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="30"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TOOL" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>This element describes the tool which was used to generate the corresponding &lt;xfile&gt; . Kept as a string.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="XfileSo.tool";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="50"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
         <xsd:element maxOccurs="1" minOccurs="0" name="TOOL-VERSION" type="xsd:string">
            <xsd:annotation>
               <xsd:documentation>This element describes the tool version which was used to generate the corresponding &lt;xfile&gt; . Kept as a string.</xsd:documentation>
               <xsd:appinfo source="tags">mmt.qualifiedName="XfileSo.toolVersion";pureMM.maxOccurs="1";pureMM.minOccurs="0";xml.sequenceOffset="60"</xsd:appinfo>
            </xsd:annotation>
         </xsd:element>
      </xsd:sequence>
   </xsd:group>
   <!-- complex type for class Implementation::XfileSo -->
   <xsd:complexType abstract="false" mixed="false" name="XFILE-SO">
      <xsd:annotation>
         <xsd:documentation>This meta class represents the ability to refer to an external file in a standalone context. Note that Xfile does the same but embedded in a documentation block paragraph.

      This meta class maintains backward compatibility of xml schema wrt. to Code.xfile and Dependency.xfile.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="XfileSo"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
         <xsd:group ref="AR:XFILE-SO"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <!-- complex type for class Inlines::Xref -->
   <xsd:complexType abstract="false" mixed="true" name="XREF">
      <xsd:annotation>
         <xsd:documentation>Use &lt;xref&gt; , to generate cross-references within the document.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="Xref"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpMixedString,atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:choice maxOccurs="unbounded" minOccurs="0"/>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
   </xsd:complexType>
   <!-- complex type for class Inlines::XrefTarget -->
   <xsd:complexType abstract="false" mixed="false" name="XREF-TARGET">
      <xsd:annotation>
         <xsd:documentation>This element specifies a reference target which can be scattered throughout the text.</xsd:documentation>
         <xsd:appinfo source="tags">mmt.qualifiedName="XrefTarget"</xsd:appinfo>
         <xsd:appinfo source="stereotypes">atpObject</xsd:appinfo>
      </xsd:annotation>
      <xsd:sequence>
         <xsd:group ref="AR:IDENTIFIABLE"/>
      </xsd:sequence>
      <xsd:attributeGroup ref="AR:AR-OBJECT"/>
      <xsd:attributeGroup ref="AR:IDENTIFIABLE"/>
   </xsd:complexType>
   <xsd:simpleType name="ACTUATOR-HW-DEFAULT-POSITIOIN-TYPE-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="BI-STABLE"/>
         <xsd:enumeration value="INSTABLE"/>
         <xsd:enumeration value="MULTI-STABLE"/>
         <xsd:enumeration value="STABLE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="ACTUATOR-HW-ELECTRICAL-TYPE-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CAPACITIVE"/>
         <xsd:enumeration value="INDUCTIVE"/>
         <xsd:enumeration value="RESISTIVE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="ACTUATOR-HW-MOVEMENT-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="BIDIRECTIONAL"/>
         <xsd:enumeration value="UNIDIRECTIONAL"/>
         <xsd:enumeration value="UNIDIRECTIONAL-WITH-AUTO-RESET"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="ADC-BEHAVIOUR-AT-LIMIT-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CLIPPING"/>
         <xsd:enumeration value="DEFAULT"/>
         <xsd:enumeration value="OTHER"/>
         <xsd:enumeration value="UNDEFINED"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="ANALOGUE-IO-MODE-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CONTINUOUS"/>
         <xsd:enumeration value="SEQUENTIAL"/>
         <xsd:enumeration value="SINGLE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="BSW-CALL-TYPE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CALLBACK"/>
         <xsd:enumeration value="INTERRUPT"/>
         <xsd:enumeration value="REGULAR"/>
         <xsd:enumeration value="SCHEDULED"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="BSW-EXECUTION-CONTEXT">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="INTERRUPT"/>
         <xsd:enumeration value="TASK"/>
         <xsd:enumeration value="UNSPECIFIED"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="BSW-INTERRUPT-CATEGORY">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CAT-1"/>
         <xsd:enumeration value="CAT-2"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="BYTE-ORDER-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="MOST-SIGNIFICANT-BYTE-FIRST"/>
         <xsd:enumeration value="MOST-SIGNIFICANT-BYTE-LAST"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="CALCULATION-LANGUAGE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="A-RFORMAL"/>
         <xsd:enumeration value="INFORMAL"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="CALPRM-AXIS-CATEGORY-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="COM-AXIS"/>
         <xsd:enumeration value="CURVE-AXIS"/>
         <xsd:enumeration value="FIX-AXIS"/>
         <xsd:enumeration value="RES-AXIS"/>
         <xsd:enumeration value="STD-AXIS"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="CAN-ADDRESSING-MODE-TYPE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="EXTENDED"/>
         <xsd:enumeration value="STANDARD"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="CAN-TP-ADDRESSING-FORMAT-TYPE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="EXTENDED"/>
         <xsd:enumeration value="MIXED"/>
         <xsd:enumeration value="STANDARD"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="CAN-TP-CHANNEL-MODE-TYPE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="FULL-DUPLEX-MODE"/>
         <xsd:enumeration value="HALF-DUPLEX-MODE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="CCU-MODE-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CAPTURE"/>
         <xsd:enumeration value="COMPARE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="CLOCK-TYPE-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="DIVIDER"/>
         <xsd:enumeration value="PLL"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="CODE-TYPE-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="OBJ"/>
         <xsd:enumeration value="SRC"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="COMMUNICATION-APPROACH-TYPE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="EXPLICIT"/>
         <xsd:enumeration value="IMPLICIT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="COMMUNICATION-ARCHITECTURE-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="MASTER"/>
         <xsd:enumeration value="MULTI-MASTER"/>
         <xsd:enumeration value="SLAVE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="COMMUNICATION-DIRECTION-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="INOUT"/>
         <xsd:enumeration value="INPUT"/>
         <xsd:enumeration value="OUTPUT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="COMMUNICATION-DIRECTION-TYPE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="IN"/>
         <xsd:enumeration value="OUT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="COMMUNICATION-PHYSICAL-MEDIUM-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ELECTRICAL"/>
         <xsd:enumeration value="OPTICAL"/>
         <xsd:enumeration value="WIRELESS"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="CONFIGURATION-AFFECTION">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="LT-AFFECTS-PB"/>
         <xsd:enumeration value="NO-AFFECT"/>
         <xsd:enumeration value="PC-AFFECTS-LT"/>
         <xsd:enumeration value="PC-AFFECTS-LT-AND-PB"/>
         <xsd:enumeration value="PC-AFFECTS-PB"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="CONFIGURATION-CLASS">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="LINK"/>
         <xsd:enumeration value="POST-BUILD"/>
         <xsd:enumeration value="PRE-COMPILE"/>
         <xsd:enumeration value="PUBLISHED-INFORMATION"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="CONFIGURATION-VARIANT">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="VARIANT-LINK-TIME"/>
         <xsd:enumeration value="VARIANT-POST-BUILD"/>
         <xsd:enumeration value="VARIANT-POST-BUILD-LOADABLE"/>
         <xsd:enumeration value="VARIANT-POST-BUILD-SELECTABLE"/>
         <xsd:enumeration value="VARIANT-PRE-COMPILE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="CYCLE-REPETITION-TYPE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CYCLE-REPETITION-1"/>
         <xsd:enumeration value="CYCLE-REPETITION-16"/>
         <xsd:enumeration value="CYCLE-REPETITION-2"/>
         <xsd:enumeration value="CYCLE-REPETITION-32"/>
         <xsd:enumeration value="CYCLE-REPETITION-4"/>
         <xsd:enumeration value="CYCLE-REPETITION-64"/>
         <xsd:enumeration value="CYCLE-REPETITION-8"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="DEPENDENCY-USAGE-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="BUILD"/>
         <xsd:enumeration value="COMPILE"/>
         <xsd:enumeration value="EXECUTE"/>
         <xsd:enumeration value="LINK"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="DIGITAL-IO-EDGE-DETECTION-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="FALLING"/>
         <xsd:enumeration value="RAISING-FALLING"/>
         <xsd:enumeration value="RISING"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="DIRECTION-KIND">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="IN"/>
         <xsd:enumeration value="INOUT"/>
         <xsd:enumeration value="OUT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="DISPLAY-HW-COLOUR-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="COLOUR"/>
         <xsd:enumeration value="GREY"/>
         <xsd:enumeration value="MONO"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="DISPLAY-HW-TYPE-OF-CHARACTERS-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ALPHA-NUMERICAL"/>
         <xsd:enumeration value="GRAPHICAL"/>
         <xsd:enumeration value="NUMERICAL"/>
         <xsd:enumeration value="SEMI-GRAPHICAL"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="E-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="BOLD"/>
         <xsd:enumeration value="BOLDITALIC"/>
         <xsd:enumeration value="ITALIC"/>
         <xsd:enumeration value="PLAIN"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="E-ENUM-FONT">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="DEFAULT"/>
         <xsd:enumeration value="MONO"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="FILTER-DEBOUNCING-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="DEBOUNCE-DATA"/>
         <xsd:enumeration value="RAW-DATA"/>
         <xsd:enumeration value="WAIT-TIME-DATE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="FLEXRAY-CHANNEL-NAME">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CHANNEL-A"/>
         <xsd:enumeration value="CHANNEL-B"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="HANDLE-INVALID-TYPE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="DONT-INVALIDATE"/>
         <xsd:enumeration value="KEEP"/>
         <xsd:enumeration value="REPLACE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="HW-ELEMENT-DEFAULT-RESET-BEHAVIOR-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="OFF"/>
         <xsd:enumeration value="ON"/>
         <xsd:enumeration value="OTHER"/>
         <xsd:enumeration value="PASSIVE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="HW-ELEMENT-POWER-DRIVER-TYPE-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="FB"/>
         <xsd:enumeration value="HB"/>
         <xsd:enumeration value="HS"/>
         <xsd:enumeration value="LS"/>
         <xsd:enumeration value="OTHER"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="HW-ELEMENT-RESET-ON-FAULT-BEHAVIOUR-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="AUTO"/>
         <xsd:enumeration value="FOLD-BACK"/>
         <xsd:enumeration value="RE-TRIGGER"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="INTERVAL-TYPE-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CLOSED"/>
         <xsd:enumeration value="INFINITE"/>
         <xsd:enumeration value="OPEN"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="L-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="AA"/>
         <xsd:enumeration value="AB"/>
         <xsd:enumeration value="AF"/>
         <xsd:enumeration value="AM"/>
         <xsd:enumeration value="AR"/>
         <xsd:enumeration value="AS"/>
         <xsd:enumeration value="AY"/>
         <xsd:enumeration value="AZ"/>
         <xsd:enumeration value="BA"/>
         <xsd:enumeration value="BE"/>
         <xsd:enumeration value="BG"/>
         <xsd:enumeration value="BH"/>
         <xsd:enumeration value="BI"/>
         <xsd:enumeration value="BN"/>
         <xsd:enumeration value="BO"/>
         <xsd:enumeration value="BR"/>
         <xsd:enumeration value="CA"/>
         <xsd:enumeration value="CO"/>
         <xsd:enumeration value="CS"/>
         <xsd:enumeration value="CY"/>
         <xsd:enumeration value="DA"/>
         <xsd:enumeration value="DE"/>
         <xsd:enumeration value="DZ"/>
         <xsd:enumeration value="EL"/>
         <xsd:enumeration value="EN"/>
         <xsd:enumeration value="EO"/>
         <xsd:enumeration value="ES"/>
         <xsd:enumeration value="ET"/>
         <xsd:enumeration value="EU"/>
         <xsd:enumeration value="FA"/>
         <xsd:enumeration value="FI"/>
         <xsd:enumeration value="FJ"/>
         <xsd:enumeration value="FO"/>
         <xsd:enumeration value="FOR-ALL"/>
         <xsd:enumeration value="FR"/>
         <xsd:enumeration value="FY"/>
         <xsd:enumeration value="GA"/>
         <xsd:enumeration value="GD"/>
         <xsd:enumeration value="GL"/>
         <xsd:enumeration value="GN"/>
         <xsd:enumeration value="GU"/>
         <xsd:enumeration value="HA"/>
         <xsd:enumeration value="HI"/>
         <xsd:enumeration value="HR"/>
         <xsd:enumeration value="HU"/>
         <xsd:enumeration value="HY"/>
         <xsd:enumeration value="IA"/>
         <xsd:enumeration value="IE"/>
         <xsd:enumeration value="IK"/>
         <xsd:enumeration value="IN"/>
         <xsd:enumeration value="IS"/>
         <xsd:enumeration value="IT"/>
         <xsd:enumeration value="IW"/>
         <xsd:enumeration value="JA"/>
         <xsd:enumeration value="JI"/>
         <xsd:enumeration value="JW"/>
         <xsd:enumeration value="KA"/>
         <xsd:enumeration value="KK"/>
         <xsd:enumeration value="KL"/>
         <xsd:enumeration value="KM"/>
         <xsd:enumeration value="KN"/>
         <xsd:enumeration value="KO"/>
         <xsd:enumeration value="KS"/>
         <xsd:enumeration value="KU"/>
         <xsd:enumeration value="KY"/>
         <xsd:enumeration value="LA"/>
         <xsd:enumeration value="LN"/>
         <xsd:enumeration value="LO"/>
         <xsd:enumeration value="LT"/>
         <xsd:enumeration value="LV"/>
         <xsd:enumeration value="MG"/>
         <xsd:enumeration value="MI"/>
         <xsd:enumeration value="MK"/>
         <xsd:enumeration value="ML"/>
         <xsd:enumeration value="MN"/>
         <xsd:enumeration value="MO"/>
         <xsd:enumeration value="MR"/>
         <xsd:enumeration value="MS"/>
         <xsd:enumeration value="MT"/>
         <xsd:enumeration value="MY"/>
         <xsd:enumeration value="NA"/>
         <xsd:enumeration value="NE"/>
         <xsd:enumeration value="NL"/>
         <xsd:enumeration value="NO"/>
         <xsd:enumeration value="OC"/>
         <xsd:enumeration value="OM"/>
         <xsd:enumeration value="OR"/>
         <xsd:enumeration value="PA"/>
         <xsd:enumeration value="PL"/>
         <xsd:enumeration value="PS"/>
         <xsd:enumeration value="PT"/>
         <xsd:enumeration value="QU"/>
         <xsd:enumeration value="RM"/>
         <xsd:enumeration value="RN"/>
         <xsd:enumeration value="RO"/>
         <xsd:enumeration value="RU"/>
         <xsd:enumeration value="RW"/>
         <xsd:enumeration value="SA"/>
         <xsd:enumeration value="SD"/>
         <xsd:enumeration value="SG"/>
         <xsd:enumeration value="SH"/>
         <xsd:enumeration value="SI"/>
         <xsd:enumeration value="SK"/>
         <xsd:enumeration value="SL"/>
         <xsd:enumeration value="SM"/>
         <xsd:enumeration value="SN"/>
         <xsd:enumeration value="SO"/>
         <xsd:enumeration value="SQ"/>
         <xsd:enumeration value="SR"/>
         <xsd:enumeration value="SS"/>
         <xsd:enumeration value="ST"/>
         <xsd:enumeration value="SU"/>
         <xsd:enumeration value="SV"/>
         <xsd:enumeration value="SW"/>
         <xsd:enumeration value="TA"/>
         <xsd:enumeration value="TE"/>
         <xsd:enumeration value="TG"/>
         <xsd:enumeration value="TH"/>
         <xsd:enumeration value="TI"/>
         <xsd:enumeration value="TK"/>
         <xsd:enumeration value="TL"/>
         <xsd:enumeration value="TN"/>
         <xsd:enumeration value="TO"/>
         <xsd:enumeration value="TR"/>
         <xsd:enumeration value="TS"/>
         <xsd:enumeration value="TT"/>
         <xsd:enumeration value="TW"/>
         <xsd:enumeration value="UK"/>
         <xsd:enumeration value="UR"/>
         <xsd:enumeration value="UZ"/>
         <xsd:enumeration value="VI"/>
         <xsd:enumeration value="VO"/>
         <xsd:enumeration value="WO"/>
         <xsd:enumeration value="XH"/>
         <xsd:enumeration value="YO"/>
         <xsd:enumeration value="ZH"/>
         <xsd:enumeration value="ZU"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="LIMIT-KIND">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="MAX"/>
         <xsd:enumeration value="MIN"/>
         <xsd:enumeration value="NONE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="LIN-CHECKSUM-TYPE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CLASSIC"/>
         <xsd:enumeration value="ENHANCED"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="MAX-COMM-MODE-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="FULL"/>
         <xsd:enumeration value="NONE"/>
         <xsd:enumeration value="SILENT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="MAXIMUM-MESSAGE-LENGTH-TYPE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ISO"/>
         <xsd:enumeration value="ISO-6"/>
         <xsd:enumeration value="L-4-G"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="MEMORY-ACCESS-TYPE-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="BURST"/>
         <xsd:enumeration value="ERASE"/>
         <xsd:enumeration value="PROGRAM"/>
         <xsd:enumeration value="RANDOM"/>
         <xsd:enumeration value="READ"/>
         <xsd:enumeration value="SEQUENCE"/>
         <xsd:enumeration value="WRITE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="MEMORY-MAPPED-HW-PORT-TYPE-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CONTROL"/>
         <xsd:enumeration value="DATA"/>
         <xsd:enumeration value="UNSPECIFIED"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="MEMORY-SECTION-TYPE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CODE"/>
         <xsd:enumeration value="CONFIG-DATA"/>
         <xsd:enumeration value="CONST"/>
         <xsd:enumeration value="USER-DEFINED"/>
         <xsd:enumeration value="VAR"/>
         <xsd:enumeration value="VAR-FAST"/>
         <xsd:enumeration value="VAR-NO-INIT"/>
         <xsd:enumeration value="VAR-POWER-ON-INIT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="MEMORY-SEGMENT-USAGE-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="BOOT"/>
         <xsd:enumeration value="CODE"/>
         <xsd:enumeration value="DATA"/>
         <xsd:enumeration value="STACK"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="MODE-ACTIVATION-KIND">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ENTRY"/>
         <xsd:enumeration value="EXIT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="MONOTONY-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="DECREASING"/>
         <xsd:enumeration value="INCREASING"/>
         <xsd:enumeration value="NO-MONOTONY"/>
         <xsd:enumeration value="STRICTLY-DECREASING"/>
         <xsd:enumeration value="STRICTLY-INCREASING"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="NETWORK-TARGET-ADDRESS-TYPE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="FUNCTIONAL"/>
         <xsd:enumeration value="PHYSICAL"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="NV-BLOCK-NEEDS-RELIABILITY-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="HIGH"/>
         <xsd:enumeration value="LOW"/>
         <xsd:enumeration value="MEDIUM"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="NV-BLOCK-NEEDS-WRITING-PRIORITY-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="HIGH"/>
         <xsd:enumeration value="LOW"/>
         <xsd:enumeration value="MEDIUM"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="OBD-RATIO-CONNECTION-KIND">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="API-USE"/>
         <xsd:enumeration value="OBSERVER"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="OSCILLATOR-MODE-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="FUNDAMENTAL"/>
         <xsd:enumeration value="OVERTONE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="PNC-GATEWAY-TYPE-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ACTIVE"/>
         <xsd:enumeration value="NONE"/>
         <xsd:enumeration value="PASSIVE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="PROCESSING-KIND">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="FILTERED"/>
         <xsd:enumeration value="NONE"/>
         <xsd:enumeration value="RAW"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="PROCESSING-UNIT-ADRESSING-MODE-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="DIRECT"/>
         <xsd:enumeration value="INDEXED"/>
         <xsd:enumeration value="INDIRECT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="PROCESSING-UNIT-ARCHITECTURE-KIND-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="HARVARD"/>
         <xsd:enumeration value="NEUMANN"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="PROCESSING-UNIT-ARCHITECTURE-TYPE-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CISC"/>
         <xsd:enumeration value="MIND"/>
         <xsd:enumeration value="RISC"/>
         <xsd:enumeration value="SIMD"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="PROCESSING-UNIT-SPECIAL-OPCODES-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="BIT-MANIPULATION"/>
         <xsd:enumeration value="DIV"/>
         <xsd:enumeration value="FLOAT"/>
         <xsd:enumeration value="MAC"/>
         <xsd:enumeration value="MUL"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="PROGRAMMINGLANGUAGE-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="C"/>
         <xsd:enumeration value="CPP"/>
         <xsd:enumeration value="JAVA"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="PULSE-TEST-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="DISABLE"/>
         <xsd:enumeration value="ENABLE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="PWD-MODE-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="THREE-PHASE-INPUT"/>
         <xsd:enumeration value="TWO-PHASE-INPUT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="REAL-TYPE-ENCODING-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="DOUBLE"/>
         <xsd:enumeration value="SINGLE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="REGISTER-TYPE-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ADDRESS"/>
         <xsd:enumeration value="CONTROL"/>
         <xsd:enumeration value="DATA"/>
         <xsd:enumeration value="SPECIAL"/>
         <xsd:enumeration value="STACK-POINTER"/>
         <xsd:enumeration value="STATUS"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="RUN-MODE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="RUN-CONTINUOUS"/>
         <xsd:enumeration value="RUN-ONCE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="SCALE-CONSTR-VALIDITY-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="NOT-AVAILABLE"/>
         <xsd:enumeration value="NOT-DEFINED"/>
         <xsd:enumeration value="NOT-VALID"/>
         <xsd:enumeration value="VALID"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="SENSOR-HW-SIGNAL-QUALITY-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CODED"/>
         <xsd:enumeration value="DEBOUNCED"/>
         <xsd:enumeration value="FILTERED"/>
         <xsd:enumeration value="RAW"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="SHOW-CONTENT-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="NO-SHOW-CONTENT"/>
         <xsd:enumeration value="SHOW-CONTENT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="SHOW-RESOURCE-LONG-NAME-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="NO-SHOW-LONG-NAME"/>
         <xsd:enumeration value="SHOW-LONG-NAME"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="SHOW-RESOURCE-NUMBER-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="NO-SHOW-NUMBER"/>
         <xsd:enumeration value="SHOW-NUMBER"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="SHOW-RESOURCE-PAGE-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="NO-SHOW-PAGE"/>
         <xsd:enumeration value="SHOW-PAGE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="SHOW-RESOURCE-SHORT-NAME-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="NO-SHOW-SHORT-NAME"/>
         <xsd:enumeration value="SHOW-SHORT-NAME"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="SHOW-RESOURCE-TYPE-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="NO-SHOW-TYPE"/>
         <xsd:enumeration value="SHOW-TYPE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="SHOW-SEE-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="NO-SHOW-SEE"/>
         <xsd:enumeration value="SHOW-SEE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="SIGNAL-FAN-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="NFOLD"/>
         <xsd:enumeration value="SINGLE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="SUBSTITUTION-TYPE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="EVENT-TRIGGERED"/>
         <xsd:enumeration value="SPORADIC"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="SW-CALIBRATION-ACCESS-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="NOT-ACCESSIBLE"/>
         <xsd:enumeration value="READ-ONLY"/>
         <xsd:enumeration value="READ-WRITE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="SW-IMPL-POLICY-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="MEASUREMENT-POINT"/>
         <xsd:enumeration value="MESSAGE"/>
         <xsd:enumeration value="STANDARD"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="SW-SERVICE-IMPL-POLICY-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="INLINE"/>
         <xsd:enumeration value="INLINE-CONDITIONAL"/>
         <xsd:enumeration value="MACRO"/>
         <xsd:enumeration value="STANDARD"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="SW-SERVICE-REENTRANCE-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="REENTRANCE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="SW-VARIABLE-ACCESS-IMPL-POLICY-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="DIRECT"/>
         <xsd:enumeration value="OPTIMIZED"/>
         <xsd:enumeration value="SELECTABLE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="SWC-TO-ECU-MAPPING-CONSTRAINT-TYPE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="DEDICATED"/>
         <xsd:enumeration value="EXCLUSIVE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="SWC-TO-SWC-OPERATION-ARGUMENTS-DIRECTION-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="IN"/>
         <xsd:enumeration value="OUT"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="TIMER-COUNT-DIRECTION-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="DOWN"/>
         <xsd:enumeration value="SELECTABLE"/>
         <xsd:enumeration value="UP"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="TIMER-MODE-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CONTINUOUS"/>
         <xsd:enumeration value="FREE"/>
         <xsd:enumeration value="SINGLE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="TP-ACK-TYPE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="ACK-WITH-RT"/>
         <xsd:enumeration value="ACK-WITHOUT-RT"/>
         <xsd:enumeration value="NO-ACK"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="TRANSFER-PROPERTY-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="PENDING"/>
         <xsd:enumeration value="TRIGGERED"/>
         <xsd:enumeration value="TRIGGERED-ON-CHANGE"/>
         <xsd:enumeration value="TRIGGERED-ON-CHANGE-WITHOUT-REPETITION"/>
         <xsd:enumeration value="TRIGGERED-WITHOUT-REPETITION"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="TRIGGER-MODE">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="DYNAMIC-PART-TRIGGER"/>
         <xsd:enumeration value="NONE"/>
         <xsd:enumeration value="STATIC-OR-DYNAMIC-PART-TRIGGER"/>
         <xsd:enumeration value="STATIC-PART-TRIGGER"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="TT-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CODE"/>
         <xsd:enumeration value="CONTROL-ELEMENT"/>
         <xsd:enumeration value="MATERIAL"/>
         <xsd:enumeration value="ORGANISATION"/>
         <xsd:enumeration value="OTHER"/>
         <xsd:enumeration value="PRM"/>
         <xsd:enumeration value="PRODUCT"/>
         <xsd:enumeration value="SGML-ATTRIBUTE"/>
         <xsd:enumeration value="SGMLTAG"/>
         <xsd:enumeration value="STATE"/>
         <xsd:enumeration value="TOOL"/>
         <xsd:enumeration value="VARIABLE"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="TYPE-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="CONTENT-RELATED"/>
         <xsd:enumeration value="DOC-RELATED"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="WATCH-DOG-MODE-ENUM">
      <xsd:restriction base="xsd:string">
         <xsd:enumeration value="DEBUG"/>
         <xsd:enumeration value="NORMAL"/>
         <xsd:enumeration value="WINDOWED"/>
      </xsd:restriction>
   </xsd:simpleType>
   <!-- Predefined element and attribute types -->
   <xsd:simpleType name="IDENTIFIER">
      <xsd:restriction base="xsd:string">
         <xsd:pattern value="[a-zA-Z][a-zA-Z0-9_]{0,127}"/>
      </xsd:restriction>
   </xsd:simpleType>
   <xsd:simpleType name="REF">
      <xsd:restriction base="xsd:string">
         <!-- Pattern:
                 - first slash optional (relative or absolute reference)
                 - Identifier consisting of [letter][letter|digit|underscore] required
                 - optionally a sequence of slashes and Identifiers
         -->
         <xsd:pattern value="(/[a-zA-Z][a-zA-Z0-9_]{0,127})*"/>
      </xsd:restriction>
   </xsd:simpleType>
</xsd:schema>
